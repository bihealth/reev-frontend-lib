// @generated by protobuf-ts 2.9.3 with parameter keep_enum_prefix,long_type_string
// @generated from protobuf file "mehari/txs.proto" (package "mehari.txs", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import { WireType } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'

/**
 * Stores long array of sequences with an "index" of sequence names to their
 * index.
 *
 * The fields `aliases` and `aliases_idx` have the same length and `aliases_idx[i]`
 * stores the index into `seqs` for the sequence `aliases[i]`.  In other words.
 * `seqs[aliases_idx[i]]` stores the sequence for `aliases[i]`.
 *
 * @generated from protobuf message mehari.txs.SequenceDb
 */
export interface SequenceDb {
  /**
   * The sequence aliases, cf. `aliases_idx`.
   *
   * @generated from protobuf field: repeated string aliases = 1;
   */
  aliases: string[]
  /**
   * The corresponding index in `seqs`, cf. `aliases`.
   *
   * @generated from protobuf field: repeated uint32 aliases_idx = 2;
   */
  aliasesIdx: number[]
  /**
   * The corresponding sequences.
   *
   * @generated from protobuf field: repeated string seqs = 3;
   */
  seqs: string[]
}
/**
 * Mapping from gene to transcript ID.
 *
 * @generated from protobuf message mehari.txs.GeneToTxId
 */
export interface GeneToTxId {
  /**
   * Gene HGNC ID; serves as gene identifier.
   *
   * @generated from protobuf field: string gene_id = 1;
   */
  geneId: string
  /**
   * Vector of all transcript IDs.
   *
   * @generated from protobuf field: repeated string tx_ids = 2;
   */
  txIds: string[]
  /**
   * Whether this gene has been filtered out because of missing transcripts.
   *
   * @generated from protobuf field: optional bool filtered = 3;
   */
  filtered?: boolean
  /**
   * Reason for filtering.
   *
   * @generated from protobuf field: optional uint32 filter_reason = 4;
   */
  filterReason?: number
}
/**
 * Container for the transcript-related database.
 *
 * @generated from protobuf message mehari.txs.TranscriptDb
 */
export interface TranscriptDb {
  /**
   * Vector of all transcripts.
   *
   * @generated from protobuf field: repeated mehari.txs.Transcript transcripts = 1;
   */
  transcripts: Transcript[]
  /**
   * Mapping from gene ID to vector of all transcript IDs.
   *
   * @generated from protobuf field: repeated mehari.txs.GeneToTxId gene_to_tx = 2;
   */
  geneToTx: GeneToTxId[]
}
/**
 * Store information about a transcript.
 *
 * @generated from protobuf message mehari.txs.Transcript
 */
export interface Transcript {
  /**
   * Transcript accession with version, e.g., `"NM_007294.3"` or `"ENST00000461574.1"` for BRCA1.
   *
   * @generated from protobuf field: string id = 1;
   */
  id: string
  /**
   * HGNC symbol, e.g., `"BRCA1"`
   *
   * @generated from protobuf field: string gene_symbol = 2;
   */
  geneSymbol: string
  /**
   * HGNC gene identifier, e.g., `"1100"` for BRCA1.
   *
   * @generated from protobuf field: string gene_id = 3;
   */
  geneId: string
  /**
   * Transcript biotype.
   *
   * @generated from protobuf field: mehari.txs.TranscriptBiotype biotype = 4;
   */
  biotype: TranscriptBiotype
  /**
   * Transcript flags.
   *
   * @generated from protobuf field: repeated mehari.txs.TranscriptTag tags = 5;
   */
  tags: TranscriptTag[]
  /**
   * Identifier of the corresponding protein.
   *
   * @generated from protobuf field: optional string protein = 6;
   */
  protein?: string
  /**
   * CDS start codon.
   *
   * @generated from protobuf field: optional int32 start_codon = 7;
   */
  startCodon?: number
  /**
   * CDS stop codon.
   *
   * @generated from protobuf field: optional int32 stop_codon = 8;
   */
  stopCodon?: number
  /**
   * Alignments on the different genome builds.
   *
   * @generated from protobuf field: repeated mehari.txs.GenomeAlignment genome_alignments = 9;
   */
  genomeAlignments: GenomeAlignment[]
  /**
   * Whether this transcript has an issue (e.g. MissingStopCodon), cf. `mehari::db::create::mod::Reason`.
   *
   * @generated from protobuf field: optional bool filtered = 10;
   */
  filtered?: boolean
  /**
   * Reason for filtering.
   *
   * @generated from protobuf field: optional uint32 filter_reason = 11;
   */
  filterReason?: number
}
/**
 * Store information about a transcript aligning to a genome.
 *
 * @generated from protobuf message mehari.txs.GenomeAlignment
 */
export interface GenomeAlignment {
  /**
   * The genome build identifier.
   *
   * @generated from protobuf field: mehari.txs.GenomeBuild genome_build = 1;
   */
  genomeBuild: GenomeBuild
  /**
   * Accession of the contig sequence.
   *
   * @generated from protobuf field: string contig = 2;
   */
  contig: string
  /**
   * CDS end position, `-1` to indicate `None`.
   *
   * @generated from protobuf field: optional int32 cds_start = 3;
   */
  cdsStart?: number
  /**
   * CDS end position, `-1` to indicate `None`.
   *
   * @generated from protobuf field: optional int32 cds_end = 4;
   */
  cdsEnd?: number
  /**
   * The strand.
   *
   * @generated from protobuf field: mehari.txs.Strand strand = 5;
   */
  strand: Strand
  /**
   * Exons of the alignment.
   *
   * @generated from protobuf field: repeated mehari.txs.ExonAlignment exons = 6;
   */
  exons: ExonAlignment[]
}
/**
 * Store the alignment of one exon to the reference.
 *
 * @generated from protobuf message mehari.txs.ExonAlignment
 */
export interface ExonAlignment {
  /**
   * Start position on reference.
   *
   * @generated from protobuf field: int32 alt_start_i = 1;
   */
  altStartI: number
  /**
   * End position on reference.
   *
   * @generated from protobuf field: int32 alt_end_i = 2;
   */
  altEndI: number
  /**
   * Exon number.
   *
   * @generated from protobuf field: int32 ord = 3;
   */
  ord: number
  /**
   * CDS start coordinate.
   *
   * @generated from protobuf field: optional int32 alt_cds_start_i = 4;
   */
  altCdsStartI?: number
  /**
   * CDS end coordinate.
   *
   * @generated from protobuf field: optional int32 alt_cds_end_i = 5;
   */
  altCdsEndI?: number
  /**
   * CIGAR string of alignment, empty indicates full matches.
   *
   * @generated from protobuf field: string cigar = 6;
   */
  cigar: string
}
/**
 * Database of transcripts with sequences.
 *
 * @generated from protobuf message mehari.txs.TxSeqDatabase
 */
export interface TxSeqDatabase {
  /**
   * Store transcripts with their aliases.
   *
   * @generated from protobuf field: mehari.txs.TranscriptDb tx_db = 1;
   */
  txDb?: TranscriptDb
  /**
   * Store sequence with their aliases.
   *
   * @generated from protobuf field: mehari.txs.SequenceDb seq_db = 2;
   */
  seqDb?: SequenceDb
  /**
   * The version of the database.
   *
   * @generated from protobuf field: optional string version = 3;
   */
  version?: string
  /**
   * The reference assembly that this database refers to.
   *
   * @generated from protobuf field: optional string genome_release = 4;
   */
  genomeRelease?: string
}
/**
 * Enumeration for `Transcript::biotype`.
 *
 * @generated from protobuf enum mehari.txs.TranscriptBiotype
 */
export enum TranscriptBiotype {
  /**
   * unknown
   *
   * @generated from protobuf enum value: TRANSCRIPT_BIOTYPE_UNKNOWN = 0;
   */
  TRANSCRIPT_BIOTYPE_UNKNOWN = 0,
  /**
   * Coding transcript.
   *
   * @generated from protobuf enum value: TRANSCRIPT_BIOTYPE_CODING = 1;
   */
  TRANSCRIPT_BIOTYPE_CODING = 1,
  /**
   * Non-coding transcript.
   *
   * @generated from protobuf enum value: TRANSCRIPT_BIOTYPE_NON_CODING = 2;
   */
  TRANSCRIPT_BIOTYPE_NON_CODING = 2
}
/**
 * Bit values for the transcript tags.
 *
 * @generated from protobuf enum mehari.txs.TranscriptTag
 */
export enum TranscriptTag {
  /**
   * unknown
   *
   * @generated from protobuf enum value: TRANSCRIPT_TAG_UNKNOWN = 0;
   */
  TRANSCRIPT_TAG_UNKNOWN = 0,
  /**
   * Member of Ensembl basic.
   *
   * @generated from protobuf enum value: TRANSCRIPT_TAG_BASIC = 1;
   */
  TRANSCRIPT_TAG_BASIC = 1,
  /**
   * Member of Ensembl canonical.
   *
   * @generated from protobuf enum value: TRANSCRIPT_TAG_ENSEMBL_CANONICAL = 2;
   */
  TRANSCRIPT_TAG_ENSEMBL_CANONICAL = 2,
  /**
   * Member of MANE Select.
   *
   * @generated from protobuf enum value: TRANSCRIPT_TAG_MANE_SELECT = 3;
   */
  TRANSCRIPT_TAG_MANE_SELECT = 3,
  /**
   * Member of MANE Plus Clinical.
   *
   * @generated from protobuf enum value: TRANSCRIPT_TAG_MANE_PLUS_CLINICAL = 4;
   */
  TRANSCRIPT_TAG_MANE_PLUS_CLINICAL = 4,
  /**
   * Member of RefSeq Select.
   *
   * @generated from protobuf enum value: TRANSCRIPT_TAG_REF_SEQ_SELECT = 5;
   */
  TRANSCRIPT_TAG_REF_SEQ_SELECT = 5,
  /**
   * Flagged as being a selenoprotein (UGA => selenon).
   *
   * @generated from protobuf enum value: TRANSCRIPT_TAG_SELENOPROTEIN = 6;
   */
  TRANSCRIPT_TAG_SELENOPROTEIN = 6,
  /**
   * Member of GENCODE Primary
   *
   * @generated from protobuf enum value: TRANSCRIPT_TAG_GENCODE_PRIMARY = 7;
   */
  TRANSCRIPT_TAG_GENCODE_PRIMARY = 7
}
/**
 * Enumeration for the known genome builds.
 *
 * @generated from protobuf enum mehari.txs.GenomeBuild
 */
export enum GenomeBuild {
  /**
   * unknown
   *
   * @generated from protobuf enum value: GENOME_BUILD_UNKNOWN = 0;
   */
  GENOME_BUILD_UNKNOWN = 0,
  /**
   * GRCH37.
   *
   * @generated from protobuf enum value: GENOME_BUILD_GRCH37 = 1;
   */
  GENOME_BUILD_GRCH37 = 1,
  /**
   * GRCh38.
   *
   * @generated from protobuf enum value: GENOME_BUILD_GRCH38 = 2;
   */
  GENOME_BUILD_GRCH38 = 2
}
/**
 * Enumeration for the two strands of the genome.
 *
 * @generated from protobuf enum mehari.txs.Strand
 */
export enum Strand {
  /**
   * unknown
   *
   * @generated from protobuf enum value: STRAND_UNKNOWN = 0;
   */
  STRAND_UNKNOWN = 0,
  /**
   * Forward / plus
   *
   * @generated from protobuf enum value: STRAND_PLUS = 1;
   */
  STRAND_PLUS = 1,
  /**
   * Reverse / minus
   *
   * @generated from protobuf enum value: STRAND_MINUS = 2;
   */
  STRAND_MINUS = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class SequenceDb$Type extends MessageType<SequenceDb> {
  constructor() {
    super('mehari.txs.SequenceDb', [
      {
        no: 1,
        name: 'aliases',
        kind: 'scalar',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: 'aliases_idx',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 13 /*ScalarType.UINT32*/
      },
      {
        no: 3,
        name: 'seqs',
        kind: 'scalar',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/
      }
    ])
  }
  create(value?: PartialMessage<SequenceDb>): SequenceDb {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.aliases = []
    message.aliasesIdx = []
    message.seqs = []
    if (value !== undefined) reflectionMergePartial<SequenceDb>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SequenceDb
  ): SequenceDb {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated string aliases */ 1:
          message.aliases.push(reader.string())
          break
        case /* repeated uint32 aliases_idx */ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.aliasesIdx.push(reader.uint32())
          else message.aliasesIdx.push(reader.uint32())
          break
        case /* repeated string seqs */ 3:
          message.seqs.push(reader.string())
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: SequenceDb,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated string aliases = 1; */
    for (let i = 0; i < message.aliases.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.aliases[i])
    /* repeated uint32 aliases_idx = 2; */
    if (message.aliasesIdx.length) {
      writer.tag(2, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.aliasesIdx.length; i++) writer.uint32(message.aliasesIdx[i])
      writer.join()
    }
    /* repeated string seqs = 3; */
    for (let i = 0; i < message.seqs.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.seqs[i])
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message mehari.txs.SequenceDb
 */
export const SequenceDb = new SequenceDb$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GeneToTxId$Type extends MessageType<GeneToTxId> {
  constructor() {
    super('mehari.txs.GeneToTxId', [
      { no: 1, name: 'gene_id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: 'tx_ids',
        kind: 'scalar',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/
      },
      { no: 3, name: 'filtered', kind: 'scalar', opt: true, T: 8 /*ScalarType.BOOL*/ },
      { no: 4, name: 'filter_reason', kind: 'scalar', opt: true, T: 13 /*ScalarType.UINT32*/ }
    ])
  }
  create(value?: PartialMessage<GeneToTxId>): GeneToTxId {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.geneId = ''
    message.txIds = []
    if (value !== undefined) reflectionMergePartial<GeneToTxId>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GeneToTxId
  ): GeneToTxId {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string gene_id */ 1:
          message.geneId = reader.string()
          break
        case /* repeated string tx_ids */ 2:
          message.txIds.push(reader.string())
          break
        case /* optional bool filtered */ 3:
          message.filtered = reader.bool()
          break
        case /* optional uint32 filter_reason */ 4:
          message.filterReason = reader.uint32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: GeneToTxId,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string gene_id = 1; */
    if (message.geneId !== '') writer.tag(1, WireType.LengthDelimited).string(message.geneId)
    /* repeated string tx_ids = 2; */
    for (let i = 0; i < message.txIds.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.txIds[i])
    /* optional bool filtered = 3; */
    if (message.filtered !== undefined) writer.tag(3, WireType.Varint).bool(message.filtered)
    /* optional uint32 filter_reason = 4; */
    if (message.filterReason !== undefined)
      writer.tag(4, WireType.Varint).uint32(message.filterReason)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message mehari.txs.GeneToTxId
 */
export const GeneToTxId = new GeneToTxId$Type()
// @generated message type with reflection information, may provide speed optimized methods
class TranscriptDb$Type extends MessageType<TranscriptDb> {
  constructor() {
    super('mehari.txs.TranscriptDb', [
      {
        no: 1,
        name: 'transcripts',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Transcript
      },
      {
        no: 2,
        name: 'gene_to_tx',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => GeneToTxId
      }
    ])
  }
  create(value?: PartialMessage<TranscriptDb>): TranscriptDb {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.transcripts = []
    message.geneToTx = []
    if (value !== undefined) reflectionMergePartial<TranscriptDb>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TranscriptDb
  ): TranscriptDb {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated mehari.txs.Transcript transcripts */ 1:
          message.transcripts.push(Transcript.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated mehari.txs.GeneToTxId gene_to_tx */ 2:
          message.geneToTx.push(GeneToTxId.internalBinaryRead(reader, reader.uint32(), options))
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: TranscriptDb,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated mehari.txs.Transcript transcripts = 1; */
    for (let i = 0; i < message.transcripts.length; i++)
      Transcript.internalBinaryWrite(
        message.transcripts[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated mehari.txs.GeneToTxId gene_to_tx = 2; */
    for (let i = 0; i < message.geneToTx.length; i++)
      GeneToTxId.internalBinaryWrite(
        message.geneToTx[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message mehari.txs.TranscriptDb
 */
export const TranscriptDb = new TranscriptDb$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Transcript$Type extends MessageType<Transcript> {
  constructor() {
    super('mehari.txs.Transcript', [
      { no: 1, name: 'id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'gene_symbol', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'gene_id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 4,
        name: 'biotype',
        kind: 'enum',
        T: () => ['mehari.txs.TranscriptBiotype', TranscriptBiotype]
      },
      {
        no: 5,
        name: 'tags',
        kind: 'enum',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => ['mehari.txs.TranscriptTag', TranscriptTag]
      },
      { no: 6, name: 'protein', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 7, name: 'start_codon', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      { no: 8, name: 'stop_codon', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      {
        no: 9,
        name: 'genome_alignments',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => GenomeAlignment
      },
      { no: 10, name: 'filtered', kind: 'scalar', opt: true, T: 8 /*ScalarType.BOOL*/ },
      { no: 11, name: 'filter_reason', kind: 'scalar', opt: true, T: 13 /*ScalarType.UINT32*/ }
    ])
  }
  create(value?: PartialMessage<Transcript>): Transcript {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.id = ''
    message.geneSymbol = ''
    message.geneId = ''
    message.biotype = 0
    message.tags = []
    message.genomeAlignments = []
    if (value !== undefined) reflectionMergePartial<Transcript>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Transcript
  ): Transcript {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string()
          break
        case /* string gene_symbol */ 2:
          message.geneSymbol = reader.string()
          break
        case /* string gene_id */ 3:
          message.geneId = reader.string()
          break
        case /* mehari.txs.TranscriptBiotype biotype */ 4:
          message.biotype = reader.int32()
          break
        case /* repeated mehari.txs.TranscriptTag tags */ 5:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.tags.push(reader.int32())
          else message.tags.push(reader.int32())
          break
        case /* optional string protein */ 6:
          message.protein = reader.string()
          break
        case /* optional int32 start_codon */ 7:
          message.startCodon = reader.int32()
          break
        case /* optional int32 stop_codon */ 8:
          message.stopCodon = reader.int32()
          break
        case /* repeated mehari.txs.GenomeAlignment genome_alignments */ 9:
          message.genomeAlignments.push(
            GenomeAlignment.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* optional bool filtered */ 10:
          message.filtered = reader.bool()
          break
        case /* optional uint32 filter_reason */ 11:
          message.filterReason = reader.uint32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Transcript,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== '') writer.tag(1, WireType.LengthDelimited).string(message.id)
    /* string gene_symbol = 2; */
    if (message.geneSymbol !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.geneSymbol)
    /* string gene_id = 3; */
    if (message.geneId !== '') writer.tag(3, WireType.LengthDelimited).string(message.geneId)
    /* mehari.txs.TranscriptBiotype biotype = 4; */
    if (message.biotype !== 0) writer.tag(4, WireType.Varint).int32(message.biotype)
    /* repeated mehari.txs.TranscriptTag tags = 5; */
    if (message.tags.length) {
      writer.tag(5, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.tags.length; i++) writer.int32(message.tags[i])
      writer.join()
    }
    /* optional string protein = 6; */
    if (message.protein !== undefined)
      writer.tag(6, WireType.LengthDelimited).string(message.protein)
    /* optional int32 start_codon = 7; */
    if (message.startCodon !== undefined) writer.tag(7, WireType.Varint).int32(message.startCodon)
    /* optional int32 stop_codon = 8; */
    if (message.stopCodon !== undefined) writer.tag(8, WireType.Varint).int32(message.stopCodon)
    /* repeated mehari.txs.GenomeAlignment genome_alignments = 9; */
    for (let i = 0; i < message.genomeAlignments.length; i++)
      GenomeAlignment.internalBinaryWrite(
        message.genomeAlignments[i],
        writer.tag(9, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional bool filtered = 10; */
    if (message.filtered !== undefined) writer.tag(10, WireType.Varint).bool(message.filtered)
    /* optional uint32 filter_reason = 11; */
    if (message.filterReason !== undefined)
      writer.tag(11, WireType.Varint).uint32(message.filterReason)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message mehari.txs.Transcript
 */
export const Transcript = new Transcript$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GenomeAlignment$Type extends MessageType<GenomeAlignment> {
  constructor() {
    super('mehari.txs.GenomeAlignment', [
      {
        no: 1,
        name: 'genome_build',
        kind: 'enum',
        T: () => ['mehari.txs.GenomeBuild', GenomeBuild]
      },
      { no: 2, name: 'contig', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'cds_start', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      { no: 4, name: 'cds_end', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      { no: 5, name: 'strand', kind: 'enum', T: () => ['mehari.txs.Strand', Strand] },
      {
        no: 6,
        name: 'exons',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => ExonAlignment
      }
    ])
  }
  create(value?: PartialMessage<GenomeAlignment>): GenomeAlignment {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.genomeBuild = 0
    message.contig = ''
    message.strand = 0
    message.exons = []
    if (value !== undefined) reflectionMergePartial<GenomeAlignment>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GenomeAlignment
  ): GenomeAlignment {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* mehari.txs.GenomeBuild genome_build */ 1:
          message.genomeBuild = reader.int32()
          break
        case /* string contig */ 2:
          message.contig = reader.string()
          break
        case /* optional int32 cds_start */ 3:
          message.cdsStart = reader.int32()
          break
        case /* optional int32 cds_end */ 4:
          message.cdsEnd = reader.int32()
          break
        case /* mehari.txs.Strand strand */ 5:
          message.strand = reader.int32()
          break
        case /* repeated mehari.txs.ExonAlignment exons */ 6:
          message.exons.push(ExonAlignment.internalBinaryRead(reader, reader.uint32(), options))
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: GenomeAlignment,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* mehari.txs.GenomeBuild genome_build = 1; */
    if (message.genomeBuild !== 0) writer.tag(1, WireType.Varint).int32(message.genomeBuild)
    /* string contig = 2; */
    if (message.contig !== '') writer.tag(2, WireType.LengthDelimited).string(message.contig)
    /* optional int32 cds_start = 3; */
    if (message.cdsStart !== undefined) writer.tag(3, WireType.Varint).int32(message.cdsStart)
    /* optional int32 cds_end = 4; */
    if (message.cdsEnd !== undefined) writer.tag(4, WireType.Varint).int32(message.cdsEnd)
    /* mehari.txs.Strand strand = 5; */
    if (message.strand !== 0) writer.tag(5, WireType.Varint).int32(message.strand)
    /* repeated mehari.txs.ExonAlignment exons = 6; */
    for (let i = 0; i < message.exons.length; i++)
      ExonAlignment.internalBinaryWrite(
        message.exons[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message mehari.txs.GenomeAlignment
 */
export const GenomeAlignment = new GenomeAlignment$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ExonAlignment$Type extends MessageType<ExonAlignment> {
  constructor() {
    super('mehari.txs.ExonAlignment', [
      { no: 1, name: 'alt_start_i', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 2, name: 'alt_end_i', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 3, name: 'ord', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 4, name: 'alt_cds_start_i', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      { no: 5, name: 'alt_cds_end_i', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      { no: 6, name: 'cigar', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(value?: PartialMessage<ExonAlignment>): ExonAlignment {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.altStartI = 0
    message.altEndI = 0
    message.ord = 0
    message.cigar = ''
    if (value !== undefined) reflectionMergePartial<ExonAlignment>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ExonAlignment
  ): ExonAlignment {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* int32 alt_start_i */ 1:
          message.altStartI = reader.int32()
          break
        case /* int32 alt_end_i */ 2:
          message.altEndI = reader.int32()
          break
        case /* int32 ord */ 3:
          message.ord = reader.int32()
          break
        case /* optional int32 alt_cds_start_i */ 4:
          message.altCdsStartI = reader.int32()
          break
        case /* optional int32 alt_cds_end_i */ 5:
          message.altCdsEndI = reader.int32()
          break
        case /* string cigar */ 6:
          message.cigar = reader.string()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ExonAlignment,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* int32 alt_start_i = 1; */
    if (message.altStartI !== 0) writer.tag(1, WireType.Varint).int32(message.altStartI)
    /* int32 alt_end_i = 2; */
    if (message.altEndI !== 0) writer.tag(2, WireType.Varint).int32(message.altEndI)
    /* int32 ord = 3; */
    if (message.ord !== 0) writer.tag(3, WireType.Varint).int32(message.ord)
    /* optional int32 alt_cds_start_i = 4; */
    if (message.altCdsStartI !== undefined)
      writer.tag(4, WireType.Varint).int32(message.altCdsStartI)
    /* optional int32 alt_cds_end_i = 5; */
    if (message.altCdsEndI !== undefined) writer.tag(5, WireType.Varint).int32(message.altCdsEndI)
    /* string cigar = 6; */
    if (message.cigar !== '') writer.tag(6, WireType.LengthDelimited).string(message.cigar)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message mehari.txs.ExonAlignment
 */
export const ExonAlignment = new ExonAlignment$Type()
// @generated message type with reflection information, may provide speed optimized methods
class TxSeqDatabase$Type extends MessageType<TxSeqDatabase> {
  constructor() {
    super('mehari.txs.TxSeqDatabase', [
      { no: 1, name: 'tx_db', kind: 'message', T: () => TranscriptDb },
      { no: 2, name: 'seq_db', kind: 'message', T: () => SequenceDb },
      { no: 3, name: 'version', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: 'genome_release', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(value?: PartialMessage<TxSeqDatabase>): TxSeqDatabase {
    const message = globalThis.Object.create(this.messagePrototype!)
    if (value !== undefined) reflectionMergePartial<TxSeqDatabase>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TxSeqDatabase
  ): TxSeqDatabase {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* mehari.txs.TranscriptDb tx_db */ 1:
          message.txDb = TranscriptDb.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.txDb
          )
          break
        case /* mehari.txs.SequenceDb seq_db */ 2:
          message.seqDb = SequenceDb.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.seqDb
          )
          break
        case /* optional string version */ 3:
          message.version = reader.string()
          break
        case /* optional string genome_release */ 4:
          message.genomeRelease = reader.string()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: TxSeqDatabase,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* mehari.txs.TranscriptDb tx_db = 1; */
    if (message.txDb)
      TranscriptDb.internalBinaryWrite(
        message.txDb,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* mehari.txs.SequenceDb seq_db = 2; */
    if (message.seqDb)
      SequenceDb.internalBinaryWrite(
        message.seqDb,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional string version = 3; */
    if (message.version !== undefined)
      writer.tag(3, WireType.LengthDelimited).string(message.version)
    /* optional string genome_release = 4; */
    if (message.genomeRelease !== undefined)
      writer.tag(4, WireType.LengthDelimited).string(message.genomeRelease)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message mehari.txs.TxSeqDatabase
 */
export const TxSeqDatabase = new TxSeqDatabase$Type()
