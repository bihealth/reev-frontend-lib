// @generated by protobuf-ts 2.9.3 with parameter keep_enum_prefix,long_type_string
// @generated from protobuf file "annonars/clinvar_data/clinvar_public.proto" (package "annonars.clinvar_data.clinvar_public", syntax proto3)
// tslint:disable
//
// Protobuf file for representing the types from the ClinVar VCV XSD file.
//
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'

import { Timestamp } from '../../google/protobuf/timestamp'

/**
 * A structure to support reporting unformatted content, with type and
 * source specified.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.Comment
 */
export interface Comment {
  /**
   * The comment's value.
   *
   * @generated from protobuf field: string value = 1;
   */
  value: string
  /**
   * The optional comment data source.
   *
   * @generated from protobuf field: optional string data_source = 2;
   */
  dataSource?: string
  /**
   * The comment's type.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.CommentType type = 3;
   */
  type?: CommentType
}
/**
 * This structure is used to represent how an object described in the
 * submission relates to objects in other databases.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.Xref
 */
export interface Xref {
  /**
   * The name of the database. When there is an overlap with sequence
   * databases, that name is used.
   *
   * @generated from protobuf field: string db = 1;
   */
  db: string
  /**
   * The identifier used by the database. Being exported as a string
   * even though internally the database has rules for defining which datases use
   * integer identifers.
   *
   * @generated from protobuf field: string id = 2;
   */
  id: string
  /**
   * Used to differentiate between different types of identifiers that
   * a database may provide.
   *
   * @generated from protobuf field: optional string type = 3;
   */
  type?: string
  /**
   * Optional URL to the database entry.
   *
   * @generated from protobuf field: optional string url = 4;
   */
  url?: string
  /**
   * The status; defaults to "current".
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.Status status = 5;
   */
  status?: Status
}
/**
 * Description of a citation.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.Citation
 */
export interface Citation {
  // nested elements

  /**
   * Optional list of IDs.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Citation.IdType ids = 1;
   */
  ids: Citation_IdType[]
  /**
   * Optional URL.
   *
   * @generated from protobuf field: optional string url = 2;
   */
  url?: string
  /**
   * Optional citation text.
   *
   * @generated from protobuf field: optional string citation_text = 3;
   */
  citationText?: string
  // attributes

  /**
   * This maintained distinct from publication types in PubMed and
   * established by GTR curators.  The default is 'general'.
   *
   * @generated from protobuf field: optional string type = 4;
   */
  type?: string
  /**
   * Corresponds to the abbreviation reported by GTR.
   *
   * @generated from protobuf field: optional string abbrev = 5;
   */
  abbrev?: string
}
/**
 * Local ID with source.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.Citation.IdType
 */
export interface Citation_IdType {
  /**
   * The citation's value.
   *
   * @generated from protobuf field: string value = 1;
   */
  value: string
  /**
   * If there is an identifier, what database provides it.
   *
   * @generated from protobuf field: string source = 2;
   */
  source: string
}
/**
 * The attribute is a general element to represent a defined set of data
 * qualified by an enumerated set of types. For each attribute element, the value will
 * be a character string and is optional. Source shall be used to store identifiers for
 * supplied data from source other than the submitter (e.g. SequenceOntology). The data
 * submitted where Type="variation" shall be validated against sequence_alternation in
 * Sequence Ontology http://www.sequenceontology.org/. This is to be a generic version
 * of AttributeType and should be used with extension when it is used to specify Type
 * and its enumerations.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.BaseAttribute
 */
export interface BaseAttribute {
  /**
   * The attribute's value; can be empty.
   *
   * @generated from protobuf field: optional string value = 1;
   */
  value?: string
  /**
   * The optional integer value.
   *
   * @generated from protobuf field: optional int64 integer_value = 2;
   */
  integerValue?: string
  /**
   * The optional date value.
   *
   * @generated from protobuf field: optional google.protobuf.Timestamp date_value = 3;
   */
  dateValue?: Timestamp
}
/**
 * Description of a nucleotide sequence expression.
 *
 * Corresponds to `typeNucleotideSequenceExpression`
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.HgvsNucleotideExpression
 */
export interface HgvsNucleotideExpression {
  /**
   * The expression values.
   *
   * @generated from protobuf field: string expression = 1;
   */
  expression: string
  /**
   * The type of the nucleotide sequence.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.NucleotideSequence sequence_type = 2;
   */
  sequenceType?: NucleotideSequence
  /**
   * Optional sequence accession version.
   *
   * @generated from protobuf field: optional string sequence_accession_version = 3;
   */
  sequenceAccessionVersion?: string
  /**
   * Optional sequence accession.
   *
   * @generated from protobuf field: optional string sequence_accession = 4;
   */
  sequenceAccession?: string
  /**
   * Optional sequence version.
   *
   * @generated from protobuf field: optional int32 sequence_version = 5;
   */
  sequenceVersion?: number
  /**
   * Optional description of the change.
   *
   * @generated from protobuf field: optional string change = 6;
   */
  change?: string
  /**
   * Optional assembly information.
   *
   * @generated from protobuf field: optional string assembly = 7;
   */
  assembly?: string
  /**
   * Optional submission information.
   *
   * @generated from protobuf field: optional string submitted = 8;
   */
  submitted?: string
  /**
   * Optional MANE Select flag.
   *
   * @generated from protobuf field: optional bool mane_select = 9;
   */
  maneSelect?: boolean
  /**
   * Optional MANE Plus Clinical flag.
   *
   * @generated from protobuf field: optional bool mane_plus_clinical = 10;
   */
  manePlusClinical?: boolean
}
/**
 * Description of a protein sequence expression.
 *
 * Corresponds to `typeProteinSequenceExpression` in XSD.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.HgvsProteinExpression
 */
export interface HgvsProteinExpression {
  /**
   * The expression values.
   *
   * @generated from protobuf field: string expression = 1;
   */
  expression: string
  /**
   * Optional sequence accession version.
   *
   * @generated from protobuf field: optional string sequence_accession_version = 2;
   */
  sequenceAccessionVersion?: string
  /**
   * Optional sequence accession.
   *
   * @generated from protobuf field: optional string sequence_accession = 3;
   */
  sequenceAccession?: string
  /**
   * Optional sequence version.
   *
   * @generated from protobuf field: optional int32 sequence_version = 4;
   */
  sequenceVersion?: number
  /**
   * Optional description of the change.
   *
   * @generated from protobuf field: optional string change = 5;
   */
  change?: string
}
/**
 * A structure to represent an HGVS expression for a nucleotide sequence
 * variant, along with the predicted protein change and the predicted molecular
 * consequence. Also used to represent only the protein change if that is all that has
 * been reported.
 *
 * Corresponds to `typeHVSExpression` in XSD.
 *
 * nested elements
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.HgvsExpression
 */
export interface HgvsExpression {
  /**
   * Optional nucleotide sequence expression.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.HgvsNucleotideExpression nucleotide_expression = 1;
   */
  nucleotideExpression?: HgvsNucleotideExpression
  /**
   * Optional protein sequence expression.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.HgvsProteinExpression protein_expression = 2;
   */
  proteinExpression?: HgvsProteinExpression
  /**
   * List of molecular consequences.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Xref molecular_consequences = 3;
   */
  molecularConsequences: Xref[]
  // attributes

  /**
   * Type of HGVS expression.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.HgvsType type = 4;
   */
  type: HgvsType
  /**
   * Optional assembly.
   *
   * @generated from protobuf field: optional string assembly = 5;
   */
  assembly?: string
}
// // Phenotype list details.
// message PhenotypeListDetailsType {
//   // Local type for phenotype.
//   message Phenotype {
//     message XRefList {
//       repeated Xref xrefs = 1;
//     }

//     /* nested elements */
//     repeated XRefList xref_list = 1;

//     /* attributes */

//     // `name` attribute
//     string name = 2;
//     // `target_id` attribute
//     int64 target_id = 3;
//     // `AffectedStatus` attribute.
//     optional string affected_status = 4;
//   }

//   /* nested elements */

//   // List phenotypes.
//   repeated Phenotype phenotypes = 1;
//   // List of phenotype details.
//   repeated PhenotypeDetails phenotype_details = 2;

//   /* attributes */

//   // Type of the phenotype set.
//   PhenotypeSetType phenotype_set_type = 3;
// }

/**
 * Description of a software.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.Software
 */
export interface Software {
  /**
   * Name of the software.
   *
   * @generated from protobuf field: string name = 1;
   */
  name: string
  /**
   * Version of the software; optional.
   *
   * @generated from protobuf field: optional string version = 2;
   */
  version?: string
  /**
   * Purpose of the software; optional.
   *
   * @generated from protobuf field: optional string purpose = 3;
   */
  purpose?: string
}
/**
 * Description of the history of a record.
 *
 * Called ``typeDescriptionHistory`` in XSD.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.DescriptionHistory
 */
export interface DescriptionHistory {
  /**
   * The pathogenicity description.
   *
   * @generated from protobuf field: string description = 1;
   */
  description: string
  /**
   * The date of the description.
   *
   * @generated from protobuf field: optional google.protobuf.Timestamp dated = 2;
   */
  dated?: Timestamp
}
/**
 * Entry in an element set.
 *
 * Called ``SetElementSetType`` in XSD.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.GenericSetElement
 */
export interface GenericSetElement {
  /**
   * The element's value.
   *
   * @generated from protobuf field: string value = 1;
   */
  value: string
  /**
   * The element's type.
   *
   * @generated from protobuf field: string type = 2;
   */
  type: string
  /**
   * List of citations.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Citation citations = 3;
   */
  citations: Citation[]
  /**
   * List of xrefs.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 4;
   */
  xrefs: Xref[]
  /**
   * List of comments.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Comment comments = 5;
   */
  comments: Comment[]
}
/**
 * Common type for an entry in a set of attributes.
 *
 * Called ``typeAttributeSet`` in XSD.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.AttributeSetElement
 */
export interface AttributeSetElement {
  /**
   * The attribute value.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.AttributeSetElement.Attribute attribute = 1;
   */
  attribute?: AttributeSetElement_Attribute
  /**
   * List of xrefs.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 2;
   */
  xrefs: Xref[]
  /**
   * List of citations.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Citation citations = 3;
   */
  citations: Citation[]
  /**
   * List of comments.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Comment comments = 4;
   */
  comments: Comment[]
}
/**
 * Extend the BaseAttribute with a `type` field.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.AttributeSetElement.Attribute
 */
export interface AttributeSetElement_Attribute {
  /**
   * The base value.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.BaseAttribute base = 1;
   */
  base?: BaseAttribute
  /**
   * The type of the attribute.
   *
   * @generated from protobuf field: string type = 2;
   */
  type: string
}
/**
 * Type to describe traits in various places.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.Trait
 */
export interface Trait {
  /**
   * names
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.GenericSetElement names = 1;
   */
  names: GenericSetElement[]
  /**
   * symbols
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.GenericSetElement symbols = 2;
   */
  symbols: GenericSetElement[]
  /**
   * attributes
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.AttributeSetElement attributes = 3;
   */
  attributes: AttributeSetElement[]
  /**
   * Trait relationships
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Trait.TraitRelationship trait_relationships = 4;
   */
  traitRelationships: Trait_TraitRelationship[]
  /**
   * Citation list.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Citation citations = 5;
   */
  citations: Citation[]
  /**
   * Xref list.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 6;
   */
  xrefs: Xref[]
  /**
   * Comment list.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Comment comments = 7;
   */
  comments: Comment[]
  /**
   * Sources
   *
   * @generated from protobuf field: repeated string sources = 8;
   */
  sources: string[]
}
/**
 * Local type for trait relationship.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.Trait.TraitRelationship
 */
export interface Trait_TraitRelationship {
  // nested elements

  /**
   * Name(s) of the trait.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.GenericSetElement names = 1;
   */
  names: GenericSetElement[]
  /**
   * Citation list.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Citation citations = 2;
   */
  citations: Citation[]
  /**
   * Xref list.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 3;
   */
  xrefs: Xref[]
  /**
   * Comment list.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Comment comments = 4;
   */
  comments: Comment[]
  /**
   * Sources
   *
   * @generated from protobuf field: repeated string sources = 5;
   */
  sources: string[]
  // attributes

  /**
   * Trait type.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.Trait.TraitRelationship.Type type = 6;
   */
  type: Trait_TraitRelationship_Type
}
/**
 * Local enumeration for trait types.
 *
 * NB: only DrugResponseAndDisease is used in the XML.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.Trait.TraitRelationship.Type
 */
export enum Trait_TraitRelationship_Type {
  /**
   * unspecified trait type
   *
   * @generated from protobuf enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,
  /**
   * corresponds to "phenotype"
   *
   * @generated from protobuf enum value: TYPE_PHENOTYPE = 1;
   */
  TYPE_PHENOTYPE = 1,
  /**
   * corresponds to "Subphenotype"
   *
   * @generated from protobuf enum value: TYPE_SUBPHENOTYPE = 2;
   */
  TYPE_SUBPHENOTYPE = 2,
  /**
   * corresponds to "DrugResponseAndDisease"
   *
   * @generated from protobuf enum value: TYPE_DRUG_RESPONSE_AND_DISEASE = 3;
   */
  TYPE_DRUG_RESPONSE_AND_DISEASE = 3,
  /**
   * corresponds to "co-occuring condition"
   *
   * @generated from protobuf enum value: TYPE_CO_OCCURING_CONDITION = 4;
   */
  TYPE_CO_OCCURING_CONDITION = 4,
  /**
   * corresponds to "Finding member"
   *
   * @generated from protobuf enum value: TYPE_FINDING_MEMBER = 5;
   */
  TYPE_FINDING_MEMBER = 5
}
/**
 * Describes an indication.
 *
 * NB: Called "IndicationType" in the XSD.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.Indication
 */
export interface Indication {
  // nested elements

  /**
   * Represents the value for the test indication as a name of a trait.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Trait traits = 1;
   */
  traits: Trait[]
  /**
   * List of names.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.GenericSetElement names = 2;
   */
  names: GenericSetElement[]
  /**
   * List of attributes.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.AttributeSetElement attributes = 3;
   */
  attributes: AttributeSetElement[]
  /**
   * List of xrefs.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 4;
   */
  xrefs: Xref[]
  /**
   * List of citations.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Citation citations = 5;
   */
  citations: Citation[]
  /**
   * List of comments.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Comment comments = 6;
   */
  comments: Comment[]
  // attributes

  /**
   * The type of indication.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.Indication.Type type = 7;
   */
  type: Indication_Type
}
/**
 * Enumeration for the indication type.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.Indication.Type
 */
export enum Indication_Type {
  /**
   * unspecified indication type.
   *
   * @generated from protobuf enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,
  /**
   * corresponds to "Indication"
   *
   * @generated from protobuf enum value: TYPE_INDICATION = 1;
   */
  TYPE_INDICATION = 1
}
/**
 * A set of ``Trait`` objects.
 *
 * NB: Called "ClinAsserTraitSetType" in the XSD.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.TraitSet
 */
export interface TraitSet {
  // nested elements

  /**
   * The traits.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Trait traits = 1;
   */
  traits: Trait[]
  /**
   * The names.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.GenericSetElement names = 2;
   */
  names: GenericSetElement[]
  /**
   * The symbols.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.GenericSetElement symbols = 3;
   */
  symbols: GenericSetElement[]
  /**
   * The attributes.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.AttributeSetElement attributes = 4;
   */
  attributes: AttributeSetElement[]
  /**
   * List of xrefs.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 5;
   */
  xrefs: Xref[]
  /**
   * List of citations.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Citation citations = 6;
   */
  citations: Citation[]
  /**
   * List of comments.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Comment comments = 7;
   */
  comments: Comment[]
  // attributes

  /**
   * The type.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.TraitSet.Type type = 8;
   */
  type: TraitSet_Type
  /**
   * Date of last evaluation.
   *
   * @generated from protobuf field: optional google.protobuf.Timestamp date_last_evaluated = 9;
   */
  dateLastEvaluated?: Timestamp
  /**
   * ID.
   *
   * @generated from protobuf field: optional int64 id = 10;
   */
  id?: string
  /**
   * Whether contributes to aggregate classification.
   *
   * @generated from protobuf field: optional bool contributes_to_aggregate_classification = 11;
   */
  contributesToAggregateClassification?: boolean
  /**
   * Lower level of evidence.
   *
   * @generated from protobuf field: optional bool lower_level_of_evidence = 12;
   */
  lowerLevelOfEvidence?: boolean
  /**
   * Explanation of or multiple conditions.
   *
   * @generated from protobuf field: optional string multiple_condition_explanation = 13;
   */
  multipleConditionExplanation?: string
}
/**
 * Local type.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.TraitSet.Type
 */
export enum TraitSet_Type {
  /**
   * unspecified type
   *
   * @generated from protobuf enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,
  /**
   * corresponds to "Disease"
   *
   * @generated from protobuf enum value: TYPE_DISEASE = 1;
   */
  TYPE_DISEASE = 1,
  /**
   * corresponds to "DrugResponse"
   *
   * @generated from protobuf enum value: TYPE_DRUG_RESPONSE = 2;
   */
  TYPE_DRUG_RESPONSE = 2,
  /**
   * corresponds to "Finding"
   *
   * @generated from protobuf enum value: TYPE_FINDING = 3;
   */
  TYPE_FINDING = 3,
  /**
   * corresponds to "PhenotypeInstruction"
   *
   * @generated from protobuf enum value: TYPE_PHENOTYPE_INSTRUCTION = 4;
   */
  TYPE_PHENOTYPE_INSTRUCTION = 4,
  /**
   * corresponds to "TraitChoice"
   *
   * @generated from protobuf enum value: TYPE_TRAIT_CHOICE = 5;
   */
  TYPE_TRAIT_CHOICE = 5
}
/**
 * Aggregated germline classification info.
 *
 * Corresponds to ``typeAggregatedGermlineClassification`` in XSD.
 *
 * nested elements
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.AggregatedGermlineClassification
 */
export interface AggregatedGermlineClassification {
  /**
   * The aggregate review status based on all germline submissions
   * for this record.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.AggregateGermlineReviewStatus review_status = 1;
   */
  reviewStatus: AggregateGermlineReviewStatus
  /**
   * We are not providing an enumeration for the values we report
   * for germline classification within the xsd. Details are in
   * https://github.com/ncbi/clinvar/ClassificationOnClinVar.md
   *
   *
   * @generated from protobuf field: optional string description = 2;
   */
  description?: string
  /**
   * Explanation is used only when the description is 'conflicting
   * data from submitters' The element summarizes the conflict.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.Comment explanation = 3;
   */
  explanation?: Comment
  /**
   * List of xrefs.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 4;
   */
  xrefs: Xref[]
  /**
   * List of citations.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Citation citations = 5;
   */
  citations: Citation[]
  /**
   * List of comments.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Comment comments = 6;
   */
  comments: Comment[]
  /**
   * History information.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.DescriptionHistory history_records = 7;
   */
  historyRecords: DescriptionHistory[]
  /**
   * List of conditions.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.TraitSet conditions = 8;
   */
  conditions: TraitSet[]
  // attributes

  /**
   * Date of last evaluation.
   *
   * @generated from protobuf field: optional google.protobuf.Timestamp date_last_evaluated = 9;
   */
  dateLastEvaluated?: Timestamp
  /**
   * Date of creation.
   *
   * @generated from protobuf field: google.protobuf.Timestamp date_created = 10;
   */
  dateCreated?: Timestamp
  /**
   * Date of most recent submission.
   *
   * @generated from protobuf field: google.protobuf.Timestamp most_recent_submission = 11;
   */
  mostRecentSubmission?: Timestamp
  /**
   * Number of submitters.
   *
   * @generated from protobuf field: optional int32 number_of_submitters = 12;
   */
  numberOfSubmitters?: number
  /**
   * Number of submissions.
   *
   * @generated from protobuf field: optional int32 number_of_submissions = 13;
   */
  numberOfSubmissions?: number
}
/**
 * Aggregated somatic clinical impact info.
 *
 * nested elements
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.AggregatedSomaticClinicalImpact
 */
export interface AggregatedSomaticClinicalImpact {
  /**
   * The aggregate review status based on all somatic clinical
   * impact submissions for this record.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.AggregateSomaticClinicalImpactReviewStatus review_status = 1;
   */
  reviewStatus: AggregateSomaticClinicalImpactReviewStatus
  /**
   * We are not providing an enumeration for the values we report
   * for somatic clinical impact classification within the xsd. Details are in
   * https://github.com/ncbi/clinvar/ClassificationOnClinVar.md
   *
   * @generated from protobuf field: optional string description = 2;
   */
  description?: string
  /**
   * List of xrefs.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 3;
   */
  xrefs: Xref[]
  /**
   * List of citations.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Citation citations = 4;
   */
  citations: Citation[]
  /**
   * List of comments.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Comment comments = 5;
   */
  comments: Comment[]
  /**
   * History information.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.DescriptionHistory history_records = 6;
   */
  historyRecords: DescriptionHistory[]
  /**
   * List of conditions.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.TraitSet conditions = 7;
   */
  conditions: TraitSet[]
  // attributes

  /**
   * Date of last evaluation.
   *
   * @generated from protobuf field: optional google.protobuf.Timestamp date_last_evaluated = 8;
   */
  dateLastEvaluated?: Timestamp
  /**
   * Date of creation.
   *
   * @generated from protobuf field: google.protobuf.Timestamp date_created = 9;
   */
  dateCreated?: Timestamp
  /**
   * Date of most recent submission.
   *
   * @generated from protobuf field: google.protobuf.Timestamp most_recent_submission = 10;
   */
  mostRecentSubmission?: Timestamp
  /**
   * Number of submitters.
   *
   * @generated from protobuf field: optional int32 number_of_submitters = 11;
   */
  numberOfSubmitters?: number
  /**
   * Number of submissions.
   *
   * @generated from protobuf field: optional int32 number_of_submissions = 12;
   */
  numberOfSubmissions?: number
}
/**
 * Aggregated oncogenicity classification info.
 *
 * nested elements
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.AggregatedOncogenicityClassification
 */
export interface AggregatedOncogenicityClassification {
  /**
   * The aggregate review status based on all somatic clinical
   * impact submissions for this record.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.AggregateOncogenicityReviewStatus review_status = 1;
   */
  reviewStatus: AggregateOncogenicityReviewStatus
  /**
   * We are not providing an enumeration for the values we report
   * for somatic clinical impact classification within the xsd. Details are in
   * https://github.com/ncbi/clinvar/ClassificationOnClinVar.md
   *
   * @generated from protobuf field: optional string description = 2;
   */
  description?: string
  /**
   * List of xrefs.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 3;
   */
  xrefs: Xref[]
  /**
   * List of citations.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Citation citations = 4;
   */
  citations: Citation[]
  /**
   * List of comments.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Comment comments = 5;
   */
  comments: Comment[]
  /**
   * History information.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.DescriptionHistory history_records = 6;
   */
  historyRecords: DescriptionHistory[]
  /**
   * List of conditions.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.TraitSet conditions = 7;
   */
  conditions: TraitSet[]
  // attributes

  /**
   * Date of last evaluation.
   *
   * @generated from protobuf field: optional google.protobuf.Timestamp date_last_evaluated = 8;
   */
  dateLastEvaluated?: Timestamp
  /**
   * Date of creation.
   *
   * @generated from protobuf field: google.protobuf.Timestamp date_created = 9;
   */
  dateCreated?: Timestamp
  /**
   * Date of most recent submission.
   *
   * @generated from protobuf field: google.protobuf.Timestamp most_recent_submission = 10;
   */
  mostRecentSubmission?: Timestamp
  /**
   * Number of submitters.
   *
   * @generated from protobuf field: optional int32 number_of_submitters = 11;
   */
  numberOfSubmitters?: number
  /**
   * Number of submissions.
   *
   * @generated from protobuf field: optional int32 number_of_submissions = 12;
   */
  numberOfSubmissions?: number
}
/**
 * Used to bundle different types of Classifications (germline,
 * oncogenic, somatic clinical impact) ; Supports summary as
 * well as submission details.
 *
 * NB: called "typeAggregateClassificationSet" in XSD.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.AggregateClassificationSet
 */
export interface AggregateClassificationSet {
  /**
   * The aggregate germline classification.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.AggregatedGermlineClassification germline_classification = 1;
   */
  germlineClassification?: AggregatedGermlineClassification
  /**
   * The aggregate somatic clinical impact.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.AggregatedSomaticClinicalImpact somatic_clinical_impact = 2;
   */
  somaticClinicalImpact?: AggregatedSomaticClinicalImpact
  /**
   * The aggregate oncogenicity classification.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.AggregatedOncogenicityClassification oncogenicity_classification = 3;
   */
  oncogenicityClassification?: AggregatedOncogenicityClassification
}
/**
 * Describes the clinical significance of a variant.
 *
 * Corresponds to `ClinicalSignificanceType` in XSD.
 *
 * contained elements
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.ClinicalSignificance
 */
export interface ClinicalSignificance {
  /**
   * The optional review status.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.SubmitterReviewStatus review_status = 1;
   */
  reviewStatus?: SubmitterReviewStatus
  /**
   * Structure used to support old data of AlleleDescriptionSet
   * within Co-occurenceSet.
   *
   * NB: unused in XML
   *
   * @generated from protobuf field: optional string description = 2;
   */
  description?: string
  /**
   * Optional explanatory comment.
   *
   * Explanation is used only when the description is 'conflicting
   * data from submitters' The element summarizes the conflict.
   *
   * NB: unused in XML
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.Comment explanation = 3;
   */
  explanation?: Comment
  /**
   * Optional list of xrefs.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 4;
   */
  xrefs: Xref[]
  /**
   * Optional list of citations.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Citation citations = 5;
   */
  citations: Citation[]
  /**
   * Optional list of comments.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Comment comments = 6;
   */
  comments: Comment[]
  // attributes

  /**
   * Date of last evaluation.
   *
   * NB: unused in XML
   *
   * @generated from protobuf field: optional google.protobuf.Timestamp date_last_evaluated = 7;
   */
  dateLastEvaluated?: Timestamp
}
/**
 * This is to be used within co-occurrence set.
 *
 * Corresponds to `typeAlleleDescr` in XSD.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.AlleleDescription
 */
export interface AlleleDescription {
  /**
   * The name of the allele.
   *
   * @generated from protobuf field: string name = 1;
   */
  name: string
  /**
   * Optional relative orientation.
   *
   * NB: Unused in XML
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.AlleleDescription.RelativeOrientation relative_orientation = 2;
   */
  relativeOrientation?: AlleleDescription_RelativeOrientation
  /**
   * Optional zygosity.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.Zygosity zygosity = 3;
   */
  zygosity?: Zygosity
  /**
   * Optional clinical significance.
   *
   * Corresponds to `ClinicalSignificanceType` in XSD.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.ClinicalSignificance clinical_significance = 4;
   */
  clinicalSignificance?: ClinicalSignificance
}
/**
 * Enumeration for relative orientation.
 *
 * NB: unused in XML
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.AlleleDescription.RelativeOrientation
 */
export enum AlleleDescription_RelativeOrientation {
  /**
   * unspecified relative orientation
   *
   * @generated from protobuf enum value: RELATIVE_ORIENTATION_UNSPECIFIED = 0;
   */
  RELATIVE_ORIENTATION_UNSPECIFIED = 0,
  /**
   * corresponds to "cis"
   *
   * @generated from protobuf enum value: RELATIVE_ORIENTATION_CIS = 1;
   */
  RELATIVE_ORIENTATION_CIS = 1,
  /**
   * corresponds to "trans"
   *
   * @generated from protobuf enum value: RELATIVE_ORIENTATION_TRANS = 2;
   */
  RELATIVE_ORIENTATION_TRANS = 2,
  /**
   * corresponds to "unknown"
   *
   * @generated from protobuf enum value: RELATIVE_ORIENTATION_UNKNOWN = 3;
   */
  RELATIVE_ORIENTATION_UNKNOWN = 3
}
/**
 * A structure to support reporting of an accession, its version, the
 * date its status changed, and text describing that change.
 *
 * Corresponds to `typeRecordHistory` in XSD.
 *
 * nested elements
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.RecordHistory
 */
export interface RecordHistory {
  /**
   * Optional comment on the history record.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.Comment comment = 1;
   */
  comment?: Comment
  // attributes

  /**
   * The accession.
   *
   * @generated from protobuf field: string accession = 2;
   */
  accession: string
  /**
   * The version.
   *
   * @generated from protobuf field: int32 version = 3;
   */
  version: number
  /**
   * The date the record.
   *
   * @generated from protobuf field: google.protobuf.Timestamp date_changed = 4;
   */
  dateChanged?: Timestamp
  /**
   * Attribute @VaritionID is only populated for VCV, where @Accession
   * is like VCV000000009
   *
   * @generated from protobuf field: optional int64 variation_id = 5;
   */
  variationId?: string
}
/**
 * Report classification of a variant for a SCV.
 *
 * Corresponds to `ClassificationTypeSCV` in XSD.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.ClassificationScv
 */
export interface ClassificationScv {
  // nested elements

  /**
   * The field's review status.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.SubmitterReviewStatus review_status = 1;
   */
  reviewStatus: SubmitterReviewStatus
  /**
   * The germline classification; mutually exlusive with `somatic_clinical_impact`
   * and `oncogenicity_classification`.
   *
   * @generated from protobuf field: optional string germline_classification = 2;
   */
  germlineClassification?: string
  /**
   * Information on the clinical impact; mutually exlusive with `germline_classification`
   * and `oncogenicity_classification`.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.ClassificationScv.SomaticClinicalImpact somatic_clinical_impact = 3;
   */
  somaticClinicalImpact?: ClassificationScv_SomaticClinicalImpact
  /**
   * The oncogenicity classification; mutually exlusive with `germline_classification`
   * and `oncogenicity_classification`.
   *
   * @generated from protobuf field: optional string oncogenicity_classification = 4;
   */
  oncogenicityClassification?: string
  /**
   * Optional explanation of classification.
   *
   * @generated from protobuf field: optional string explanation_of_classification = 5;
   */
  explanationOfClassification?: string
  /**
   * List of classification scores.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.ClassificationScv.ClassificationScore classification_scores = 6;
   */
  classificationScores: ClassificationScv_ClassificationScore[]
  /**
   * List of xrefs.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 7;
   */
  xrefs: Xref[]
  /**
   * List of citations.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Citation citations = 8;
   */
  citations: Citation[]
  /**
   * List of comments.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Comment comments = 9;
   */
  comments: Comment[]
  // attributes

  /**
   * Date of last evaluation.
   *
   * @generated from protobuf field: optional google.protobuf.Timestamp date_last_evaluated = 10;
   */
  dateLastEvaluated?: Timestamp
}
/**
 * Clinical impact of a somatic variatn.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.ClassificationScv.SomaticClinicalImpact
 */
export interface ClassificationScv_SomaticClinicalImpact {
  /**
   * The somatic clinical impact value.
   *
   * @generated from protobuf field: string value = 1;
   */
  value: string
  // attributes

  /**
   * Type of the clinical impact assertion.
   *
   * @generated from protobuf field: optional string clinical_impact_assertion_type = 2;
   */
  clinicalImpactAssertionType?: string
  /**
   * Clinical impact significance.
   *
   * @generated from protobuf field: optional string clinical_impact_clinical_significance = 3;
   */
  clinicalImpactClinicalSignificance?: string
  /**
   * Name of the drug for the therapeutic assertion.
   *
   * @generated from protobuf field: optional string drug_for_therapeutic_assertion = 4;
   */
  drugForTherapeuticAssertion?: string
}
/**
 * Classification score description.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.ClassificationScv.ClassificationScore
 */
export interface ClassificationScv_ClassificationScore {
  /**
   * The score's value.
   *
   * @generated from protobuf field: double value = 1;
   */
  value: number
  /**
   * The score's type; optional.
   *
   * @generated from protobuf field: optional string type = 2;
   */
  type?: string
}
/**
 * Set of attributes for the primary submitter. Any addtional submitters
 * are captured in the AdditionalSubmitters element.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.SubmitterIdentifiers
 */
export interface SubmitterIdentifiers {
  /**
   * Name of submitter.
   *
   * @generated from protobuf field: string submitter_name = 1;
   */
  submitterName: string
  /**
   * Organization ID.
   *
   * @generated from protobuf field: int64 org_id = 2;
   */
  orgId: string
  /**
   * Organization category.
   *
   * @generated from protobuf field: string org_category = 3;
   */
  orgCategory: string
  /**
   * Organization abbreviation; optional.
   *
   * @generated from protobuf field: optional string org_abbreviation = 4;
   */
  orgAbbreviation?: string
}
/**
 * Definition of a species.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.Species
 */
export interface Species {
  /**
   * Name of the species.
   *
   * @generated from protobuf field: string name = 1;
   */
  name: string
  /**
   * Optional taxonomy ID.
   *
   * @generated from protobuf field: optional int32 taxonomy_id = 2;
   */
  taxonomyId?: number
}
/**
 * Interpreted condition for an RCV record.
 *
 * Corresponds to `typeRCVInterpretedCondition` in XSD.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.ClassifiedCondition
 */
export interface ClassifiedCondition {
  /**
   * Condition value.
   *
   * @generated from protobuf field: string value = 1;
   */
  value: string
  /**
   * Database name.
   *
   * @generated from protobuf field: optional string db = 2;
   */
  db?: string
  /**
   * Identifier in database.
   *
   * @generated from protobuf field: optional string id = 3;
   */
  id?: string
}
/**
 * Inside ClinicalAssertion, a structure to support reporting of an
 * accession, its version, the date its status changed, and text describing that
 * change.
 *
 * Corresponds to `typeClinicalAssertionRecordHistory` in XSD.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.ClinicalAssertionRecordHistory
 */
export interface ClinicalAssertionRecordHistory {
  /**
   * Optional comment.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.Comment comment = 1;
   */
  comment?: Comment
  /**
   * Accession.
   *
   * @generated from protobuf field: string accession = 2;
   */
  accession: string
  /**
   * Optional version.
   *
   * @generated from protobuf field: optional int32 version = 3;
   */
  version?: number
  /**
   * Date of the record.
   *
   * @generated from protobuf field: google.protobuf.Timestamp date_changed = 4;
   */
  dateChanged?: Timestamp
}
/**
 * Description of a functional consequence.
 *
 * Corresponds to `typeFunctionalConsequence` in XSD.
 *
 * nested elements
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.FunctionalConsequence
 */
export interface FunctionalConsequence {
  /**
   * List of xrefs.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 1;
   */
  xrefs: Xref[]
  /**
   * List of citations.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Citation citations = 2;
   */
  citations: Citation[]
  /**
   * List of comments.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Comment comments = 3;
   */
  comments: Comment[]
  // attributes

  /**
   * Value of functional consequence.
   *
   * @generated from protobuf field: string value = 4;
   */
  value: string
}
/**
 * Type for the tag `GeneralCitations`.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.GeneralCitations
 */
export interface GeneralCitations {
  /**
   * List of xrefs.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 1;
   */
  xrefs: Xref[]
  /**
   * List of citations.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Citation citations = 2;
   */
  citations: Citation[]
}
/**
 * This refers to the zygosity of the variant being asserted.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.Cooccurrence
 */
export interface Cooccurrence {
  /**
   * Optional zygosity.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.Zygosity zygosity = 1;
   */
  zygosity?: Zygosity
  /**
   * The allele descriptions.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.AlleleDescription allele_descriptions = 2;
   */
  alleleDescriptions: AlleleDescription[]
  /**
   * The optional count.
   *
   * @generated from protobuf field: optional int32 count = 3;
   */
  count?: number
}
/**
 * A structure to support reporting the name of a submitter, its
 * organization id, and its abbreviation and type.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.Submitter
 */
export interface Submitter {
  /**
   * The submitter's identifier.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.SubmitterIdentifiers submitter_identifiers = 1;
   */
  submitterIdentifiers?: SubmitterIdentifiers
  /**
   * The submitter type.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.Submitter.Type type = 2;
   */
  type: Submitter_Type
}
/**
 * Enumeration of submitter kind.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.Submitter.Type
 */
export enum Submitter_Type {
  /**
   * unspecified submitter type
   *
   * @generated from protobuf enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,
  /**
   * corresponds to "primary"
   *
   * @generated from protobuf enum value: TYPE_PRIMARY = 1;
   */
  TYPE_PRIMARY = 1,
  /**
   * corresponds to "secondary"
   *
   * @generated from protobuf enum value: TYPE_SECONDARY = 2;
   */
  TYPE_SECONDARY = 2,
  /**
   * corresponds to "behalf"
   *
   * @generated from protobuf enum value: TYPE_BEHALF = 3;
   */
  TYPE_BEHALF = 3
}
/**
 * Haploinsufficiency/Triplosensitivity of gene.
 *
 * nested elements
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.DosageSensitivity
 */
export interface DosageSensitivity {
  /**
   * Value.
   *
   * @generated from protobuf field: string value = 1;
   */
  value: string
  // attributes

  /**
   * Optional last evaluated date.
   *
   * @generated from protobuf field: optional google.protobuf.Timestamp last_evaluated = 2;
   */
  lastEvaluated?: Timestamp
  /**
   * URL to ClinGen.
   *
   * @generated from protobuf field: optional string clingen = 3;
   */
  clingen?: string
}
/**
 * A name with an optional type.
 *
 * Corresponds to `typeNames` in XSD.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.OtherName
 */
export interface OtherName {
  /**
   * The name's value.
   *
   * @generated from protobuf field: string value = 1;
   */
  value: string
  /**
   * The name's type.
   *
   * @generated from protobuf field: optional string type = 2;
   */
  type?: string
}
/**
 * A structure to support reporting of an accession, its version, the
 * date it was deleted and a free-text summary of why it was deleted.
 *
 * Corresponds to `typeDeletedSCV`.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.DeletedScv
 */
export interface DeletedScv {
  /**
   * The accession.
   *
   * @generated from protobuf field: string accession = 1;
   */
  accession: string
  /**
   * The version.
   *
   * @generated from protobuf field: int32 version = 2;
   */
  version: number
  /**
   * The date of deletion.
   *
   * @generated from protobuf field: google.protobuf.Timestamp date_deleted = 3;
   */
  dateDeleted?: Timestamp
}
/**
 * There can be multiple types of location, and the locations may have
 * identifiers in other databases.
 *
 * Corresponds to `typeLocation` in XSD.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.Location
 */
export interface Location {
  /**
   * Cytogenetic location is maintained independent of sequence
   * location, and can be submitted or computed from the sequence location.
   *
   * Between 0 and 4 entries.
   *
   * @generated from protobuf field: repeated string cytogenetic_locations = 1;
   */
  cytogeneticLocations: string[]
  /**
   * Location on a defined sequence, with reference and alternate
   * allele, and start /stop values depending on the specificity with which the
   * variant location is known. The number system of offset 1, and
   * right-justified to be consistent with HGVS location data.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Location.SequenceLocation sequence_locations = 2;
   */
  sequenceLocations: Location_SequenceLocation[]
  /**
   * The location of the variant relative to features within the gene.
   *
   * @generated from protobuf field: repeated string gene_locations = 3;
   */
  geneLocations: string[]
  /**
   * List of xrefs.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 4;
   */
  xrefs: Xref[]
}
/**
 * Local type for sequence location.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.Location.SequenceLocation
 */
export interface Location_SequenceLocation {
  /**
   * forDisplay value.
   *
   * @generated from protobuf field: optional bool for_display = 1;
   */
  forDisplay?: boolean
  /**
   * Name of assembly.
   *
   * @generated from protobuf field: string assembly = 2;
   */
  assembly: string
  /**
   * Chromosomeof variant.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.Chromosome chr = 3;
   */
  chr: Chromosome
  /**
   * Optional chromosome accession.
   *
   * @generated from protobuf field: optional string accession = 4;
   */
  accession?: string
  /**
   * Outer start position.
   *
   * @generated from protobuf field: optional uint32 outer_start = 5;
   */
  outerStart?: number
  /**
   * Inner start position.
   *
   * @generated from protobuf field: optional uint32 inner_start = 6;
   */
  innerStart?: number
  /**
   * Start position.
   *
   * @generated from protobuf field: optional uint32 start = 7;
   */
  start?: number
  /**
   * Stop position.
   *
   * @generated from protobuf field: optional uint32 stop = 8;
   */
  stop?: number
  /**
   * Inner stop position.
   *
   * @generated from protobuf field: optional uint32 inner_stop = 9;
   */
  innerStop?: number
  /**
   * Outer stop position.
   *
   * @generated from protobuf field: optional uint32 outer_stop = 10;
   */
  outerStop?: number
  /**
   * Display start position.
   *
   * @generated from protobuf field: optional uint32 display_start = 11;
   */
  displayStart?: number
  /**
   * Display stop position.
   *
   * @generated from protobuf field: optional uint32 display_stop = 12;
   */
  displayStop?: number
  /**
   * Strand.
   *
   * @generated from protobuf field: optional string strand = 13;
   */
  strand?: string
  /**
   * Variant length.
   *
   * @generated from protobuf field: optional uint32 variant_length = 14;
   */
  variantLength?: number
  /**
   * Reference allele.
   *
   * @generated from protobuf field: optional string reference_allele = 15;
   */
  referenceAllele?: string
  /**
   * Alternate allele.
   *
   * @generated from protobuf field: optional string alternate_allele = 16;
   */
  alternateAllele?: string
  /**
   * Assembly accession version.
   *
   * @generated from protobuf field: optional string assembly_accession_version = 17;
   */
  assemblyAccessionVersion?: string
  /**
   * Assembly status.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.Location.SequenceLocation.AssemblyStatus assembly_status = 18;
   */
  assemblyStatus?: Location_SequenceLocation_AssemblyStatus
  /**
   * Position in VCF.
   *
   * @generated from protobuf field: optional uint32 position_vcf = 19;
   */
  positionVcf?: number
  /**
   * Reference allele in VCF.
   *
   * @generated from protobuf field: optional string reference_allele_vcf = 20;
   */
  referenceAlleleVcf?: string
  /**
   * Alternate allele in VCF.
   *
   * @generated from protobuf field: optional string alternate_allele_vcf = 21;
   */
  alternateAlleleVcf?: string
  /**
   * For display length.
   *
   * @generated from protobuf field: optional uint32 for_display_length = 22;
   */
  forDisplayLength?: number
}
/**
 * Local enum for the assembly status.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.Location.SequenceLocation.AssemblyStatus
 */
export enum Location_SequenceLocation_AssemblyStatus {
  /**
   * unspecified assembly status
   *
   * @generated from protobuf enum value: ASSEMBLY_STATUS_UNSPECIFIED = 0;
   */
  ASSEMBLY_STATUS_UNSPECIFIED = 0,
  /**
   * corresponds to "current"
   *
   * @generated from protobuf enum value: ASSEMBLY_STATUS_CURRENT = 1;
   */
  ASSEMBLY_STATUS_CURRENT = 1,
  /**
   * corresponds to "previous"
   *
   * @generated from protobuf enum value: ASSEMBLY_STATUS_PREVIOUS = 2;
   */
  ASSEMBLY_STATUS_PREVIOUS = 2
}
/**
 * Description of a SCV.
 *
 * Corresponds to "typeSCV" in XSD.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.Scv
 */
export interface Scv {
  /**
   * Optional title.
   *
   * @generated from protobuf field: optional string title = 1;
   */
  title?: string
  /**
   * Accession.
   *
   * @generated from protobuf field: string accession = 2;
   */
  accession: string
  /**
   * Version.
   *
   * @generated from protobuf field: int32 version = 3;
   */
  version: number
}
// // Description of a list of indications.
// //
// // Corresponds to `IndicationListType` in XSD.
// message Indications {
//   // The indication may be a set of phenotypic descriptions.
//   message Indication {
//     // Xrefs.
//     repeated Xref xrefs = 1;
//     // Name of the indication.
//     string name = 2;
//     // Target ID.
//     int64 target_id = 3;
//   }

//   // Type of the phenotype.
//   PhenotypeSetType phenotype_set_type = 1;
// }

// // Description of a pharma.
// message PharmaType {
//   // Local type for drug response.
//   message DrugResponse {
//     // // The phenotype details.
//     // repeated PhenotypeListDetailsType phenotype_details = 1;
//     // Xref list.
//     repeated Xref xrefs = 1;
//     // Name of drug.
//     string drug_name = 2;
//     // Target ID.
//     int64 target_id = 3;
//   }

//   // Drug responses.
//   repeated DrugResponse drug_responses = 1;
// }

// // Description of a single method.
// //
// // Corresponds to `typeMethodRefs` in XSD.
// message MethodWithXrefs {
//   // Name of the method.
//   string method_name = 1;
//   // Xrefs.
//   repeated Xref xrefs = 2;
// }

/**
 * Structure to describe attributes of any family data in an observation.
 * If the details of the number of families and the de-identified pedigree id are not
 * available, use FamilyHistory to describe what type of family data is available. Can
 * also be used to report 'Yes' or 'No' if there are no more details.
 *
 * Corresponds to "FamilyInfo" in XSD.
 *
 * nested elements
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.FamilyData
 */
export interface FamilyData {
  /**
   * Optional family history.
   *
   * @generated from protobuf field: optional string family_history = 1;
   */
  familyHistory?: string
  // attributes

  /**
   * Number of families.
   *
   * @generated from protobuf field: optional int32 num_families = 2;
   */
  numFamilies?: number
  /**
   * Number of families with variant.
   *
   * @generated from protobuf field: optional int32 num_families_with_variant = 3;
   */
  numFamiliesWithVariant?: number
  /**
   * Number of families with segregation observed.
   *
   * @generated from protobuf field: optional int32 num_families_with_segregation_observed = 4;
   */
  numFamiliesWithSegregationObserved?: number
  /**
   * Pedigree ID.
   *
   * @generated from protobuf field: optional string pedigree_id = 5;
   */
  pedigreeId?: string
  /**
   * Segregation oberved (yes, no, number)
   *
   * @generated from protobuf field: optional string segregation_observed = 6;
   */
  segregationObserved?: string
}
/**
 * Description of a sample.
 *
 * Corresponds to `typeSample` in XSD.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.Sample
 */
export interface Sample {
  /**
   * The sample description.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.Sample.SampleDescription sample_description = 1;
   */
  sampleDescription?: Sample_SampleDescription
  /**
   * The sample origin.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.Origin origin = 2;
   */
  origin?: Origin
  /**
   * Sample ethnicity.
   *
   * @generated from protobuf field: optional string ethnicity = 3;
   */
  ethnicity?: string
  /**
   * Sample geographic origin.
   *
   * @generated from protobuf field: optional string geographic_origin = 4;
   */
  geographicOrigin?: string
  /**
   * Sample tissue.
   *
   * @generated from protobuf field: optional string tissue = 5;
   */
  tissue?: string
  /**
   * Presence of variant in normal tissue.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.Sample.SomaticVariantInNormalTissue somatic_variant_in_normal_tissue = 6;
   */
  somaticVariantInNormalTissue?: Sample_SomaticVariantInNormalTissue
  /**
   * Somatic variant allele fraction.
   *
   * @generated from protobuf field: optional string somatic_variant_allele_fraction = 7;
   */
  somaticVariantAlleleFraction?: string
  /**
   * Cell line name.
   *
   * @generated from protobuf field: optional string cell_line = 8;
   */
  cellLine?: string
  /**
   * Species.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.Species species = 9;
   */
  species?: Species
  /**
   * Age (range), max. size of 2.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Sample.Age ages = 10;
   */
  ages: Sample_Age[]
  /**
   * Strain.
   *
   * @generated from protobuf field: optional string strain = 11;
   */
  strain?: string
  /**
   * Affected status.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.Sample.AffectedStatus affected_status = 12;
   */
  affectedStatus?: Sample_AffectedStatus
  /**
   * Denominator, total individuals included in this observation set.
   *
   * @generated from protobuf field: optional int32 numer_tested = 13;
   */
  numerTested?: number
  /**
   * Denominator, total males included in this observation set.
   *
   * @generated from protobuf field: optional int32 number_males = 14;
   */
  numberMales?: number
  /**
   * Denominator, total females included in this observation set.
   *
   * @generated from protobuf field: optional int32 number_females = 15;
   */
  numberFemales?: number
  /**
   * Denominator, total number chromosomes tested. Number affected
   * and unaffected are captured in the element NumberObserved.
   *
   * @generated from protobuf field: optional int32 number_chr_tested = 16;
   */
  numberChrTested?: number
  /**
   * Gender should be used ONLY if explicit values are not
   * available for number of males or females, and there is a need to indicate
   * that the genders in the sample are known.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.Sample.Gender gender = 17;
   */
  gender?: Sample_Gender
  /**
   * Family information.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.FamilyData family_data = 18;
   */
  familyData?: FamilyData
  /**
   * Optional proband ID.
   *
   * @generated from protobuf field: optional string proband = 19;
   */
  proband?: string
  /**
   * Optional indication.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.Indication indication = 20;
   */
  indication?: Indication
  /**
   * List of citations.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Citation citations = 21;
   */
  citations: Citation[]
  /**
   * List of xrefs.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 22;
   */
  xrefs: Xref[]
  /**
   * List of comments.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Comment comments = 23;
   */
  comments: Comment[]
  /**
   * Source type.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.Sample.SourceType source_type = 24;
   */
  sourceType?: Sample_SourceType
}
/**
 * Local type for sample description.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.Sample.SampleDescription
 */
export interface Sample_SampleDescription {
  /**
   * Description of sample.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.Comment description = 1;
   */
  description?: Comment
  /**
   * Citation.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.Citation citation = 2;
   */
  citation?: Citation
}
/**
 * Local type for an age.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.Sample.Age
 */
export interface Sample_Age {
  /**
   * The age value.
   *
   * @generated from protobuf field: int32 value = 1;
   */
  value: number
  /**
   * The age unit.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.Sample.AgeUnit unit = 2;
   */
  unit: Sample_AgeUnit
  /**
   * The age type.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.Sample.AgeType type = 3;
   */
  type: Sample_AgeType
}
/**
 * Local enumeration for presence in normal tissue.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.Sample.SomaticVariantInNormalTissue
 */
export enum Sample_SomaticVariantInNormalTissue {
  /**
   * unspecified presence
   *
   * @generated from protobuf enum value: SOMATIC_VARIANT_IN_NORMAL_TISSUE_UNSPECIFIED = 0;
   */
  SOMATIC_VARIANT_IN_NORMAL_TISSUE_UNSPECIFIED = 0,
  /**
   * corresponds to "present"
   *
   * @generated from protobuf enum value: SOMATIC_VARIANT_IN_NORMAL_TISSUE_PRESENT = 1;
   */
  SOMATIC_VARIANT_IN_NORMAL_TISSUE_PRESENT = 1,
  /**
   * corresponds to "absent"
   *
   * @generated from protobuf enum value: SOMATIC_VARIANT_IN_NORMAL_TISSUE_ABSENT = 2;
   */
  SOMATIC_VARIANT_IN_NORMAL_TISSUE_ABSENT = 2,
  /**
   * corresponds to "not tested"
   *
   * @generated from protobuf enum value: SOMATIC_VARIANT_IN_NORMAL_TISSUE_NOT_TESTED = 3;
   */
  SOMATIC_VARIANT_IN_NORMAL_TISSUE_NOT_TESTED = 3
}
/**
 * Local enumeration for an age unit.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.Sample.AgeUnit
 */
export enum Sample_AgeUnit {
  /**
   * unspecified age unit
   *
   * @generated from protobuf enum value: AGE_UNIT_UNSPECIFIED = 0;
   */
  AGE_UNIT_UNSPECIFIED = 0,
  /**
   * corresponds to "days"
   *
   * @generated from protobuf enum value: AGE_UNIT_DAYS = 1;
   */
  AGE_UNIT_DAYS = 1,
  /**
   * corresponds to "weeks"
   *
   * @generated from protobuf enum value: AGE_UNIT_WEEKS = 2;
   */
  AGE_UNIT_WEEKS = 2,
  /**
   * corresponds to "months"
   *
   * @generated from protobuf enum value: AGE_UNIT_MONTHS = 3;
   */
  AGE_UNIT_MONTHS = 3,
  /**
   * corresponds to "years"
   *
   * @generated from protobuf enum value: AGE_UNIT_YEARS = 4;
   */
  AGE_UNIT_YEARS = 4,
  /**
   * corresponds to "weeks gestation"
   *
   * @generated from protobuf enum value: AGE_UNIT_WEEKS_GESTATION = 5;
   */
  AGE_UNIT_WEEKS_GESTATION = 5,
  /**
   * corresponds to "months gestation"
   *
   * @generated from protobuf enum value: AGE_UNIT_MONTHS_GESTATION = 6;
   */
  AGE_UNIT_MONTHS_GESTATION = 6
}
/**
 * Local enumeration for an age type.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.Sample.AgeType
 */
export enum Sample_AgeType {
  /**
   * unspecified age type
   *
   * @generated from protobuf enum value: AGE_TYPE_UNSPECIFIED = 0;
   */
  AGE_TYPE_UNSPECIFIED = 0,
  /**
   * corresponds to "minimum"
   *
   * @generated from protobuf enum value: AGE_TYPE_MINIMUM = 1;
   */
  AGE_TYPE_MINIMUM = 1,
  /**
   * corresponds to "maximum"
   *
   * @generated from protobuf enum value: AGE_TYPE_MAXIMUM = 2;
   */
  AGE_TYPE_MAXIMUM = 2,
  /**
   * corresponds to "single"
   *
   * @generated from protobuf enum value: AGE_TYPE_SINGLE = 3;
   */
  AGE_TYPE_SINGLE = 3
}
/**
 * Local enumeration for the affected status.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.Sample.AffectedStatus
 */
export enum Sample_AffectedStatus {
  /**
   * unspecified affected status
   *
   * @generated from protobuf enum value: AFFECTED_STATUS_UNSPECIFIED = 0;
   */
  AFFECTED_STATUS_UNSPECIFIED = 0,
  /**
   * corresponds to "yes"
   *
   * @generated from protobuf enum value: AFFECTED_STATUS_YES = 1;
   */
  AFFECTED_STATUS_YES = 1,
  /**
   * corresponds to "no"
   *
   * @generated from protobuf enum value: AFFECTED_STATUS_NO = 2;
   */
  AFFECTED_STATUS_NO = 2,
  /**
   * corresponds to "not provided"
   *
   * @generated from protobuf enum value: AFFECTED_STATUS_NOT_PROVIDED = 3;
   */
  AFFECTED_STATUS_NOT_PROVIDED = 3,
  /**
   * corresponds to "unknown"
   *
   * @generated from protobuf enum value: AFFECTED_STATUS_UNKNOWN = 4;
   */
  AFFECTED_STATUS_UNKNOWN = 4,
  /**
   * corresponds to "not applicable"
   *
   * @generated from protobuf enum value: AFFECTED_STATUS_NOT_APPLICABLE = 5;
   */
  AFFECTED_STATUS_NOT_APPLICABLE = 5
}
/**
 * Local enumeration for gender.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.Sample.Gender
 */
export enum Sample_Gender {
  /**
   * unspecified gender
   *
   * @generated from protobuf enum value: GENDER_UNSPECIFIED = 0;
   */
  GENDER_UNSPECIFIED = 0,
  /**
   * corresponds to "male"
   *
   * @generated from protobuf enum value: GENDER_MALE = 1;
   */
  GENDER_MALE = 1,
  /**
   * corresponds to "female"
   *
   * @generated from protobuf enum value: GENDER_FEMALE = 2;
   */
  GENDER_FEMALE = 2,
  /**
   * corresponds to "mixed"
   *
   * @generated from protobuf enum value: GENDER_MIXED = 3;
   */
  GENDER_MIXED = 3
}
/**
 * Local enumeration for SourceType.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.Sample.SourceType
 */
export enum Sample_SourceType {
  /**
   * unspecified source type
   *
   * @generated from protobuf enum value: SOURCE_TYPE_UNSPECIFIED = 0;
   */
  SOURCE_TYPE_UNSPECIFIED = 0,
  /**
   * corresponds to "submitter-generated"
   *
   * @generated from protobuf enum value: SOURCE_TYPE_SUBMITTER_GENERATED = 1;
   */
  SOURCE_TYPE_SUBMITTER_GENERATED = 1,
  /**
   * corresponds to "data mining"
   *
   * @generated from protobuf enum value: SOURCE_TYPE_DATA_MINING = 2;
   */
  SOURCE_TYPE_DATA_MINING = 2
}
/**
 * Details of a method used to generate variant calls or predict/report
 * functional consequence. The name of the platform should represent a sequencer or an
 * array, e.g. sequencing or array , e.g. capillary, 454, Helicos, Solexa, SOLiD. This
 * structure should also be used if the method is 'Curation'.
 *
 * Corresponds to `MethodType` in XSD.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.Method
 */
export interface Method {
  /**
   * Platform name.
   *
   * @generated from protobuf field: optional string name_platform = 1;
   */
  namePlatform?: string
  /**
   * Platform type.
   *
   * @generated from protobuf field: optional string type_platform = 2;
   */
  typePlatform?: string
  /**
   * Method purpose.
   *
   * @generated from protobuf field: optional string purpose = 3;
   */
  purpose?: string
  /**
   * Method result type.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.Method.ResultType result_type = 4;
   */
  resultType?: Method_ResultType
  /**
   * Smallest reported.
   *
   * @generated from protobuf field: optional string min_reported = 5;
   */
  minReported?: string
  /**
   * Largest reported.
   *
   * @generated from protobuf field: optional string max_reported = 6;
   */
  maxReported?: string
  /**
   * Reference standard.
   *
   * @generated from protobuf field: optional string reference_standard = 7;
   */
  referenceStandard?: string
  /**
   * List of citations.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Citation citations = 8;
   */
  citations: Citation[]
  /**
   * List of xrefs.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 9;
   */
  xrefs: Xref[]
  /**
   * Free text to enrich the description of the method and to
   * provide information not captured in specific fields.
   *
   * @generated from protobuf field: optional string description = 10;
   */
  description?: string
  /**
   * List of softwares used.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Software software = 11;
   */
  software: Software[]
  /**
   * Source type.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.Method.SourceType source_type = 12;
   */
  sourceType?: Method_SourceType
  /**
   * Method type.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.MethodListType method_type = 13;
   */
  methodType: MethodListType
  /**
   * Method attribute.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Method.MethodAttribute method_attributes = 14;
   */
  methodAttributes: Method_MethodAttribute[]
  /**
   * ObsMethodAttribute is used to indicate an attribute specific
   * to a particular method in conjunction with a particular observation .
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Method.ObsMethodAttribute obs_method_attributes = 15;
   */
  obsMethodAttributes: Method_ObsMethodAttribute[]
}
/**
 * Local type for method attribute.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.Method.MethodAttribute
 */
export interface Method_MethodAttribute {
  /**
   * The base value.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.BaseAttribute base = 1;
   */
  base?: BaseAttribute
  /**
   * The attribute type.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.Method.MethodAttribute.AttributeType type = 2;
   */
  type: Method_MethodAttribute_AttributeType
}
/**
 * Local enumeration of attribute type.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.Method.MethodAttribute.AttributeType
 */
export enum Method_MethodAttribute_AttributeType {
  /**
   * unspecified attribute type
   *
   * @generated from protobuf enum value: ATTRIBUTE_TYPE_UNSPECIFIED = 0;
   */
  ATTRIBUTE_TYPE_UNSPECIFIED = 0,
  /**
   * corresponds to "Location"
   *
   * @generated from protobuf enum value: ATTRIBUTE_TYPE_LOCATION = 1;
   */
  ATTRIBUTE_TYPE_LOCATION = 1,
  /**
   * corresponds to "ControlsAppropriate"
   *
   * @generated from protobuf enum value: ATTRIBUTE_TYPE_CONTROLS_APPROPRIATE = 2;
   */
  ATTRIBUTE_TYPE_CONTROLS_APPROPRIATE = 2,
  /**
   * corresponds to "MethodAppropriate"
   *
   * @generated from protobuf enum value: ATTRIBUTE_TYPE_METHOD_APPROPRIATE = 3;
   */
  ATTRIBUTE_TYPE_METHOD_APPROPRIATE = 3,
  /**
   * corresponds to "TestName"
   *
   * @generated from protobuf enum value: ATTRIBUTE_TYPE_TEST_NAME = 4;
   */
  ATTRIBUTE_TYPE_TEST_NAME = 4,
  /**
   * corresponds to "StructVarMethod"
   *
   * @generated from protobuf enum value: ATTRIBUTE_TYPE_STRUCT_VAR_METHOD_TYPE = 5;
   */
  ATTRIBUTE_TYPE_STRUCT_VAR_METHOD_TYPE = 5,
  /**
   * corresponds to "ProbeAccession"
   *
   * @generated from protobuf enum value: ATTRIBUTE_TYPE_PROBE_ACCESSION = 6;
   */
  ATTRIBUTE_TYPE_PROBE_ACCESSION = 6
}
/**
 * Local type for observation method attribute.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.Method.ObsMethodAttribute
 */
export interface Method_ObsMethodAttribute {
  /**
   * The base value.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.BaseAttribute base = 1;
   */
  base?: BaseAttribute
  /**
   * The attribute type.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.Method.ObsMethodAttribute.AttributeType type = 2;
   */
  type: Method_ObsMethodAttribute_AttributeType
  /**
   * Optional comments.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Comment comments = 3;
   */
  comments: Comment[]
}
/**
 * Local enumeration for attribute type.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.Method.ObsMethodAttribute.AttributeType
 */
export enum Method_ObsMethodAttribute_AttributeType {
  /**
   * unspecified attribute type
   *
   * @generated from protobuf enum value: ATTRIBUTE_TYPE_UNSPECIFIED = 0;
   */
  ATTRIBUTE_TYPE_UNSPECIFIED = 0,
  /**
   * corresponds to "MethodResult"
   *
   * @generated from protobuf enum value: ATTRIBUTE_TYPE_METHOD_RESULT = 1;
   */
  ATTRIBUTE_TYPE_METHOD_RESULT = 1,
  /**
   * corresponds to "TestingLaboratory"
   *
   * @generated from protobuf enum value: ATTRIBUTE_TYPE_TESTING_LABORATORY = 2;
   */
  ATTRIBUTE_TYPE_TESTING_LABORATORY = 2
}
/**
 * Local enumeration for result types.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.Method.ResultType
 */
export enum Method_ResultType {
  /**
   * unspecified result type
   *
   * @generated from protobuf enum value: RESULT_TYPE_UNSPECIFIED = 0;
   */
  RESULT_TYPE_UNSPECIFIED = 0,
  /**
   * corresponds to "number of occurrences"
   *
   * @generated from protobuf enum value: RESULT_TYPE_NUMBER_OF_OCCURRENCES = 1;
   */
  RESULT_TYPE_NUMBER_OF_OCCURRENCES = 1,
  /**
   * corresponds to "p value"
   *
   * @generated from protobuf enum value: RESULT_TYPE_P_VALUE = 2;
   */
  RESULT_TYPE_P_VALUE = 2,
  /**
   * corresponds to "odds ratio"
   *
   * @generated from protobuf enum value: RESULT_TYPE_ODDS_RATIO = 3;
   */
  RESULT_TYPE_ODDS_RATIO = 3,
  /**
   * corresponds to "variant call"
   *
   * @generated from protobuf enum value: RESULT_TYPE_VARIANT_CALL = 4;
   */
  RESULT_TYPE_VARIANT_CALL = 4
}
/**
 * Local enumeration for SourceType.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.Method.SourceType
 */
export enum Method_SourceType {
  /**
   * unspecified source type
   *
   * @generated from protobuf enum value: SOURCE_TYPE_UNSPECIFIED = 0;
   */
  SOURCE_TYPE_UNSPECIFIED = 0,
  /**
   * corresponds to "submitter-generated"
   *
   * @generated from protobuf enum value: SOURCE_TYPE_SUBMITTER_GENERATED = 1;
   */
  SOURCE_TYPE_SUBMITTER_GENERATED = 1,
  /**
   * corresponds to "data mining"
   *
   * @generated from protobuf enum value: SOURCE_TYPE_DATA_MINING = 2;
   */
  SOURCE_TYPE_DATA_MINING = 2,
  /**
   * corresponds to "data review"
   *
   * @generated from protobuf enum value: SOURCE_TYPE_DATA_REVIEW = 3;
   */
  SOURCE_TYPE_DATA_REVIEW = 3
}
/**
 * This is a record per variant (Measure/@ID,AlleleID) as submitted for
 * accessioning in an SCV.
 *
 * Corresponds to "typeAlleleSCV" in XSD.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.AlleleScv
 */
export interface AlleleScv {
  // nested elements

  /**
   * 0 to many genes (and related data ) related to the allele
   * being reported.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.AlleleScv.Gene genes = 1;
   */
  genes: AlleleScv_Gene[]
  /**
   * Name provided by the submitter.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.OtherName name = 2;
   */
  name?: OtherName
  /**
   * Variant type.
   *
   * @generated from protobuf field: optional string variant_type = 3;
   */
  variantType?: string
  /**
   * Location.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.Location location = 4;
   */
  location?: Location
  /**
   * List of other names.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.OtherName other_names = 5;
   */
  otherNames: OtherName[]
  /**
   * Single letter representation of the amino acid change and its
   * location.
   *
   * @generated from protobuf field: repeated string protein_changes = 6;
   */
  proteinChanges: string[]
  /**
   * List of xrefs.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 7;
   */
  xrefs: Xref[]
  /**
   * List of citations.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Citation citations = 8;
   */
  citations: Citation[]
  /**
   * List of comments.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Comment comments = 9;
   */
  comments: Comment[]
  /**
   * Currently redundant with the MolecularConsequence element of
   * the HGVS element?
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.AlleleScv.MolecularConsequence molecular_consequences = 10;
   */
  molecularConsequences: AlleleScv_MolecularConsequence[]
  /**
   * Functional consequences.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.FunctionalConsequence functional_consequences = 11;
   */
  functionalConsequences: FunctionalConsequence[]
  /**
   * Attributes.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.AttributeSetElement attributes = 12;
   */
  attributes: AttributeSetElement[]
  // attributes

  /**
   * Allele ID.
   *
   * @generated from protobuf field: optional int64 allele_id = 13;
   */
  alleleId?: string
}
/**
 * Local type for Gene.
 *
 * nested elements
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.AlleleScv.Gene
 */
export interface AlleleScv_Gene {
  /**
   * Gene name.
   *
   * @generated from protobuf field: optional string name = 1;
   */
  name?: string
  /**
   * Used to set key words for retrieval or
   * display about a gene, such as genes listed by the
   * ACMG guidelines.
   *
   * @generated from protobuf field: repeated string properties = 2;
   */
  properties: string[]
  /**
   * Used for gene specific identifiers
   * such as MIM number, Gene ID, HGNC ID, etc.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 3;
   */
  xrefs: Xref[]
  // attributes

  /**
   * Optional gene symbol.
   *
   * @generated from protobuf field: optional string symbol = 4;
   */
  symbol?: string
  /**
   * Relationship between gene and variant.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.GeneVariantRelationship relationship_type = 5;
   */
  relationshipType?: GeneVariantRelationship
}
/**
 * Local type for MolecularConsequence.
 *
 * nested elements
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.AlleleScv.MolecularConsequence
 */
export interface AlleleScv_MolecularConsequence {
  /**
   * Xref list.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 1;
   */
  xrefs: Xref[]
  /**
   * Citation list.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Citation citations = 2;
   */
  citations: Citation[]
  /**
   * Comment list.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Comment comments = 3;
   */
  comments: Comment[]
  // attributes

  /**
   * RS id.
   *
   * @generated from protobuf field: optional int64 rs = 4;
   */
  rs?: string
  /**
   * Optional HGVS expression.
   *
   * @generated from protobuf field: optional string hgvs = 5;
   */
  hgvs?: string
  /**
   * Optional SO id.
   *
   * @generated from protobuf field: optional string so_id = 6;
   */
  soId?: string
  /**
   * Function.
   *
   * @generated from protobuf field: string function = 7;
   */
  function: string
}
/**
 * This is a record of a haplotype in SCV.
 *
 * Corresponds to `typeHaplotypeSCV` in XSD.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.HaplotypeScv
 */
export interface HaplotypeScv {
  /**
   * The list of alleles in the haplotype.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.AlleleScv simple_alleles = 1;
   */
  simpleAlleles: AlleleScv[]
  /**
   * The preferred representation of the haplotype.
   *
   * @generated from protobuf field: optional string name = 2;
   */
  name?: string
  /**
   * Names other than 'preferred' used for the haplotype.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.OtherName other_names = 3;
   */
  otherNames: OtherName[]
  /**
   * Classification of the variant.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.AggregateClassificationSet classifications = 4;
   */
  classifications?: AggregateClassificationSet
  /**
   * Functional consequences of the variant.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.FunctionalConsequence functional_consequences = 5;
   */
  functionalConsequences: FunctionalConsequence[]
  /**
   * List of attributes.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.AttributeSetElement attributes = 6;
   */
  attributes: AttributeSetElement[]
  /**
   * List of citations.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Citation citations = 7;
   */
  citations: Citation[]
  /**
   * List of cross-references.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 8;
   */
  xrefs: Xref[]
  /**
   * List of comments.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Comment comments = 9;
   */
  comments: Comment[]
  /**
   * Variation ID.
   *
   * @generated from protobuf field: optional int64 variation_id = 10;
   */
  variationId?: string
  /**
   * Number of copies.
   *
   * @generated from protobuf field: optional int32 number_of_copies = 11;
   */
  numberOfCopies?: number
  /**
   * Number of chromosomes.
   *
   * @generated from protobuf field: optional int32 number_of_chromosomes = 12;
   */
  numberOfChromosomes?: number
}
/**
 * Used to report genotypes, be they simple or complex diplotypes.
 *
 * Corresponds to "typeGenotypeSCV" in XSD.
 *
 * nested elements
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.GenotypeScv
 */
export interface GenotypeScv {
  /**
   * Simple alleles; mutually exclusive with `haplotypes`.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.AlleleScv simple_alleles = 1;
   */
  simpleAlleles: AlleleScv[]
  /**
   * Haplotype; mutually exclusive with `simple_alleles`.
   *
   * Allows more than 2 haplotypes per genotype to support
   * representation of ploidy.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.HaplotypeScv haplotypes = 2;
   */
  haplotypes: HaplotypeScv[]
  /**
   * Optional name.
   *
   * @generated from protobuf field: optional string name = 3;
   */
  name?: string
  /**
   * Other names used for the genotype.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.OtherName other_names = 4;
   */
  otherNames: OtherName[]
  /**
   * The variation type.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.VariationType variation_type = 5;
   */
  variationType: VariationType
  /**
   * Functional consequences.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.FunctionalConsequence functional_consequences = 6;
   */
  functionalConsequences: FunctionalConsequence[]
  /**
   * Attributes.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.AttributeSetElement attributes = 7;
   */
  attributes: AttributeSetElement[]
  /**
   * List of citations.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Citation citations = 8;
   */
  citations: Citation[]
  /**
   * List of xrefs.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 9;
   */
  xrefs: Xref[]
  /**
   * List of comments.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Comment comments = 10;
   */
  comments: Comment[]
  // attributes

  /**
   * Variation ID.
   *
   * @generated from protobuf field: optional int64 variation_id = 11;
   */
  variationId?: string
}
// // Observation of one piece of evidence.
// message typeEvidenceObservation {
//   // // Method of data capture, not method of evaluation.
//   // repeated MethodWithXrefs methods = 1;
//   // Modes of inheritance.
//   repeated string modes_of_inheritance = 1;
//   // List of citations.
//   repeated Citation citations = 2;
//   // Comments.
//   repeated Comment comments = 3;
//   // // Observed phenotypes.
//   // repeated PhenotypeListDetailsType observed_phenotypes = 5;
//   // // Indications.
//   // repeated Indications indications = 6;
//   // The submitter's identifiers.
//   repeated Submitter submitter_identifiers = 4;
//   // Families.
//   optional string families = 5;
//   // Individuals.
//   optional string individuals = 6;
//   // Segregation.
//   optional string segregations = 7;
//   // Other gene.
//   optional string other_gene = 8;
//   // Same gene.
//   optional string same_gene = 9;
//   // Evident type.
//   EvidenceType evidence_type = 10;
//   // Allele frequency.
//   optional string allele_frequency = 11;
//   // Allele origin.
//   optional string allele_origin = 12;
//   // Ethnicity.
//   optional string ethnicity = 13;
//   // Geographic origin.
//   optional string geographic_origin = 14;
// }

/**
 * Documents in what populations or samples an allele or genotype has
 * been observed relative to the described trait. Summary observations can be
 * registered per submitted assertion, grouped by common citation, study type, origin,
 * ethnicity, tissue, cell line, and species data. Not all options are valid per study
 * type, but these will not be validated in the xsd.
 *
 * Corresponds to `ObservationSet` in XSD.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.ObservedIn
 */
export interface ObservedIn {
  /**
   * Sample.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.Sample sample = 1;
   */
  sample?: Sample
  /**
   * Observed data.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.ObservedIn.ObservedData observed_data = 2;
   */
  observedData: ObservedIn_ObservedData[]
  /**
   * Co-occurence set.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Cooccurrence cooccurrence_sets = 3;
   */
  cooccurrenceSets: Cooccurrence[]
  /**
   * TraitSet.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.TraitSet trait_set = 4;
   */
  traitSet?: TraitSet
  /**
   * Citation list.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Citation citations = 5;
   */
  citations: Citation[]
  /**
   * Xref list.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 6;
   */
  xrefs: Xref[]
  /**
   * Comment list.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Comment comments = 7;
   */
  comments: Comment[]
}
/**
 * Local struct for attributes based on `BaseAttribute`.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.ObservedIn.ObservedDataAttribute
 */
export interface ObservedIn_ObservedDataAttribute {
  /**
   * base
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.BaseAttribute base = 1;
   */
  base?: BaseAttribute
  /**
   * type
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.ObservedIn.ObservedDataAttribute.Type type = 2;
   */
  type: ObservedIn_ObservedDataAttribute_Type
}
/**
 * Local enum for the observed data type.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.ObservedIn.ObservedDataAttribute.Type
 */
export enum ObservedIn_ObservedDataAttribute_Type {
  /**
   * unspecified observed data attribute type
   *
   * @generated from protobuf enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,
  /**
   * corresponds to "Description"
   *
   * @generated from protobuf enum value: TYPE_DESCRIPTION = 1;
   */
  TYPE_DESCRIPTION = 1,
  /**
   * corresponds to "VariantAlleles"
   *
   * @generated from protobuf enum value: TYPE_VARIANT_ALLELES = 2;
   */
  TYPE_VARIANT_ALLELES = 2,
  /**
   * corresponds to "SubjectsWithVariant"
   *
   * @generated from protobuf enum value: TYPE_SUBJECTS_WITH_VARIANT = 3;
   */
  TYPE_SUBJECTS_WITH_VARIANT = 3,
  /**
   * corresponds to "SubjectsWithDifferentCausativeVariant"
   *
   * @generated from protobuf enum value: TYPE_SUBJECTS_WITH_DIFFERENT_CAUSATIVE_VARIANT = 4;
   */
  TYPE_SUBJECTS_WITH_DIFFERENT_CAUSATIVE_VARIANT = 4,
  /**
   * corresponds to "VariantChromosomes"
   *
   * @generated from protobuf enum value: TYPE_VARIANT_CHROMOSOMES = 5;
   */
  TYPE_VARIANT_CHROMOSOMES = 5,
  /**
   * corresponds to "IndependentObservations"
   *
   * @generated from protobuf enum value: TYPE_INDEPENDENT_OBSERVATIONS = 6;
   */
  TYPE_INDEPENDENT_OBSERVATIONS = 6,
  /**
   * corresponds to "SingleHeterozygote"
   *
   * @generated from protobuf enum value: TYPE_SINGLE_HETEROZYGOUS = 7;
   */
  TYPE_SINGLE_HETEROZYGOUS = 7,
  /**
   * corresponds to "CompoundHeterozygote"
   *
   * @generated from protobuf enum value: TYPE_COMPOUND_HETEROZYGOUS = 8;
   */
  TYPE_COMPOUND_HETEROZYGOUS = 8,
  /**
   * corresponds to "Homozygote"
   *
   * @generated from protobuf enum value: TYPE_HOMOZYGOUS = 9;
   */
  TYPE_HOMOZYGOUS = 9,
  /**
   * corresponds to "Hemizygote"
   *
   * @generated from protobuf enum value: TYPE_HEMIZYGOUS = 10;
   */
  TYPE_HEMIZYGOUS = 10,
  /**
   * corresponds to "NumberMosaic"
   *
   * @generated from protobuf enum value: TYPE_NUMBER_MOSAIC = 11;
   */
  TYPE_NUMBER_MOSAIC = 11,
  /**
   * corresponds to "ObservedUnspecified"
   *
   * @generated from protobuf enum value: TYPE_OBSERVED_UNSPECIFIED = 12;
   */
  TYPE_OBSERVED_UNSPECIFIED = 12,
  /**
   * corresponds to "AlleleFrequency"
   *
   * @generated from protobuf enum value: TYPE_ALLELE_FREQUENCY = 13;
   */
  TYPE_ALLELE_FREQUENCY = 13,
  /**
   * corresponds to "SecondaryFinding"
   *
   * @generated from protobuf enum value: TYPE_SECONDARY_FINDING = 14;
   */
  TYPE_SECONDARY_FINDING = 14,
  /**
   * corresponds to "GenotypeAndMOIConsistent"
   *
   * @generated from protobuf enum value: TYPE_GENOTYPE_AND_MOI_CONSISTENT = 15;
   */
  TYPE_GENOTYPE_AND_MOI_CONSISTENT = 15,
  /**
   * corresponds to "UnaffectedFamilyMemberWithCausativeVariant"
   *
   * @generated from protobuf enum value: TYPE_UNAFFECTED_FAMILY_MEMBER_WITH_CAUSATIVE_VARIANT = 16;
   */
  TYPE_UNAFFECTED_FAMILY_MEMBER_WITH_CAUSATIVE_VARIANT = 16,
  /**
   * corresponds to "HetParentTransmitNormalAllele"
   *
   * @generated from protobuf enum value: TYPE_HET_PARENT_TRANSMIT_NORMAL_ALLELE = 17;
   */
  TYPE_HET_PARENT_TRANSMIT_NORMAL_ALLELE = 17,
  /**
   * corresponds to "CosegregatingFamilies"
   *
   * @generated from protobuf enum value: TYPE_COSEGREGATING_FAMILIES = 18;
   */
  TYPE_COSEGREGATING_FAMILIES = 18,
  /**
   * corresponds to "InformativeMeioses"
   *
   * @generated from protobuf enum value: TYPE_INFORMATIVE_MEIOSES = 19;
   */
  TYPE_INFORMATIVE_MEIOSES = 19,
  /**
   * corresponds to "SampleLocalID"
   *
   * @generated from protobuf enum value: TYPE_SAMPLE_LOCAL_ID = 20;
   */
  TYPE_SAMPLE_LOCAL_ID = 20,
  /**
   * corresponds to "SampleVariantID"
   *
   * @generated from protobuf enum value: TYPE_SAMPLE_VARIANT_ID = 21;
   */
  TYPE_SAMPLE_VARIANT_ID = 21,
  /**
   * corresponds to "FamilyHistory"
   *
   * @generated from protobuf enum value: TYPE_FAMILY_HISTORY = 22;
   */
  TYPE_FAMILY_HISTORY = 22,
  /**
   * corresponds to "NumFamiliesWithVariant"
   *
   * @generated from protobuf enum value: TYPE_NUM_FAMILIES_WITH_VARIANT = 23;
   */
  TYPE_NUM_FAMILIES_WITH_VARIANT = 23,
  /**
   * corresponds to "NumFamiliesWithSegregationObserved"
   *
   * @generated from protobuf enum value: TYPE_NUM_FAMILIES_WITH_SEGREGATION_OBSERVED = 24;
   */
  TYPE_NUM_FAMILIES_WITH_SEGREGATION_OBSERVED = 24,
  /**
   * corresponds to "SegregationObserved"
   *
   * @generated from protobuf enum value: TYPE_SEGREGATION_OBSERVED = 25;
   */
  TYPE_SEGREGATION_OBSERVED = 25
}
/**
 * This is an AttributeSet, there will be 1 attribute supported
 * by optional citations, xrefs and comment. There must be at least one
 * ObservedData Set, but can be any number. For each ObservedData set the
 * Attribute will be either decimal or string depending on type. The value will
 * be stored here, but decimals will be entered to the database as a string.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.ObservedIn.ObservedData
 */
export interface ObservedIn_ObservedData {
  /**
   * Attributes.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.ObservedIn.ObservedDataAttribute attributes = 1;
   */
  attributes: ObservedIn_ObservedDataAttribute[]
  /**
   * Severity.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.Severity severity = 2;
   */
  severity?: Severity
  /**
   * Citation list.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Citation citations = 3;
   */
  citations: Citation[]
  /**
   * Xref list.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 4;
   */
  xrefs: Xref[]
  /**
   * Comment list.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Comment comments = 5;
   */
  comments: Comment[]
}
/**
 * Local enum for the method type.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.ObservedIn.MethodType
 */
export enum ObservedIn_MethodType {
  /**
   * unspecified method type
   *
   * @generated from protobuf enum value: METHOD_TYPE_UNSPECIFIED = 0;
   */
  METHOD_TYPE_UNSPECIFIED = 0,
  /**
   * corresponds to "literature only"
   *
   * @generated from protobuf enum value: METHOD_TYPE_LITERATURE_ONLY = 1;
   */
  METHOD_TYPE_LITERATURE_ONLY = 1,
  /**
   * corresponds to "reference population"
   *
   * @generated from protobuf enum value: METHOD_TYPE_REFERENCE_POPULATION = 2;
   */
  METHOD_TYPE_REFERENCE_POPULATION = 2,
  /**
   * corresponds to "case-control"
   *
   * @generated from protobuf enum value: METHOD_TYPE_CASE_CONTROL = 3;
   */
  METHOD_TYPE_CASE_CONTROL = 3,
  /**
   * corresponds to "clinical testing"
   *
   * @generated from protobuf enum value: METHOD_TYPE_CLINICAL_TESTING = 4;
   */
  METHOD_TYPE_CLINICAL_TESTING = 4,
  /**
   * corresponds to "in vitro"
   *
   * @generated from protobuf enum value: METHOD_TYPE_IN_VITRO = 5;
   */
  METHOD_TYPE_IN_VITRO = 5,
  /**
   * corresponds to "in vivo"
   *
   * @generated from protobuf enum value: METHOD_TYPE_IN_VIVO = 6;
   */
  METHOD_TYPE_IN_VIVO = 6,
  /**
   * corresponds to "inferred from source"
   *
   * @generated from protobuf enum value: METHOD_TYPE_INFERRED_FROM_SOURCE = 7;
   */
  METHOD_TYPE_INFERRED_FROM_SOURCE = 7,
  /**
   * corresponds to "research"
   *
   * @generated from protobuf enum value: METHOD_TYPE_RESEARCH = 8;
   */
  METHOD_TYPE_RESEARCH = 8
}
/**
 * A clinical assertion as submitted (SCV record).
 *
 * Corresponds to `MeasureTraitType` in XSD and `<ClinicalAssertion>` in XML
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.ClinicalAssertion
 */
export interface ClinicalAssertion {
  // nested elements

  /**
   * The ClinVar submission ID.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.ClinicalAssertion.ClinvarSubmissionId clinvar_submission_id = 1;
   */
  clinvarSubmissionId?: ClinicalAssertion_ClinvarSubmissionId
  /**
   * The ClinVar SCV accessions.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.ClinicalAssertion.ClinvarAccession clinvar_accession = 2;
   */
  clinvarAccession?: ClinicalAssertion_ClinvarAccession
  /**
   * Optional list of additional submitters.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Submitter additional_submitters = 3;
   */
  additionalSubmitters: Submitter[]
  /**
   * Record status.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.ClinicalAssertion.RecordStatus record_status = 4;
   */
  recordStatus: ClinicalAssertion_RecordStatus
  /**
   * Replaces; mutually exclusive with replaceds
   *
   * @generated from protobuf field: repeated string replaces = 5;
   */
  replaces: string[]
  /**
   * Replaced list; mutually exclusive with replaces
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.ClinicalAssertionRecordHistory replaceds = 6;
   */
  replaceds: ClinicalAssertionRecordHistory[]
  /**
   * SCV classification.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.ClassificationScv classifications = 7;
   */
  classifications?: ClassificationScv
  /**
   * The assertion.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.Assertion assertion = 8;
   */
  assertion: Assertion
  /**
   * Attributes.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.ClinicalAssertion.AttributeSetElement attributes = 9;
   */
  attributes: ClinicalAssertion_AttributeSetElement[]
  /**
   * Observed in.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.ObservedIn observed_ins = 10;
   */
  observedIns: ObservedIn[]
  /**
   * Allele in SCV; mutually exclusive with haplotype/genotype.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.AlleleScv simple_allele = 11;
   */
  simpleAllele?: AlleleScv
  /**
   * Haplotype in SCV; mutually exclusive with allele/genotype.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.HaplotypeScv haplotype = 12;
   */
  haplotype?: HaplotypeScv
  /**
   * Genotype in SCV; mutually exclusive with allele/haplotype.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.GenotypeScv genotype = 13;
   */
  genotype?: GenotypeScv
  /**
   * The trait set.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.TraitSet trait_set = 14;
   */
  traitSet?: TraitSet
  /**
   * List of citations.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Citation citations = 15;
   */
  citations: Citation[]
  /**
   * Optional study name.
   *
   * @generated from protobuf field: optional string study_name = 16;
   */
  studyName?: string
  /**
   * Optional study description.
   *
   * @generated from protobuf field: optional string study_description = 17;
   */
  studyDescription?: string
  /**
   * List of comments.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Comment comments = 18;
   */
  comments: Comment[]
  /**
   * List of submissions.
   *
   * @generated from protobuf field: repeated string submission_names = 19;
   */
  submissionNames: string[]
  // attributes

  /**
   * Date of creation.
   *
   * @generated from protobuf field: google.protobuf.Timestamp date_created = 20;
   */
  dateCreated?: Timestamp
  /**
   * Date of creation.
   *
   * @generated from protobuf field: google.protobuf.Timestamp date_last_updated = 21;
   */
  dateLastUpdated?: Timestamp
  /**
   * Date of creation.
   *
   * @generated from protobuf field: google.protobuf.Timestamp submission_date = 22;
   */
  submissionDate?: Timestamp
  /**
   * ID.
   *
   * @generated from protobuf field: optional uint64 id = 23;
   */
  id?: string
  /**
   * Whether it is an FDA recognized database.
   *
   * @generated from protobuf field: optional bool fda_recognized_database = 24;
   */
  fdaRecognizedDatabase?: boolean
}
/**
 * Local type for ClinVarSubmissionID.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.ClinicalAssertion.ClinvarSubmissionId
 */
export interface ClinicalAssertion_ClinvarSubmissionId {
  /**
   * The identifier provided by the submitter to facilitate
   * identification of records corresponding to their submissions. If not
   * provided by a submitter, NCBI generates one. If provided by
   * submitter, that is represented in localKeyIsSubmitted.
   *
   * @generated from protobuf field: string local_key = 1;
   */
  localKey: string
  /**
   * Optional title.
   *
   * @generated from protobuf field: optional string title = 2;
   */
  title?: string
  /**
   * Optional indication whether local key has been submitted.
   *
   * @generated from protobuf field: optional bool local_key_is_submitted = 3;
   */
  localKeyIsSubmitted?: boolean
  /**
   * Optional assembly of submission.
   *
   * @generated from protobuf field: optional string submitted_assembly = 4;
   */
  submittedAssembly?: string
}
/**
 * Local type for attribute set.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.ClinicalAssertion.AttributeSetElement
 */
export interface ClinicalAssertion_AttributeSetElement {
  /**
   * The base value.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.BaseAttribute attribute = 1;
   */
  attribute?: BaseAttribute
  /**
   * The type of the attribute.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.ClinicalAssertion.AttributeSetElement.Type type = 2;
   */
  type: ClinicalAssertion_AttributeSetElement_Type
  /**
   * List of xrefs.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 3;
   */
  xrefs: Xref[]
  /**
   * List of citations.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Citation citations = 4;
   */
  citations: Citation[]
  /**
   * List of comments.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Comment comments = 5;
   */
  comments: Comment[]
}
/**
 * Local enum for types.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.ClinicalAssertion.AttributeSetElement.Type
 */
export enum ClinicalAssertion_AttributeSetElement_Type {
  /**
   * unspecified type
   *
   * @generated from protobuf enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,
  /**
   * Corresponds to "ModeOfInheritance"
   *
   * @generated from protobuf enum value: TYPE_MODE_OF_INHERITANCE = 1;
   */
  TYPE_MODE_OF_INHERITANCE = 1,
  /**
   * Corresponds to "Penetrance"
   *
   * @generated from protobuf enum value: TYPE_PENETRANCE = 2;
   */
  TYPE_PENETRANCE = 2,
  /**
   * Corresponds to "AgeOfOnset"
   *
   * @generated from protobuf enum value: TYPE_AGE_OF_ONSET = 3;
   */
  TYPE_AGE_OF_ONSET = 3,
  /**
   * Corresponds to "Severity"
   *
   * @generated from protobuf enum value: TYPE_SEVERITY = 4;
   */
  TYPE_SEVERITY = 4,
  /**
   * Corresponds to "ClassificationHistory"
   *
   * @generated from protobuf enum value: TYPE_CLASSIFICATION_HISTORY = 5;
   */
  TYPE_CLASSIFICATION_HISTORY = 5,
  /**
   * Corresponds to "SeverityDescription"
   *
   * @generated from protobuf enum value: TYPE_SEVERITY_DESCRIPTION = 6;
   */
  TYPE_SEVERITY_DESCRIPTION = 6,
  /**
   * Corresponds to "AssertionMethod"
   *
   * @generated from protobuf enum value: TYPE_ASSERTION_METHOD = 7;
   */
  TYPE_ASSERTION_METHOD = 7
}
/**
 * Local type for `ClinVarAccession`
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.ClinicalAssertion.ClinvarAccession
 */
export interface ClinicalAssertion_ClinvarAccession {
  /**
   * Accession.
   *
   * @generated from protobuf field: string accession = 1;
   */
  accession: string
  /**
   * Version.
   *
   * @generated from protobuf field: int32 version = 2;
   */
  version: number
  /**
   * The submitter's identifier.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.SubmitterIdentifiers submitter_identifiers = 3;
   */
  submitterIdentifiers?: SubmitterIdentifiers
  /**
   * The date that the latest update to the submitted
   * record (SCV) became public in ClinVar.
   *
   * @generated from protobuf field: optional google.protobuf.Timestamp date_updated = 4;
   */
  dateUpdated?: Timestamp
  /**
   * DateCreated is the date when the record first became
   * public in ClinVar.
   *
   * @generated from protobuf field: optional google.protobuf.Timestamp date_created = 5;
   */
  dateCreated?: Timestamp
}
/**
 * Local enum for record status.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.ClinicalAssertion.RecordStatus
 */
export enum ClinicalAssertion_RecordStatus {
  /**
   * unspecified record status
   *
   * @generated from protobuf enum value: RECORD_STATUS_UNSPECIFIED = 0;
   */
  RECORD_STATUS_UNSPECIFIED = 0,
  /**
   * corresponds to "current"
   *
   * @generated from protobuf enum value: RECORD_STATUS_CURRENT = 1;
   */
  RECORD_STATUS_CURRENT = 1,
  /**
   * corresponds to "replaced"
   *
   * @generated from protobuf enum value: RECORD_STATUS_REPLACED = 2;
   */
  RECORD_STATUS_REPLACED = 2,
  /**
   * corresponds to "removed"
   *
   * @generated from protobuf enum value: RECORD_STATUS_REMOVED = 3;
   */
  RECORD_STATUS_REMOVED = 3
}
/**
 * This is a record per variant (Measure/@ID,AlleleID).
 *
 * Corresponds to "typeAllele" in XSD.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.Allele
 */
export interface Allele {
  // nested elements

  /**
   * Gene list.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Allele.Gene genes = 1;
   */
  genes: Allele_Gene[]
  /**
   * Name.
   *
   * @generated from protobuf field: string name = 2;
   */
  name: string
  /**
   * Canonical SPDI.
   *
   * @generated from protobuf field: optional string canonical_spdi = 3;
   */
  canonicalSpdi?: string
  /**
   * Variant type(s).
   *
   * @generated from protobuf field: repeated string variant_types = 4;
   */
  variantTypes: string[]
  /**
   * Location.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Location locations = 5;
   */
  locations: Location[]
  /**
   * List of other names.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.OtherName other_names = 6;
   */
  otherNames: OtherName[]
  /**
   * These are the single-letter representations of the protein change.
   *
   * @generated from protobuf field: repeated string protein_changes = 7;
   */
  proteinChanges: string[]
  /**
   * List of HGVS expressions.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.HgvsExpression hgvs_expressions = 8;
   */
  hgvsExpressions: HgvsExpression[]
  /**
   * Aggregated classifications.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.AggregateClassificationSet classifications = 9;
   */
  classifications?: AggregateClassificationSet
  /**
   * List of xrefs.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 10;
   */
  xrefs: Xref[]
  /**
   * List of comments.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Comment comments = 11;
   */
  comments: Comment[]
  /**
   * List of functional consequences.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.FunctionalConsequence functional_consequences = 12;
   */
  functionalConsequences: FunctionalConsequence[]
  /**
   * Allele frequencies.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Allele.AlleleFrequency allele_frequencies = 13;
   */
  alleleFrequencies: Allele_AlleleFrequency[]
  /**
   * Global minor allele frequencies.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.Allele.GlobalMinorAlleleFrequency global_minor_allele_frequency = 14;
   */
  globalMinorAlleleFrequency?: Allele_GlobalMinorAlleleFrequency
  // attributes

  /**
   * Allele ID.
   *
   * @generated from protobuf field: int64 allele_id = 15;
   */
  alleleId: string
  /**
   * Variation ID.
   *
   * @generated from protobuf field: int64 variation_id = 16;
   */
  variationId: string
}
/**
 * Local type for Gene.
 *
 * nested elements
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.Allele.Gene
 */
export interface Allele_Gene {
  /**
   * Gene's locations.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Location locations = 1;
   */
  locations: Location[]
  /**
   * OMIM ID.
   *
   * @generated from protobuf field: repeated uint64 omims = 2;
   */
  omims: string[]
  /**
   * Haploinsuffiency.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.DosageSensitivity haploinsufficiency = 3;
   */
  haploinsufficiency?: DosageSensitivity
  /**
   * Triplosensitivity.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.DosageSensitivity triplosensitivity = 4;
   */
  triplosensitivity?: DosageSensitivity
  /**
   * Used to set key words for retrieval or
   * display about a gene, such as genes listed by the
   * ACMG guidelines.
   *
   * @generated from protobuf field: repeated string properties = 5;
   */
  properties: string[]
  // attributes

  /**
   * Optional gene symbol.
   *
   * @generated from protobuf field: optional string symbol = 6;
   */
  symbol?: string
  /**
   * Full gene name.
   *
   * @generated from protobuf field: string full_name = 7;
   */
  fullName: string
  /**
   * Gene ID.
   *
   * @generated from protobuf field: int64 gene_id = 8;
   */
  geneId: string
  /**
   * Optional HGNC ID.
   *
   * @generated from protobuf field: optional string hgnc_id = 9;
   */
  hgncId?: string
  /**
   * Source of gene (calculated or submitted).
   *
   * @generated from protobuf field: string source = 10;
   */
  source: string
  /**
   * Relationship between gene and variant.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.GeneVariantRelationship relationship_type = 11;
   */
  relationshipType?: GeneVariantRelationship
}
/**
 * Local type for allele frequency.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.Allele.AlleleFrequency
 */
export interface Allele_AlleleFrequency {
  /**
   * Value.
   *
   * @generated from protobuf field: double value = 1;
   */
  value: number
  /**
   * Source.
   *
   * @generated from protobuf field: string source = 2;
   */
  source: string
  /**
   * URL.
   *
   * @generated from protobuf field: optional string url = 3;
   */
  url?: string
}
/**
 * Local type for GlobalMinorAlleleFrequency.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.Allele.GlobalMinorAlleleFrequency
 */
export interface Allele_GlobalMinorAlleleFrequency {
  /**
   * Value.
   *
   * @generated from protobuf field: double value = 1;
   */
  value: number
  /**
   * Source.
   *
   * @generated from protobuf field: string source = 2;
   */
  source: string
  /**
   * Minor allele.
   *
   * @generated from protobuf field: optional string minor_allele = 3;
   */
  minorAllele?: string
  /**
   * URL.
   *
   * @generated from protobuf field: optional string url = 4;
   */
  url?: string
}
/**
 * Local type for allele name.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.Allele.Name
 */
export interface Allele_Name {
  /**
   * The name's value.
   *
   * @generated from protobuf field: string value = 1;
   */
  value: string
  /**
   * The name's type.
   *
   * @generated from protobuf field: optional string type = 2;
   */
  type?: string
}
/**
 * This is a record of one or more simple alleles on the same chromosome
 * molecule.
 *
 * Corresponds to `typeHaplotype` in XSD
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.Haplotype
 */
export interface Haplotype {
  /**
   * The list of alleles in the haplotype.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Allele simple_alleles = 1;
   */
  simpleAlleles: Allele[]
  /**
   * The preferred representation of the haplotype.
   *
   * @generated from protobuf field: string name = 2;
   */
  name: string
  /**
   * The type of the haplotype.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.HaploVariationType variation_type = 3;
   */
  variationType: HaploVariationType
  /**
   * Names other than 'preferred' used for the haplotype.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.OtherName other_names = 4;
   */
  otherNames: OtherName[]
  /**
   * List of all the HGVS expressions valid for, or used to submit,
   * a variant.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.HgvsExpression hgvs_expressions = 5;
   */
  hgvsExpressions: HgvsExpression[]
  /**
   * Classifications of the variant.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.AggregateClassificationSet classifications = 6;
   */
  classifications?: AggregateClassificationSet
  /**
   * Functional consequences of the variant.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.FunctionalConsequence functional_consequences = 7;
   */
  functionalConsequences: FunctionalConsequence[]
  /**
   * List of cross-references.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 8;
   */
  xrefs: Xref[]
  /**
   * List of comments.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Comment comments = 9;
   */
  comments: Comment[]
  /**
   * Variation ID.
   *
   * @generated from protobuf field: int64 variation_id = 10;
   */
  variationId: string
  /**
   * Number of copies.
   *
   * @generated from protobuf field: optional int32 number_of_copies = 11;
   */
  numberOfCopies?: number
  /**
   * Number of chromosomes.
   *
   * @generated from protobuf field: optional int32 number_of_chromosomes = 12;
   */
  numberOfChromosomes?: number
}
/**
 * This element is used for alleles that were not directly part of a
 * submission but were part of a complex submission. They have no direct submitted
 * classification, but are being reported for a complete representation of all alleles
 * in ClinVar. Compare to ClassifiedRecord.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.IncludedRecord
 */
export interface IncludedRecord {
  /**
   * Simple allele; mutually exclusive with haplotype.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.Allele simple_allele = 1;
   */
  simpleAllele?: Allele
  /**
   * Haplotype; mutually exclusive with simple_allele.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.Haplotype haplotype = 2;
   */
  haplotype?: Haplotype
  /**
   * Aggregate classification sets.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.AggregateClassificationSet classifications = 3;
   */
  classifications?: AggregateClassificationSet
  /**
   * List of submitted records.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Scv submitted_classifications = 4;
   */
  submittedClassifications: Scv[]
  /**
   * Maintains the list of classified variants represented in
   * this submission, although not submitted with an Classification
   * independently.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.IncludedRecord.ClassifiedVariation classified_variations = 5;
   */
  classifiedVariations: IncludedRecord_ClassifiedVariation[]
  /**
   * List of general citations.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.GeneralCitations general_citations = 6;
   */
  generalCitations: GeneralCitations[]
}
/**
 * Local type for tag `ClassifiedVariation`.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.IncludedRecord.ClassifiedVariation
 */
export interface IncludedRecord_ClassifiedVariation {
  /**
   * Variation ID.
   *
   * @generated from protobuf field: int64 variation_id = 1;
   */
  variationId: string
  /**
   * Optional accession.
   *
   * @generated from protobuf field: optional string accession = 2;
   */
  accession?: string
  /**
   * Version.
   *
   * @generated from protobuf field: int32 version = 3;
   */
  version: number
}
/**
 * Used to report genotypes, be they simple or complex diplotypes.
 *
 * Corresponds to "typeGenotype" in XSD.
 *
 * nested elements
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.Genotype
 */
export interface Genotype {
  /**
   * Simple allele; mutually exclusive with `haplotype`.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Allele simple_alleles = 1;
   */
  simpleAlleles: Allele[]
  /**
   * Haplotype; mutually exclusive with `simple_allele`.
   *
   * Allows more than 2 haplotypes per genotype to support
   * representation of ploidy.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Haplotype haplotypes = 2;
   */
  haplotypes: Haplotype[]
  /**
   * Optional name.
   *
   * @generated from protobuf field: string name = 3;
   */
  name: string
  /**
   * The variation type.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.VariationType variation_type = 4;
   */
  variationType: VariationType
  /**
   * Names other than 'preferred' used for the Genotype.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.OtherName other_names = 5;
   */
  otherNames: OtherName[]
  /**
   * HGVS descriptions.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.HgvsExpression hgvs_expressions = 6;
   */
  hgvsExpressions: HgvsExpression[]
  /**
   * Functional consequences.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.FunctionalConsequence functional_consequences = 7;
   */
  functionalConsequences: FunctionalConsequence[]
  /**
   * Aggregated classifications.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.AggregateClassificationSet classifications = 8;
   */
  classifications?: AggregateClassificationSet
  /**
   * List of xrefs.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 9;
   */
  xrefs: Xref[]
  /**
   * List of citations.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Citation citations = 10;
   */
  citations: Citation[]
  /**
   * List of comments.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.Comment comments = 11;
   */
  comments: Comment[]
  /**
   * Attributes.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.AttributeSetElement attributes = 12;
   */
  attributes: AttributeSetElement[]
  // attributes

  /**
   * Variation ID.
   *
   * @generated from protobuf field: optional int64 variation_id = 13;
   */
  variationId?: string
}
/**
 * Corresponds to "typeRCV" in XSD.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.RcvAccession
 */
export interface RcvAccession {
  // nested elements

  /**
   * The list of classified conditions.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.RcvAccession.ClassifiedConditionList classified_condition_list = 1;
   */
  classifiedConditionList?: RcvAccession_ClassifiedConditionList
  /**
   * The list of RCV classifications.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.RcvAccession.RcvClassifications rcv_classifications = 2;
   */
  rcvClassifications?: RcvAccession_RcvClassifications
  /**
   * The list of RCV accessions this record has replaced.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.RecordHistory replaceds = 3;
   */
  replaceds: RecordHistory[]
  // attributes

  /**
   * Optional title.
   *
   * @generated from protobuf field: optional string title = 4;
   */
  title?: string
  /**
   * Accession.
   *
   * @generated from protobuf field: string accession = 5;
   */
  accession: string
  /**
   * Version.
   *
   * @generated from protobuf field: int32 version = 6;
   */
  version: number
}
/**
 * Local type for ClassifiedConditionList.
 *
 * nested elements
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.RcvAccession.ClassifiedConditionList
 */
export interface RcvAccession_ClassifiedConditionList {
  /**
   * List of interpreted conditions.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.ClassifiedCondition classified_conditions = 1;
   */
  classifiedConditions: ClassifiedCondition[]
  // attributes

  /**
   * Trait set ID.
   *
   * @generated from protobuf field: optional int64 trait_set_id = 2;
   */
  traitSetId?: string
}
/**
 * Local type for GermlineClassification.
 *
 * The aggregate review status based on
 * all germline submissions for this record.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.RcvAccession.GermlineClassification
 */
export interface RcvAccession_GermlineClassification {
  /**
   * The aggregate review status based on
   * all somatic clinical impact submissions for this
   * record.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.AggregateGermlineReviewStatus review_status = 1;
   */
  reviewStatus: AggregateGermlineReviewStatus
  /**
   * The oncogenicity description.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.RcvAccession.GermlineClassification.Description description = 2;
   */
  description?: RcvAccession_GermlineClassification_Description
}
/**
 * Local type for Description.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.RcvAccession.GermlineClassification.Description
 */
export interface RcvAccession_GermlineClassification_Description {
  /**
   * The description.
   *
   * @generated from protobuf field: string value = 1;
   */
  value: string
  // attributes

  /**
   * The date of the description.
   *
   * @generated from protobuf field: optional google.protobuf.Timestamp date_last_evaluated = 2;
   */
  dateLastEvaluated?: Timestamp
  /**
   * The number of submissions.
   *
   * @generated from protobuf field: optional uint32 submission_count = 3;
   */
  submissionCount?: number
}
/**
 * Local type for SomaticClinicalImpact.
 *
 * The aggregate review status based on
 * all somatic clinical impact submissions for this
 * record.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.RcvAccession.SomaticClinicalImpact
 */
export interface RcvAccession_SomaticClinicalImpact {
  /**
   * The aggregate review status based on
   * all somatic clinical impact submissions for this
   * record.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.AggregateSomaticClinicalImpactReviewStatus review_status = 1;
   */
  reviewStatus: AggregateSomaticClinicalImpactReviewStatus
  /**
   * The oncogenicity description.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.RcvAccession.SomaticClinicalImpact.Description descriptions = 2;
   */
  descriptions: RcvAccession_SomaticClinicalImpact_Description[]
}
/**
 * Local type for Description.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.RcvAccession.SomaticClinicalImpact.Description
 */
export interface RcvAccession_SomaticClinicalImpact_Description {
  /**
   * The description.
   *
   * @generated from protobuf field: string value = 1;
   */
  value: string
  // attributes

  /**
   * Clinical impact assertion type.
   *
   * @generated from protobuf field: optional string clinical_impact_assertion_type = 2;
   */
  clinicalImpactAssertionType?: string
  /**
   * Clinical impact significance
   *
   * @generated from protobuf field: optional string clinical_impact_clinical_significance = 3;
   */
  clinicalImpactClinicalSignificance?: string
  /**
   * The date of the description.
   *
   * @generated from protobuf field: optional google.protobuf.Timestamp date_last_evaluated = 4;
   */
  dateLastEvaluated?: Timestamp
  /**
   * The number of submissions.
   *
   * @generated from protobuf field: optional uint32 submission_count = 5;
   */
  submissionCount?: number
}
/**
 * Local type for OncogenicityClassification.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.RcvAccession.OncogenicityClassification
 */
export interface RcvAccession_OncogenicityClassification {
  /**
   * The aggregate review status based on
   * all oncogenic submissions for this record.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.AggregateOncogenicityReviewStatus review_status = 1;
   */
  reviewStatus: AggregateOncogenicityReviewStatus
  /**
   * The oncogenicity description.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.RcvAccession.OncogenicityClassification.Description description = 2;
   */
  description?: RcvAccession_OncogenicityClassification_Description
}
/**
 * Local type for Description.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.RcvAccession.OncogenicityClassification.Description
 */
export interface RcvAccession_OncogenicityClassification_Description {
  /**
   * The description.
   *
   * @generated from protobuf field: string value = 1;
   */
  value: string
  // attributes

  /**
   * The date of the description.
   *
   * @generated from protobuf field: optional google.protobuf.Timestamp date_last_evaluated = 2;
   */
  dateLastEvaluated?: Timestamp
  /**
   * The number of submissions.
   *
   * @generated from protobuf field: optional uint32 submission_count = 3;
   */
  submissionCount?: number
}
/**
 * Local type for RCV classifications.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.RcvAccession.RcvClassifications
 */
export interface RcvAccession_RcvClassifications {
  /**
   * Germline classification.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.RcvAccession.GermlineClassification germline_classification = 1;
   */
  germlineClassification?: RcvAccession_GermlineClassification
  /**
   * Somatic clinical impact.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.RcvAccession.SomaticClinicalImpact somatic_clinical_impact = 2;
   */
  somaticClinicalImpact?: RcvAccession_SomaticClinicalImpact
  /**
   * Oncogenicity classification.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.RcvAccession.OncogenicityClassification oncogenicity_classification = 3;
   */
  oncogenicityClassification?: RcvAccession_OncogenicityClassification
}
/**
 * This element is restricted to variation records for which an explicit
 * classification was submitted.  Compare to IncludedRecord, which provides aggregate
 * information about variants that are part of another submission, but for which
 * ClinVar has *not* received a submission specific to that variant independently.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.ClassifiedRecord
 */
export interface ClassifiedRecord {
  /**
   * Describes a single sequence change relative to a
   * contiguous region of a chromosome or the mitochondrion.
   *
   * Mutually exclusive with `haplotype` and `genotype`.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.Allele simple_allele = 1;
   */
  simpleAllele?: Allele
  /**
   * Describes multiple sequence changes on one of the
   * chromosomes of a homologous pair or on the mitochondrion.
   *
   * Mutually exclusive with `simple_allele` and `genotype`.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.Haplotype haplotype = 2;
   */
  haplotype?: Haplotype
  /**
   * Describes the combination of sequence changes on each
   * chromosome of a homologous pair.
   *
   * Mutually exclusive with `simple_allele` and `haplotype`.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.Genotype genotype = 3;
   */
  genotype?: Genotype
  /**
   * List of RCV records.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.ClassifiedRecord.RcvList rcv_list = 4;
   */
  rcvList?: ClassifiedRecord_RcvList
  /**
   * List of classifications.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.AggregateClassificationSet classifications = 5;
   */
  classifications?: AggregateClassificationSet
  /**
   * List of clinical assertions.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.ClinicalAssertion clinical_assertions = 6;
   */
  clinicalAssertions: ClinicalAssertion[]
  /**
   * This element is used to report how each user-submitted
   * trait name was mapped to a MedGen CUI identifier and a preferred name.
   * The structure may be used in the future to report, when a trait is
   * identified by a source's identifier (e.g. MIM number), the preferred
   * name used by that source at the time of submission. For MappingType
   * XRef, MappingRef is the database name and MappingValue is the database's
   * identifier. For MappingType Name, MappingRef is Alternate or Preferred,
   * and MappingValue is the submitted name of the trait. ClinicalAssertionID
   * is an integer identifier that corresponds 1:1 to the SCV assigned to the
   * submission.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.ClassifiedRecord.TraitMapping trait_mappings = 7;
   */
  traitMappings: ClassifiedRecord_TraitMapping[]
  /**
   * List of deleted SCVs.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.DeletedScv deleted_scvs = 8;
   */
  deletedScvs: DeletedScv[]
  /**
   * List of general citations.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.GeneralCitations general_citations = 9;
   */
  generalCitations: GeneralCitations[]
}
/**
 * Local type for tag `RCVList`.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.ClassifiedRecord.RcvList
 */
export interface ClassifiedRecord_RcvList {
  /**
   * The RCV record.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.RcvAccession rcv_accessions = 1;
   */
  rcvAccessions: RcvAccession[]
  /**
   * The number of submissions (SCV accessions) referencing the VariationID.
   *
   * @generated from protobuf field: optional int32 submission_count = 2;
   */
  submissionCount?: number
  /**
   * The number of idependent observations.
   *
   * @generated from protobuf field: optional int32 independent_observations = 3;
   */
  independentObservations?: number
}
/**
 * Local type for the tag `TraitMapping`.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.ClassifiedRecord.TraitMapping
 */
export interface ClassifiedRecord_TraitMapping {
  /**
   * nested elements
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.ClassifiedRecord.TraitMapping.Medgen medgens = 1;
   */
  medgens: ClassifiedRecord_TraitMapping_Medgen[]
  // attributes

  /**
   * ID of clinical assertion.
   *
   * @generated from protobuf field: int64 clinical_assertion_id = 2;
   */
  clinicalAssertionId: string
  /**
   * The trait type.
   *
   * @generated from protobuf field: string trait_type = 3;
   */
  traitType: string
  /**
   * The mapping type.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.ClassifiedRecord.MappingType mapping_type = 4;
   */
  mappingType: ClassifiedRecord_MappingType
  /**
   * The mapping value.
   *
   * @generated from protobuf field: string mapping_value = 5;
   */
  mappingValue: string
  /**
   * The mapping reference.
   *
   * @generated from protobuf field: string mapping_ref = 6;
   */
  mappingRef: string
}
/**
 * Local type for the tag "MedGen"
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.ClassifiedRecord.TraitMapping.Medgen
 */
export interface ClassifiedRecord_TraitMapping_Medgen {
  /**
   * Name.
   *
   * @generated from protobuf field: string name = 1;
   */
  name: string
  /**
   * CUI.
   *
   * @generated from protobuf field: string cui = 2;
   */
  cui: string
}
/**
 * Local type for the attribute `@MappingType`.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.ClassifiedRecord.MappingType
 */
export enum ClassifiedRecord_MappingType {
  /**
   * unspecified mapping type
   *
   * @generated from protobuf enum value: MAPPING_TYPE_UNSPECIFIED = 0;
   */
  MAPPING_TYPE_UNSPECIFIED = 0,
  /**
   * corresponds to "Name"
   *
   * @generated from protobuf enum value: MAPPING_TYPE_NAME = 1;
   */
  MAPPING_TYPE_NAME = 1,
  /**
   * corresponds to "Xref"
   *
   * @generated from protobuf enum value: MAPPING_TYPE_XREF = 2;
   */
  MAPPING_TYPE_XREF = 2
}
/**
 * This element groups the set of data specific to a VariationArchive
 * record, namely the summary data of what has been submitted about a
 * VariationID AND for Classified records only, the content each
 * submission (SCV) provided.
 *
 * Type for the `<VariationArchive>` type.
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.VariationArchive
 */
export interface VariationArchive {
  // attributes

  /**
   * Numeric variation ID.
   *
   * @generated from protobuf field: int64 variation_id = 1;
   */
  variationId: string
  /**
   * This is ClinVar's name for the variant.  ClinVar uses this term in
   * its web displays
   *
   * @generated from protobuf field: string variation_name = 2;
   */
  variationName: string
  /**
   * Type of the variant.
   *
   * @generated from protobuf field: string variation_type = 3;
   */
  variationType: string
  /**
   * DateCreated is the date when the record first became public in
   * ClinVar.
   *
   * @generated from protobuf field: google.protobuf.Timestamp date_created = 4;
   */
  dateCreated?: Timestamp
  /**
   * The date the record was last updated in the public database. The
   * update may be a change to one of the submitted records (SCVs) or
   * annotation added to the aggregate record by NCBI staff. This date
   * is independent of a version change; annotated added by NCBI may
   * change without representing a change in the version.
   *
   * @generated from protobuf field: google.protobuf.Timestamp date_last_updated = 5;
   */
  dateLastUpdated?: Timestamp
  /**
   * This date is of the most recent submitted record (SCV) for the
   * VCV; it may reflect a new submitted record or an update to a submitted record.
   *
   * @generated from protobuf field: google.protobuf.Timestamp most_recent_submission = 6;
   */
  mostRecentSubmission?: Timestamp
  /**
   * Accession assigned to the variant, or set of variants, that was
   * Classified
   *
   * @generated from protobuf field: string accession = 7;
   */
  accession: string
  /**
   * Version of record and suffix for accession.
   *
   * @generated from protobuf field: int32 version = 8;
   */
  version: number
  /**
   * Number of submitters in record.
   *
   * @generated from protobuf field: int32 number_of_submitters = 9;
   */
  numberOfSubmitters: number
  /**
   * Number of submissions in record.
   *
   * @generated from protobuf field: int32 number_of_submissions = 10;
   */
  numberOfSubmissions: number
  /**
   * Record type.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.VariationArchive.RecordType record_type = 11;
   */
  recordType: VariationArchive_RecordType
  // contained elements

  /**
   * The record's status.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.VariationArchive.RecordStatus record_status = 12;
   */
  recordStatus: VariationArchive_RecordStatus
  /**
   * Pointer to the replacing record; optional.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.RecordHistory replaced_by = 13;
   */
  replacedBy?: RecordHistory
  /**
   * The list of VCV accessions this record has replaced.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.RecordHistory replaceds = 14;
   */
  replaceds: RecordHistory[]
  /**
   * Comment on the record; optional.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.Comment comment = 15;
   */
  comment?: Comment
  /**
   * Specification of the species.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.Species species = 16;
   */
  species?: Species
  /**
   * This element describes the classification of a single
   * allele, haplotype, or genotype based on all submissions to ClinVar. This
   * differs from the element IncludedRecord, which describes simple alleles
   * or haplotypes, referenced in ClassifiedRecord, but for which no explicit
   * classification was submitted. Once that variation is described, details
   * are added about the phenotypes being classified, the classification, the
   * submitters providing the classifications, and all supported evidence.
   *
   * NB: mutually exclusive with `included_record`.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.ClassifiedRecord classified_record = 17;
   */
  classifiedRecord?: ClassifiedRecord
  /**
   * This element describes a single allele or haplotype
   * included in submissions to ClinVar, but for which no explicit
   * classification was submitted. It also references the submissions and the
   * Classified records that include them.
   *
   * NB: mutually exclusive with `classified_record`.
   *
   * @generated from protobuf field: optional annonars.clinvar_data.clinvar_public.IncludedRecord included_record = 18;
   */
  includedRecord?: IncludedRecord
}
/**
 * Enumeration for `@RecordType`.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.VariationArchive.RecordType
 */
export enum VariationArchive_RecordType {
  /**
   * unspecified record type
   *
   * @generated from protobuf enum value: RECORD_TYPE_UNSPECIFIED = 0;
   */
  RECORD_TYPE_UNSPECIFIED = 0,
  /**
   * corresponds to "included"
   *
   * @generated from protobuf enum value: RECORD_TYPE_INCLUDED = 1;
   */
  RECORD_TYPE_INCLUDED = 1,
  /**
   * corresponds to "classified"
   *
   * @generated from protobuf enum value: RECORD_TYPE_CLASSIFIED = 2;
   */
  RECORD_TYPE_CLASSIFIED = 2
}
/**
 * Enumeration for `@RecordStatus`.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.VariationArchive.RecordStatus
 */
export enum VariationArchive_RecordStatus {
  /**
   * unspecified record status
   *
   * @generated from protobuf enum value: RECORD_STATUS_UNSPECIFIED = 0;
   */
  RECORD_STATUS_UNSPECIFIED = 0,
  /**
   * corresponds to "current"
   *
   * @generated from protobuf enum value: RECORD_STATUS_CURRENT = 1;
   */
  RECORD_STATUS_CURRENT = 1,
  /**
   * corresponds to "previous"
   *
   * @generated from protobuf enum value: RECORD_STATUS_PREVIOUS = 2;
   */
  RECORD_STATUS_PREVIOUS = 2,
  /**
   * corresponds to "replaced"
   *
   * @generated from protobuf enum value: RECORD_STATUS_REPLACED = 3;
   */
  RECORD_STATUS_REPLACED = 3,
  /**
   * correspodns to "deleted"
   *
   * @generated from protobuf enum value: RECORD_STATUS_DELETED = 4;
   */
  RECORD_STATUS_DELETED = 4
}
/**
 * The element to group each VariationArchive element in the release
 *
 * Type for the `<ClinVarVariationRelease>` tag.
 *
 * attributes
 *
 * @generated from protobuf message annonars.clinvar_data.clinvar_public.ClinvarVariationRelease
 */
export interface ClinvarVariationRelease {
  /**
   * The current release.
   *
   * @generated from protobuf field: google.protobuf.Timestamp release_date = 1;
   */
  releaseDate?: Timestamp
  // contained elements

  /**
   * List of `<VariationArchive>` tags.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.clinvar_public.VariationArchive variation_archives = 2;
   */
  variationArchives: VariationArchive[]
}
/**
 * Enumeration describing connection between genes and variants.
 *
 * Corresponds to XSD type "GeneVariantRelationship".
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.GeneVariantRelationship
 */
export enum GeneVariantRelationship {
  /**
   * unspecified gene variant
   *
   * @generated from protobuf enum value: GENE_VARIANT_RELATIONSHIP_UNSPECIFIED = 0;
   */
  GENE_VARIANT_RELATIONSHIP_UNSPECIFIED = 0,
  /**
   * corresponds to "variant within gene"
   *
   * @generated from protobuf enum value: GENE_VARIANT_RELATIONSHIP_VARIANT_WITHIN_GENE = 1;
   */
  GENE_VARIANT_RELATIONSHIP_VARIANT_WITHIN_GENE = 1,
  /**
   * corresponds to "gene overlapped by variant" and
   * (legacy:) "genes overlapped by variant"
   *
   * @generated from protobuf enum value: GENE_VARIANT_RELATIONSHIP_GENE_OVERLAPPED_BY_VARIANT = 2;
   */
  GENE_VARIANT_RELATIONSHIP_GENE_OVERLAPPED_BY_VARIANT = 2,
  /**
   * corresponds to "variant near gene, upstream" and
   * (legacy:) "near gene, upstream"
   *
   * @generated from protobuf enum value: GENE_VARIANT_RELATIONSHIP_NEAR_GENE_UPSTREAM = 3;
   */
  GENE_VARIANT_RELATIONSHIP_NEAR_GENE_UPSTREAM = 3,
  /**
   * corresponds to "variant near gene, downstream" and
   * (legacy:) "near gene, downstream"
   *
   * @generated from protobuf enum value: GENE_VARIANT_RELATIONSHIP_NEAR_GENE_DOWNSTREAM = 4;
   */
  GENE_VARIANT_RELATIONSHIP_NEAR_GENE_DOWNSTREAM = 4,
  /**
   * corresponds to "asserted, but not computed"
   *
   * @generated from protobuf enum value: GENE_VARIANT_RELATIONSHIP_ASSERTED_BUT_NOT_COMPUTED = 5;
   */
  GENE_VARIANT_RELATIONSHIP_ASSERTED_BUT_NOT_COMPUTED = 5,
  /**
   * corresponds to "within multiple genes by overlap"
   *
   * @generated from protobuf enum value: GENE_VARIANT_RELATIONSHIP_WITHIN_MULTIPLE_GENES_BY_OVERLAP = 6;
   */
  GENE_VARIANT_RELATIONSHIP_WITHIN_MULTIPLE_GENES_BY_OVERLAP = 6,
  /**
   * corresponds to "within single gene"
   *
   * @generated from protobuf enum value: GENE_VARIANT_RELATIONSHIP_WITHIN_SINGLE_GENE = 7;
   */
  GENE_VARIANT_RELATIONSHIP_WITHIN_SINGLE_GENE = 7
}
/**
 * Enumeration describing severity.
 *
 * Corresponds to XSD type "typeSeverity"
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.Severity
 */
export enum Severity {
  /**
   * unspecified severity
   *
   * @generated from protobuf enum value: SEVERITY_UNSPECIFIED = 0;
   */
  SEVERITY_UNSPECIFIED = 0,
  /**
   * corresponds to "mild"
   *
   * @generated from protobuf enum value: SEVERITY_MILD = 1;
   */
  SEVERITY_MILD = 1,
  /**
   * corresponds to "moderate"
   *
   * @generated from protobuf enum value: SEVERITY_MODERATE = 2;
   */
  SEVERITY_MODERATE = 2,
  /**
   * corresponds to "sever"
   *
   * @generated from protobuf enum value: SEVERITY_SEVERE = 3;
   */
  SEVERITY_SEVERE = 3
}
/**
 * Enumeration describing status.
 *
 * Corresponds to `typeStatus` in XSD.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.Status
 */
export enum Status {
  /**
   * unspecified status
   *
   * @generated from protobuf enum value: STATUS_UNSPECIFIED = 0;
   */
  STATUS_UNSPECIFIED = 0,
  /**
   * corresponds to "current"
   *
   * @generated from protobuf enum value: STATUS_CURRENT = 1;
   */
  STATUS_CURRENT = 1,
  /**
   * corresponds to "completed and retired"
   *
   * @generated from protobuf enum value: STATUS_COMPLETED_AND_RETIRED = 2;
   */
  STATUS_COMPLETED_AND_RETIRED = 2,
  /**
   * corresponds to "delete"
   *
   * @generated from protobuf enum value: STATUS_DELETE = 3;
   */
  STATUS_DELETE = 3,
  /**
   * corresponds to "in development"
   *
   * @generated from protobuf enum value: STATUS_IN_DEVELOPMENT = 4;
   */
  STATUS_IN_DEVELOPMENT = 4,
  /**
   * corresponds to "reclassified"
   *
   * @generated from protobuf enum value: STATUS_RECLASSIFIED = 5;
   */
  STATUS_RECLASSIFIED = 5,
  /**
   * corresponds to "reject"
   *
   * @generated from protobuf enum value: STATUS_REJECT = 6;
   */
  STATUS_REJECT = 6,
  /**
   * corresponds to "secondary"
   *
   * @generated from protobuf enum value: STATUS_SECONDARY = 7;
   */
  STATUS_SECONDARY = 7,
  /**
   * corresponds to "suppressed"
   *
   * @generated from protobuf enum value: STATUS_SUPPRESSED = 8;
   */
  STATUS_SUPPRESSED = 8,
  /**
   * corresponds to "under review"
   *
   * @generated from protobuf enum value: STATUS_UNDER_REVIEW = 9;
   */
  STATUS_UNDER_REVIEW = 9
}
/**
 * Enumeration describing submitter review status.
 *
 * Corresponds to `typeSubmitterReviewStatusValue` in XSD.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.SubmitterReviewStatus
 */
export enum SubmitterReviewStatus {
  /**
   * unspecified status
   *
   * @generated from protobuf enum value: SUBMITTER_REVIEW_STATUS_UNSPECIFIED = 0;
   */
  SUBMITTER_REVIEW_STATUS_UNSPECIFIED = 0,
  /**
   * corresponds to "no classification provided"
   *
   * @generated from protobuf enum value: SUBMITTER_REVIEW_STATUS_NO_CLASSIFICATION_PROVIDED = 1;
   */
  SUBMITTER_REVIEW_STATUS_NO_CLASSIFICATION_PROVIDED = 1,
  /**
   * corresponds to "no assertion criteria provided"
   *
   * @generated from protobuf enum value: SUBMITTER_REVIEW_STATUS_NO_ASSERTION_CRITERIA_PROVIDED = 2;
   */
  SUBMITTER_REVIEW_STATUS_NO_ASSERTION_CRITERIA_PROVIDED = 2,
  /**
   * corresponds to "criteria provided, single submitter"
   *
   * @generated from protobuf enum value: SUBMITTER_REVIEW_STATUS_CRITERIA_PROVIDED_SINGLE_SUBMITTER = 3;
   */
  SUBMITTER_REVIEW_STATUS_CRITERIA_PROVIDED_SINGLE_SUBMITTER = 3,
  /**
   * corresponds to "reviewed by expert panel"
   *
   * @generated from protobuf enum value: SUBMITTER_REVIEW_STATUS_REVIEWED_BY_EXPERT_PANEL = 4;
   */
  SUBMITTER_REVIEW_STATUS_REVIEWED_BY_EXPERT_PANEL = 4,
  /**
   * corresponds to "practice guideline"
   *
   * @generated from protobuf enum value: SUBMITTER_REVIEW_STATUS_PRACTICE_GUIDELINE = 5;
   */
  SUBMITTER_REVIEW_STATUS_PRACTICE_GUIDELINE = 5,
  /**
   * corresponds to "flagged submission"
   *
   * @generated from protobuf enum value: SUBMITTER_REVIEW_STATUS_FLAGGED_SUBMISSION = 6;
   */
  SUBMITTER_REVIEW_STATUS_FLAGGED_SUBMISSION = 6,
  /**
   * corresponds to "criteria provided, multiple submitters, no conflicts"
   *
   * @generated from protobuf enum value: SUBMITTER_REVIEW_STATUS_CRITERIA_PROVIDED_MULTIPLE_SUBMITTERS_NO_CONFLICTS = 7;
   */
  SUBMITTER_REVIEW_STATUS_CRITERIA_PROVIDED_MULTIPLE_SUBMITTERS_NO_CONFLICTS = 7,
  /**
   * corresponds to "criteria provided, conflicting classifications"
   *
   * @generated from protobuf enum value: SUBMITTER_REVIEW_STATUS_CRITERIA_PROVIDED_CONFLICTING_CLASSIFICATIONS = 8;
   */
  SUBMITTER_REVIEW_STATUS_CRITERIA_PROVIDED_CONFLICTING_CLASSIFICATIONS = 8,
  /**
   * corresponds to "classified by single submitter"
   *
   * @generated from protobuf enum value: SUBMITTER_REVIEW_STATUS_CLASSIFIED_BY_SINGLE_SUBMITTER = 9;
   */
  SUBMITTER_REVIEW_STATUS_CLASSIFIED_BY_SINGLE_SUBMITTER = 9,
  /**
   * corresponds to "reviewed by professional society"
   *
   * @generated from protobuf enum value: SUBMITTER_REVIEW_STATUS_REVIEWED_BY_PROFESSIONAL_SOCIETY = 10;
   */
  SUBMITTER_REVIEW_STATUS_REVIEWED_BY_PROFESSIONAL_SOCIETY = 10,
  /**
   * corresponds to "not classified by submitter"
   *
   * @generated from protobuf enum value: SUBMITTER_REVIEW_STATUS_NOT_CLASSIFIED_BY_SUBMITTER = 11;
   */
  SUBMITTER_REVIEW_STATUS_NOT_CLASSIFIED_BY_SUBMITTER = 11,
  /**
   * corresponds to "classified by multiple submitters"
   *
   * @generated from protobuf enum value: SUBMITTER_REVIEW_STATUS_CLASSIFIED_BY_MULTIPLE_SUBMITTERS = 12;
   */
  SUBMITTER_REVIEW_STATUS_CLASSIFIED_BY_MULTIPLE_SUBMITTERS = 12
}
/**
 * Enumeration describing zygosity.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.Zygosity
 */
export enum Zygosity {
  /**
   * unspecified zygosity
   *
   * @generated from protobuf enum value: ZYGOSITY_UNSPECIFIED = 0;
   */
  ZYGOSITY_UNSPECIFIED = 0,
  /**
   * corresponds to "Homozygote"
   *
   * @generated from protobuf enum value: ZYGOSITY_HOMOZYGOTE = 1;
   */
  ZYGOSITY_HOMOZYGOTE = 1,
  /**
   * corresponds to "SingleHeterozygote"
   *
   * @generated from protobuf enum value: ZYGOSITY_SINGLE_HETEROZYGOTE = 2;
   */
  ZYGOSITY_SINGLE_HETEROZYGOTE = 2,
  /**
   * corresponds to "CompoundHeterozygote"
   *
   * @generated from protobuf enum value: ZYGOSITY_COMPOUND_HETEROZYGOTE = 3;
   */
  ZYGOSITY_COMPOUND_HETEROZYGOTE = 3,
  /**
   * corresponds to "Hemizygote"
   *
   * @generated from protobuf enum value: ZYGOSITY_HEMIZYGOTE = 4;
   */
  ZYGOSITY_HEMIZYGOTE = 4,
  /**
   * corresponds to "not provided"
   *
   * @generated from protobuf enum value: ZYGOSITY_NOT_PROVIDED = 5;
   */
  ZYGOSITY_NOT_PROVIDED = 5
}
/**
 * Enumeration describing assertion type attributes.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.Assertion
 */
export enum Assertion {
  /**
   * unspecified assertion type attribute
   *
   * @generated from protobuf enum value: ASSERTION_UNSPECIFIED = 0;
   */
  ASSERTION_UNSPECIFIED = 0,
  /**
   * corresponds to "variation to disease"
   *
   * @generated from protobuf enum value: ASSERTION_VARIATION_TO_DISEASE = 1;
   */
  ASSERTION_VARIATION_TO_DISEASE = 1,
  /**
   * corresponds to "variation to included disease"
   *
   * @generated from protobuf enum value: ASSERTION_VARIATION_TO_INCLUDED_DISEASE = 2;
   */
  ASSERTION_VARIATION_TO_INCLUDED_DISEASE = 2,
  /**
   * corresponds to "variation in modifier gene to disease"
   *
   * @generated from protobuf enum value: ASSERTION_VARIATION_IN_MODIFIER_GENE_TO_DISEASE = 3;
   */
  ASSERTION_VARIATION_IN_MODIFIER_GENE_TO_DISEASE = 3,
  /**
   * corresponds to "confers sensitivity"
   *
   * @generated from protobuf enum value: ASSERTION_CONFERS_SENSITIVITY = 4;
   */
  ASSERTION_CONFERS_SENSITIVITY = 4,
  /**
   * corresponds to "confers resistance"
   *
   * @generated from protobuf enum value: ASSERTION_CONFERS_RESISTANCE = 5;
   */
  ASSERTION_CONFERS_RESISTANCE = 5,
  /**
   * corresponds to "variant to named protein"
   *
   * @generated from protobuf enum value: ASSERTION_VARIANT_TO_NAMED_PROTEIN = 6;
   */
  ASSERTION_VARIANT_TO_NAMED_PROTEIN = 6
}
/**
 * Enumeration describing aggregate germline review status value.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.AggregateGermlineReviewStatus
 */
export enum AggregateGermlineReviewStatus {
  /**
   * unspecified aggregate germline review status value
   *
   * @generated from protobuf enum value: AGGREGATE_GERMLINE_REVIEW_STATUS_UNSPECIFIED = 0;
   */
  AGGREGATE_GERMLINE_REVIEW_STATUS_UNSPECIFIED = 0,
  /**
   * corresponds to "no classification provided"
   *
   * @generated from protobuf enum value: AGGREGATE_GERMLINE_REVIEW_STATUS_NO_CLASSIFICATION_PROVIDED = 1;
   */
  AGGREGATE_GERMLINE_REVIEW_STATUS_NO_CLASSIFICATION_PROVIDED = 1,
  /**
   * corresponds to "no assertion criteria provided"
   *
   * @generated from protobuf enum value: AGGREGATE_GERMLINE_REVIEW_STATUS_NO_ASSERTION_CRITERIA_PROVIDED = 2;
   */
  AGGREGATE_GERMLINE_REVIEW_STATUS_NO_ASSERTION_CRITERIA_PROVIDED = 2,
  /**
   * corresponds to "criteria provided, single submitter"
   *
   * @generated from protobuf enum value: AGGREGATE_GERMLINE_REVIEW_STATUS_CRITERIA_PROVIDED_SINGLE_SUBMITTER = 3;
   */
  AGGREGATE_GERMLINE_REVIEW_STATUS_CRITERIA_PROVIDED_SINGLE_SUBMITTER = 3,
  /**
   * corresponds to "criteria provided, multiple submitters, no conflicts"
   *
   * @generated from protobuf enum value: AGGREGATE_GERMLINE_REVIEW_STATUS_CRITERIA_PROVIDED_MULTIPLE_SUBMITTERS_NO_CONFLICTS = 4;
   */
  AGGREGATE_GERMLINE_REVIEW_STATUS_CRITERIA_PROVIDED_MULTIPLE_SUBMITTERS_NO_CONFLICTS = 4,
  /**
   * corresponds to "criteria provided, conflicting classifications"
   *
   * @generated from protobuf enum value: AGGREGATE_GERMLINE_REVIEW_STATUS_CRITERIA_PROVIDED_CONFLICTING_CLASSIFICATIONS = 5;
   */
  AGGREGATE_GERMLINE_REVIEW_STATUS_CRITERIA_PROVIDED_CONFLICTING_CLASSIFICATIONS = 5,
  /**
   * corresponds to "reviewed by expert panel"
   *
   * @generated from protobuf enum value: AGGREGATE_GERMLINE_REVIEW_STATUS_REVIEWED_BY_EXPERT_PANEL = 6;
   */
  AGGREGATE_GERMLINE_REVIEW_STATUS_REVIEWED_BY_EXPERT_PANEL = 6,
  /**
   * corresponds to "practice guideline"
   *
   * @generated from protobuf enum value: AGGREGATE_GERMLINE_REVIEW_STATUS_PRACTICE_GUIDELINE = 7;
   */
  AGGREGATE_GERMLINE_REVIEW_STATUS_PRACTICE_GUIDELINE = 7,
  /**
   * corresponds to "no classifications from unflagged records"
   *
   * @generated from protobuf enum value: AGGREGATE_GERMLINE_REVIEW_STATUS_NO_CLASSIFICATIONS_FROM_UNFLAGGED_RECORDS = 8;
   */
  AGGREGATE_GERMLINE_REVIEW_STATUS_NO_CLASSIFICATIONS_FROM_UNFLAGGED_RECORDS = 8,
  /**
   * corresponds to "no classification for the single variant"
   *
   * @generated from protobuf enum value: AGGREGATE_GERMLINE_REVIEW_STATUS_NO_CLASSIFICATION_FOR_THE_SINGLE_VARIANT = 9;
   */
  AGGREGATE_GERMLINE_REVIEW_STATUS_NO_CLASSIFICATION_FOR_THE_SINGLE_VARIANT = 9
}
/**
 * Enumeration describing aggregate somatic clinical impact review status value.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.AggregateSomaticClinicalImpactReviewStatus
 */
export enum AggregateSomaticClinicalImpactReviewStatus {
  /**
   * unspecified aggregate somatic clinical impact review status value
   *
   * @generated from protobuf enum value: AGGREGATE_SOMATIC_CLINICAL_IMPACT_REVIEW_STATUS_UNSPECIFIED = 0;
   */
  AGGREGATE_SOMATIC_CLINICAL_IMPACT_REVIEW_STATUS_UNSPECIFIED = 0,
  /**
   * corresponds to "no classification provided"
   *
   * @generated from protobuf enum value: AGGREGATE_SOMATIC_CLINICAL_IMPACT_REVIEW_STATUS_NO_CLASSIFICATION_PROVIDED = 1;
   */
  AGGREGATE_SOMATIC_CLINICAL_IMPACT_REVIEW_STATUS_NO_CLASSIFICATION_PROVIDED = 1,
  /**
   * corresponds to "no assertion criteria provided"
   *
   * @generated from protobuf enum value: AGGREGATE_SOMATIC_CLINICAL_IMPACT_REVIEW_STATUS_NO_ASSERTION_CRITERIA_PROVIDED = 2;
   */
  AGGREGATE_SOMATIC_CLINICAL_IMPACT_REVIEW_STATUS_NO_ASSERTION_CRITERIA_PROVIDED = 2,
  /**
   * corresponds to "criteria provided, single submitter"
   *
   * @generated from protobuf enum value: AGGREGATE_SOMATIC_CLINICAL_IMPACT_REVIEW_STATUS_CRITERIA_PROVIDED_SINGLE_SUBMITTER = 3;
   */
  AGGREGATE_SOMATIC_CLINICAL_IMPACT_REVIEW_STATUS_CRITERIA_PROVIDED_SINGLE_SUBMITTER = 3,
  /**
   * corresponds to "criteria provided, multiple submitters"
   *
   * @generated from protobuf enum value: AGGREGATE_SOMATIC_CLINICAL_IMPACT_REVIEW_STATUS_CRITERIA_PROVIDED_MULTIPLE_SUBMITTERS = 4;
   */
  AGGREGATE_SOMATIC_CLINICAL_IMPACT_REVIEW_STATUS_CRITERIA_PROVIDED_MULTIPLE_SUBMITTERS = 4,
  /**
   * corresponds to "reviewed by expert panel"
   *
   * @generated from protobuf enum value: AGGREGATE_SOMATIC_CLINICAL_IMPACT_REVIEW_STATUS_REVIEWED_BY_EXPERT_PANEL = 5;
   */
  AGGREGATE_SOMATIC_CLINICAL_IMPACT_REVIEW_STATUS_REVIEWED_BY_EXPERT_PANEL = 5,
  /**
   * corresponds to "practice guideline"
   *
   * @generated from protobuf enum value: AGGREGATE_SOMATIC_CLINICAL_IMPACT_REVIEW_STATUS_PRACTICE_GUIDELINE = 6;
   */
  AGGREGATE_SOMATIC_CLINICAL_IMPACT_REVIEW_STATUS_PRACTICE_GUIDELINE = 6,
  /**
   * corresponds to "no classifications from unflagged records"
   *
   * @generated from protobuf enum value: AGGREGATE_SOMATIC_CLINICAL_IMPACT_REVIEW_STATUS_NO_CLASSIFICATIONS_FROM_UNFLAGGED_RECORDS = 7;
   */
  AGGREGATE_SOMATIC_CLINICAL_IMPACT_REVIEW_STATUS_NO_CLASSIFICATIONS_FROM_UNFLAGGED_RECORDS = 7,
  /**
   * corresponds to "no classification for the single variant"
   *
   * @generated from protobuf enum value: AGGREGATE_SOMATIC_CLINICAL_IMPACT_REVIEW_STATUS_NO_CLASSIFICATION_FOR_THE_SINGLE_VARIANT = 8;
   */
  AGGREGATE_SOMATIC_CLINICAL_IMPACT_REVIEW_STATUS_NO_CLASSIFICATION_FOR_THE_SINGLE_VARIANT = 8
}
/**
 * Enumeration describing aggregate oncogenicity review status value.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.AggregateOncogenicityReviewStatus
 */
export enum AggregateOncogenicityReviewStatus {
  /**
   * unspecified aggregate oncogenicity review status value
   *
   * @generated from protobuf enum value: AGGREGATE_ONCOGENICITY_REVIEW_STATUS_UNSPECIFIED = 0;
   */
  AGGREGATE_ONCOGENICITY_REVIEW_STATUS_UNSPECIFIED = 0,
  /**
   * corresponds to "no classification provided"
   *
   * @generated from protobuf enum value: AGGREGATE_ONCOGENICITY_REVIEW_STATUS_NO_CLASSIFICATION_PROVIDED = 1;
   */
  AGGREGATE_ONCOGENICITY_REVIEW_STATUS_NO_CLASSIFICATION_PROVIDED = 1,
  /**
   * corresponds to "no assertion criteria provided"
   *
   * @generated from protobuf enum value: AGGREGATE_ONCOGENICITY_REVIEW_STATUS_NO_ASSERTION_CRITERIA_PROVIDED = 2;
   */
  AGGREGATE_ONCOGENICITY_REVIEW_STATUS_NO_ASSERTION_CRITERIA_PROVIDED = 2,
  /**
   * corresponds to "criteria provided, single submitter"
   *
   * @generated from protobuf enum value: AGGREGATE_ONCOGENICITY_REVIEW_STATUS_CRITERIA_PROVIDED_SINGLE_SUBMITTER = 3;
   */
  AGGREGATE_ONCOGENICITY_REVIEW_STATUS_CRITERIA_PROVIDED_SINGLE_SUBMITTER = 3,
  /**
   * corresponds to "criteria provided, multiple submitters, no conflicts"
   *
   * @generated from protobuf enum value: AGGREGATE_ONCOGENICITY_REVIEW_STATUS_CRITERIA_PROVIDED_MULTIPLE_SUBMITTERS_NO_CONFLICTS = 4;
   */
  AGGREGATE_ONCOGENICITY_REVIEW_STATUS_CRITERIA_PROVIDED_MULTIPLE_SUBMITTERS_NO_CONFLICTS = 4,
  /**
   * corresponds to "criteria provided, conflicting classifications"
   *
   * @generated from protobuf enum value: AGGREGATE_ONCOGENICITY_REVIEW_STATUS_CRITERIA_PROVIDED_CONFLICTING_CLASSIFICATIONS = 5;
   */
  AGGREGATE_ONCOGENICITY_REVIEW_STATUS_CRITERIA_PROVIDED_CONFLICTING_CLASSIFICATIONS = 5,
  /**
   * corresponds to "reviewed by expert panel"
   *
   * @generated from protobuf enum value: AGGREGATE_ONCOGENICITY_REVIEW_STATUS_REVIEWED_BY_EXPERT_PANEL = 6;
   */
  AGGREGATE_ONCOGENICITY_REVIEW_STATUS_REVIEWED_BY_EXPERT_PANEL = 6,
  /**
   * corresponds to "practice guideline"
   *
   * @generated from protobuf enum value: AGGREGATE_ONCOGENICITY_REVIEW_STATUS_PRACTICE_GUIDELINE = 7;
   */
  AGGREGATE_ONCOGENICITY_REVIEW_STATUS_PRACTICE_GUIDELINE = 7,
  /**
   * corresponds to "no classifications from unflagged records"
   *
   * @generated from protobuf enum value: AGGREGATE_ONCOGENICITY_REVIEW_STATUS_NO_CLASSIFICATIONS_FROM_UNFLAGGED_RECORDS = 8;
   */
  AGGREGATE_ONCOGENICITY_REVIEW_STATUS_NO_CLASSIFICATIONS_FROM_UNFLAGGED_RECORDS = 8,
  /**
   * corresponds to "no classification for the single variant"
   *
   * @generated from protobuf enum value: AGGREGATE_ONCOGENICITY_REVIEW_STATUS_NO_CLASSIFICATION_FOR_THE_SINGLE_VARIANT = 9;
   */
  AGGREGATE_ONCOGENICITY_REVIEW_STATUS_NO_CLASSIFICATION_FOR_THE_SINGLE_VARIANT = 9
}
/**
 * Enumeration describing origin.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.Origin
 */
export enum Origin {
  /**
   * unspecified origin
   *
   * @generated from protobuf enum value: ORIGIN_UNSPECIFIED = 0;
   */
  ORIGIN_UNSPECIFIED = 0,
  /**
   * corresponds to "germline"
   *
   * @generated from protobuf enum value: ORIGIN_GERMLINE = 1;
   */
  ORIGIN_GERMLINE = 1,
  /**
   * corresponds to "somatic"
   *
   * @generated from protobuf enum value: ORIGIN_SOMATIC = 2;
   */
  ORIGIN_SOMATIC = 2,
  /**
   * corresponds to "de novo"
   *
   * @generated from protobuf enum value: ORIGIN_DE_NOVO = 3;
   */
  ORIGIN_DE_NOVO = 3,
  /**
   * corresponds to "not provided"
   *
   * @generated from protobuf enum value: ORIGIN_NOT_PROVIDED = 4;
   */
  ORIGIN_NOT_PROVIDED = 4,
  /**
   * corresponds to "inherited"
   *
   * @generated from protobuf enum value: ORIGIN_INHERITED = 5;
   */
  ORIGIN_INHERITED = 5,
  /**
   * corresponds to "maternal"
   *
   * @generated from protobuf enum value: ORIGIN_MATERNAL = 6;
   */
  ORIGIN_MATERNAL = 6,
  /**
   * corresponds to "paternal"
   *
   * @generated from protobuf enum value: ORIGIN_PATERNAL = 7;
   */
  ORIGIN_PATERNAL = 7,
  /**
   * corresponds to "uniparental"
   *
   * @generated from protobuf enum value: ORIGIN_UNIPARENTAL = 8;
   */
  ORIGIN_UNIPARENTAL = 8,
  /**
   * corresponds to "biparental"
   *
   * @generated from protobuf enum value: ORIGIN_BIPARENTAL = 9;
   */
  ORIGIN_BIPARENTAL = 9,
  /**
   * corresponds to "not-reported"
   *
   * @generated from protobuf enum value: ORIGIN_NOT_REPORTED = 10;
   */
  ORIGIN_NOT_REPORTED = 10,
  /**
   * corresponds to "tested-inconclusive"
   *
   * @generated from protobuf enum value: ORIGIN_TESTED_INCONCLUSIVE = 11;
   */
  ORIGIN_TESTED_INCONCLUSIVE = 11,
  /**
   * corresponds to "unknown"
   *
   * @generated from protobuf enum value: ORIGIN_UNKNOWN = 12;
   */
  ORIGIN_UNKNOWN = 12,
  /**
   * corresponds to "not applicable"
   *
   * @generated from protobuf enum value: ORIGIN_NOT_APPLICABLE = 13;
   */
  ORIGIN_NOT_APPLICABLE = 13,
  /**
   * corresponds to "experimentally generated"
   *
   * @generated from protobuf enum value: ORIGIN_EXPERIMENTALLY_GENERATED = 14;
   */
  ORIGIN_EXPERIMENTALLY_GENERATED = 14
}
/**
 * Enumeration describing chromosome.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.Chromosome
 */
export enum Chromosome {
  /**
   * unspecified chromosome
   *
   * @generated from protobuf enum value: CHROMOSOME_UNSPECIFIED = 0;
   */
  CHROMOSOME_UNSPECIFIED = 0,
  /**
   * corresponds to "1"
   *
   * @generated from protobuf enum value: CHROMOSOME_1 = 1;
   */
  CHROMOSOME_1 = 1,
  /**
   * corresponds to "2"
   *
   * @generated from protobuf enum value: CHROMOSOME_2 = 2;
   */
  CHROMOSOME_2 = 2,
  /**
   * corresponds to "3"
   *
   * @generated from protobuf enum value: CHROMOSOME_3 = 3;
   */
  CHROMOSOME_3 = 3,
  /**
   * corresponds to "4"
   *
   * @generated from protobuf enum value: CHROMOSOME_4 = 4;
   */
  CHROMOSOME_4 = 4,
  /**
   * corresponds to "5"
   *
   * @generated from protobuf enum value: CHROMOSOME_5 = 5;
   */
  CHROMOSOME_5 = 5,
  /**
   * corresponds to "6"
   *
   * @generated from protobuf enum value: CHROMOSOME_6 = 6;
   */
  CHROMOSOME_6 = 6,
  /**
   * corresponds to "7"
   *
   * @generated from protobuf enum value: CHROMOSOME_7 = 7;
   */
  CHROMOSOME_7 = 7,
  /**
   * corresponds to "8"
   *
   * @generated from protobuf enum value: CHROMOSOME_8 = 8;
   */
  CHROMOSOME_8 = 8,
  /**
   * corresponds to "9"
   *
   * @generated from protobuf enum value: CHROMOSOME_9 = 9;
   */
  CHROMOSOME_9 = 9,
  /**
   * corresponds to "10"
   *
   * @generated from protobuf enum value: CHROMOSOME_10 = 10;
   */
  CHROMOSOME_10 = 10,
  /**
   * corresponds to "11"
   *
   * @generated from protobuf enum value: CHROMOSOME_11 = 11;
   */
  CHROMOSOME_11 = 11,
  /**
   * corresponds to "12"
   *
   * @generated from protobuf enum value: CHROMOSOME_12 = 12;
   */
  CHROMOSOME_12 = 12,
  /**
   * corresponds to "13"
   *
   * @generated from protobuf enum value: CHROMOSOME_13 = 13;
   */
  CHROMOSOME_13 = 13,
  /**
   * corresponds to "14"
   *
   * @generated from protobuf enum value: CHROMOSOME_14 = 14;
   */
  CHROMOSOME_14 = 14,
  /**
   * corresponds to "15"
   *
   * @generated from protobuf enum value: CHROMOSOME_15 = 15;
   */
  CHROMOSOME_15 = 15,
  /**
   * corresponds to "16"
   *
   * @generated from protobuf enum value: CHROMOSOME_16 = 16;
   */
  CHROMOSOME_16 = 16,
  /**
   * corresponds to "17"
   *
   * @generated from protobuf enum value: CHROMOSOME_17 = 17;
   */
  CHROMOSOME_17 = 17,
  /**
   * corresponds to "18"
   *
   * @generated from protobuf enum value: CHROMOSOME_18 = 18;
   */
  CHROMOSOME_18 = 18,
  /**
   * corresponds to "19"
   *
   * @generated from protobuf enum value: CHROMOSOME_19 = 19;
   */
  CHROMOSOME_19 = 19,
  /**
   * corresponds to "20"
   *
   * @generated from protobuf enum value: CHROMOSOME_20 = 20;
   */
  CHROMOSOME_20 = 20,
  /**
   * corresponds to "21"
   *
   * @generated from protobuf enum value: CHROMOSOME_21 = 21;
   */
  CHROMOSOME_21 = 21,
  /**
   * corresponds to "22"
   *
   * @generated from protobuf enum value: CHROMOSOME_22 = 22;
   */
  CHROMOSOME_22 = 22,
  /**
   * corresponds to "X"
   *
   * @generated from protobuf enum value: CHROMOSOME_X = 23;
   */
  CHROMOSOME_X = 23,
  /**
   * corresponds to "Y"
   *
   * @generated from protobuf enum value: CHROMOSOME_Y = 24;
   */
  CHROMOSOME_Y = 24,
  /**
   * corresponds to "MT"
   *
   * @generated from protobuf enum value: CHROMOSOME_MT = 25;
   */
  CHROMOSOME_MT = 25,
  /**
   * corresponds to "PAR"
   *
   * @generated from protobuf enum value: CHROMOSOME_PAR = 26;
   */
  CHROMOSOME_PAR = 26,
  /**
   * corresponds to "Un"
   *
   * @generated from protobuf enum value: CHROMOSOME_UN = 27;
   */
  CHROMOSOME_UN = 27
}
/**
 * Enumeration describing comment type.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.CommentType
 */
export enum CommentType {
  /**
   * unspecified comment type
   *
   * @generated from protobuf enum value: COMMENT_TYPE_UNSPECIFIED = 0;
   */
  COMMENT_TYPE_UNSPECIFIED = 0,
  /**
   * corresponds to "public"
   *
   * @generated from protobuf enum value: COMMENT_TYPE_PUBLIC = 1;
   */
  COMMENT_TYPE_PUBLIC = 1,
  /**
   * corresponds to "ConvertedByNCBI"
   *
   * @generated from protobuf enum value: COMMENT_TYPE_CONVERTED_BY_NCB = 2;
   */
  COMMENT_TYPE_CONVERTED_BY_NCB = 2,
  /**
   * corresponds to "MissingFromAssembly"
   *
   * @generated from protobuf enum value: COMMENT_TYPE_MISSING_FROM_ASSEMBLY = 3;
   */
  COMMENT_TYPE_MISSING_FROM_ASSEMBLY = 3,
  /**
   * corresponds to "GenomicLocationNotEstablished"
   *
   * @generated from protobuf enum value: COMMENT_TYPE_GENOMIC_LOCATION_NOT_ESTABLISHED = 4;
   */
  COMMENT_TYPE_GENOMIC_LOCATION_NOT_ESTABLISHED = 4,
  /**
   * corresponds to "LocationOnGenomeAndProductNotAligned"
   *
   * @generated from protobuf enum value: COMMENT_TYPE_LOCATION_ON_GENOME_AND_PRODUCT_NOT_ALIGNED = 5;
   */
  COMMENT_TYPE_LOCATION_ON_GENOME_AND_PRODUCT_NOT_ALIGNED = 5,
  /**
   * corresponds to "DeletionComment"
   *
   * @generated from protobuf enum value: COMMENT_TYPE_DELETION_COMMENT = 6;
   */
  COMMENT_TYPE_DELETION_COMMENT = 6,
  /**
   * corresponds to "MergeComment"
   *
   * @generated from protobuf enum value: COMMENT_TYPE_MERGE_COMMENT = 7;
   */
  COMMENT_TYPE_MERGE_COMMENT = 7,
  /**
   * corresponds to "AssemblySpecificAlleleDefinition"
   *
   * @generated from protobuf enum value: COMMENT_TYPE_ASSEMBLY_SPECIFIC_ALLELE_DEFINITION = 8;
   */
  COMMENT_TYPE_ASSEMBLY_SPECIFIC_ALLELE_DEFINITION = 8,
  /**
   * corresponds to "AlignmentGapMakesAppearInconsistent"
   *
   * @generated from protobuf enum value: COMMENT_TYPE_ALIGNMENT_GAP_MAKES_APPEAR_INCONSISTENT = 9;
   */
  COMMENT_TYPE_ALIGNMENT_GAP_MAKES_APPEAR_INCONSISTENT = 9,
  /**
   * corresponds to "ExplanationOfClassification"
   *
   * @generated from protobuf enum value: COMMENT_TYPE_EXPLANATION_OF_CLASSIFICATION = 10;
   */
  COMMENT_TYPE_EXPLANATION_OF_CLASSIFICATION = 10,
  /**
   * corresponds to "FlaggedComment"
   *
   * @generated from protobuf enum value: COMMENT_TYPE_FLAGGED_COMMENT = 11;
   */
  COMMENT_TYPE_FLAGGED_COMMENT = 11
}
/**
 * Enumeration describing nucleotide sequence.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.NucleotideSequence
 */
export enum NucleotideSequence {
  /**
   * unspecified nucleotide sequence
   *
   * @generated from protobuf enum value: NUCLEOTIDE_SEQUENCE_UNSPECIFIED = 0;
   */
  NUCLEOTIDE_SEQUENCE_UNSPECIFIED = 0,
  /**
   * corresponds to "genomic, top-level"
   *
   * @generated from protobuf enum value: NUCLEOTIDE_SEQUENCE_GENOMIC_TOP_LEVEL = 1;
   */
  NUCLEOTIDE_SEQUENCE_GENOMIC_TOP_LEVEL = 1,
  /**
   * corresponds to "genomic, RefSeqGene"
   *
   * @generated from protobuf enum value: NUCLEOTIDE_SEQUENCE_GENOMIC_REF_SEQ_GENE = 2;
   */
  NUCLEOTIDE_SEQUENCE_GENOMIC_REF_SEQ_GENE = 2,
  /**
   * corresponds to "genomic"
   *
   * @generated from protobuf enum value: NUCLEOTIDE_SEQUENCE_GENOMIC = 3;
   */
  NUCLEOTIDE_SEQUENCE_GENOMIC = 3,
  /**
   * corresponds to "coding"
   *
   * @generated from protobuf enum value: NUCLEOTIDE_SEQUENCE_CODING = 4;
   */
  NUCLEOTIDE_SEQUENCE_CODING = 4,
  /**
   * corresponds to "non-coding"
   *
   * @generated from protobuf enum value: NUCLEOTIDE_SEQUENCE_NON_CODING = 5;
   */
  NUCLEOTIDE_SEQUENCE_NON_CODING = 5,
  /**
   * corresponds to "protein"
   *
   * @generated from protobuf enum value: NUCLEOTIDE_SEQUENCE_PROTEIN = 6;
   */
  NUCLEOTIDE_SEQUENCE_PROTEIN = 6
}
/**
 * Enumeration describing protein sequence.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.ProteinSequence
 */
export enum ProteinSequence {
  /**
   * unspecified protein sequence
   *
   * @generated from protobuf enum value: PROTEIN_SEQUENCE_UNSPECIFIED = 0;
   */
  PROTEIN_SEQUENCE_UNSPECIFIED = 0,
  /**
   * corresponds to "protein"
   *
   * @generated from protobuf enum value: PROTEIN_SEQUENCE_PROTEIN = 1;
   */
  PROTEIN_SEQUENCE_PROTEIN = 1
}
/**
 * Enumeration describing phenotype set.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.PhenotypeSetType
 */
export enum PhenotypeSetType {
  /**
   * unspecified phenotype set
   *
   * @generated from protobuf enum value: PHENOTYPE_SET_TYPE_UNSPECIFIED = 0;
   */
  PHENOTYPE_SET_TYPE_UNSPECIFIED = 0,
  /**
   * corresponds to "Disease"
   *
   * @generated from protobuf enum value: PHENOTYPE_SET_TYPE_DISEASE = 1;
   */
  PHENOTYPE_SET_TYPE_DISEASE = 1,
  /**
   * corresponds to "DrugResponse"
   *
   * @generated from protobuf enum value: PHENOTYPE_SET_TYPE_DRUG_RESPONSE = 2;
   */
  PHENOTYPE_SET_TYPE_DRUG_RESPONSE = 2,
  /**
   * corresponds to "Finding"
   *
   * @generated from protobuf enum value: PHENOTYPE_SET_TYPE_FINDING = 3;
   */
  PHENOTYPE_SET_TYPE_FINDING = 3,
  /**
   * corresponds to "PhenotypeInstruction"
   *
   * @generated from protobuf enum value: PHENOTYPE_SET_TYPE_PHENOTYPE_INSTRUCTION = 4;
   */
  PHENOTYPE_SET_TYPE_PHENOTYPE_INSTRUCTION = 4,
  /**
   * corresponds to "TraitChoice"
   *
   * @generated from protobuf enum value: PHENOTYPE_SET_TYPE_TRAIT_CHOICE = 5;
   */
  PHENOTYPE_SET_TYPE_TRAIT_CHOICE = 5
}
/**
 * Enumeration describing variation type.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.VariationType
 */
export enum VariationType {
  /**
   * unspecified variation type
   *
   * @generated from protobuf enum value: VARIATION_TYPE_UNSPECIFIED = 0;
   */
  VARIATION_TYPE_UNSPECIFIED = 0,
  /**
   * corresponds to "Diplotype"
   *
   * @generated from protobuf enum value: VARIATION_TYPE_DIPLOTYPE = 1;
   */
  VARIATION_TYPE_DIPLOTYPE = 1,
  /**
   * corresponds to "CompoundHeterozygote"
   *
   * @generated from protobuf enum value: VARIATION_TYPE_COMPOUND_HETEROZYGOTE = 2;
   */
  VARIATION_TYPE_COMPOUND_HETEROZYGOTE = 2,
  /**
   * corresponds to "Distinct chromosomes"
   *
   * @generated from protobuf enum value: VARIATION_TYPE_DISTINCT_CHROMOSOMES = 3;
   */
  VARIATION_TYPE_DISTINCT_CHROMOSOMES = 3
}
/**
 * Enumeration describing evidence type.
 *
 * Corresponds to "EvidenceType" in XSD.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.EvidenceType
 */
export enum EvidenceType {
  /**
   * unspecified evidence type
   *
   * @generated from protobuf enum value: EVIDENCE_TYPE_UNSPECIFIED = 0;
   */
  EVIDENCE_TYPE_UNSPECIFIED = 0,
  /**
   * corresponds to "Genetic"
   *
   * @generated from protobuf enum value: EVIDENCE_TYPE_GENETIC = 1;
   */
  EVIDENCE_TYPE_GENETIC = 1,
  /**
   * corresponds to "Experimental"
   *
   * @generated from protobuf enum value: EVIDENCE_TYPE_EXPERIMENTAL = 2;
   */
  EVIDENCE_TYPE_EXPERIMENTAL = 2,
  /**
   * corresponds to "Population"
   *
   * @generated from protobuf enum value: EVIDENCE_TYPE_POPULATION = 3;
   */
  EVIDENCE_TYPE_POPULATION = 3,
  /**
   * corresponds to "Computational"
   *
   * @generated from protobuf enum value: EVIDENCE_TYPE_COMPUTATIONAL = 4;
   */
  EVIDENCE_TYPE_COMPUTATIONAL = 4
}
/**
 * Enumeration describing method list.
 *
 * Corresponds to "MethodListType" in XSD.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.MethodListType
 */
export enum MethodListType {
  /**
   * unspecified method
   *
   * @generated from protobuf enum value: METHOD_LIST_TYPE_UNSPECIFIED = 0;
   */
  METHOD_LIST_TYPE_UNSPECIFIED = 0,
  /**
   * corresponds to "literature only"
   *
   * @generated from protobuf enum value: METHOD_LIST_TYPE_LITERATURE_ONLY = 1;
   */
  METHOD_LIST_TYPE_LITERATURE_ONLY = 1,
  /**
   * corresponds to "reference population"
   *
   * @generated from protobuf enum value: METHOD_LIST_TYPE_REFERENCE_POPULATION = 2;
   */
  METHOD_LIST_TYPE_REFERENCE_POPULATION = 2,
  /**
   * corresponds to "case-control"
   *
   * @generated from protobuf enum value: METHOD_LIST_TYPE_CASE_CONTROL = 3;
   */
  METHOD_LIST_TYPE_CASE_CONTROL = 3,
  /**
   * corresponds to "clinical testing"
   *
   * @generated from protobuf enum value: METHOD_LIST_TYPE_CLINICAL_TESTING = 4;
   */
  METHOD_LIST_TYPE_CLINICAL_TESTING = 4,
  /**
   * corresponds to "in vitro"
   *
   * @generated from protobuf enum value: METHOD_LIST_TYPE_IN_VITRO = 5;
   */
  METHOD_LIST_TYPE_IN_VITRO = 5,
  /**
   * corresponds to "in vivo"
   *
   * @generated from protobuf enum value: METHOD_LIST_TYPE_IN_VIVO = 6;
   */
  METHOD_LIST_TYPE_IN_VIVO = 6,
  /**
   * corresponds to "research"
   *
   * @generated from protobuf enum value: METHOD_LIST_TYPE_RESEARCH = 7;
   */
  METHOD_LIST_TYPE_RESEARCH = 7,
  /**
   * corresponds to "curation"
   *
   * @generated from protobuf enum value: METHOD_LIST_TYPE_CURATION = 8;
   */
  METHOD_LIST_TYPE_CURATION = 8,
  /**
   * corresponds to "not provided"
   *
   * @generated from protobuf enum value: METHOD_LIST_TYPE_NOT_PROVIDED = 9;
   */
  METHOD_LIST_TYPE_NOT_PROVIDED = 9,
  /**
   * corresponds to "provider interpretation"
   *
   * @generated from protobuf enum value: METHOD_LIST_TYPE_PROVIDER_INTERPRETATION = 10;
   */
  METHOD_LIST_TYPE_PROVIDER_INTERPRETATION = 10,
  /**
   * corresponds to "phenotyping only"
   *
   * @generated from protobuf enum value: METHOD_LIST_TYPE_PHENOTYPING_ONLY = 11;
   */
  METHOD_LIST_TYPE_PHENOTYPING_ONLY = 11
}
/**
 * Enumeration describing HGVS types.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.HgvsType
 */
export enum HgvsType {
  /**
   * unspecified HGVS type
   *
   * @generated from protobuf enum value: HGVS_TYPE_UNSPECIFIED = 0;
   */
  HGVS_TYPE_UNSPECIFIED = 0,
  /**
   * corresponds to "coding"
   *
   * @generated from protobuf enum value: HGVS_TYPE_CODING = 1;
   */
  HGVS_TYPE_CODING = 1,
  /**
   * corresponds to "genomic"
   *
   * @generated from protobuf enum value: HGVS_TYPE_GENOMIC = 2;
   */
  HGVS_TYPE_GENOMIC = 2,
  /**
   * corresponds to "genomic, top-level"
   *
   * @generated from protobuf enum value: HGVS_TYPE_GENOMIC_TOP_LEVEL = 3;
   */
  HGVS_TYPE_GENOMIC_TOP_LEVEL = 3,
  /**
   * corresponds to "non-coding"
   *
   * @generated from protobuf enum value: HGVS_TYPE_NON_CODING = 4;
   */
  HGVS_TYPE_NON_CODING = 4,
  /**
   * corresponds to "protein"
   *
   * @generated from protobuf enum value: HGVS_TYPE_PROTEIN = 5;
   */
  HGVS_TYPE_PROTEIN = 5
}
/**
 * Enumeration describing clinical features affected status.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.ClinicalFeaturesAffectedStatusType
 */
export enum ClinicalFeaturesAffectedStatusType {
  /**
   * unspecified status
   *
   * @generated from protobuf enum value: CLINICAL_FEATURES_AFFECTED_STATUS_TYPE_UNSPECIFIED = 0;
   */
  CLINICAL_FEATURES_AFFECTED_STATUS_TYPE_UNSPECIFIED = 0,
  /**
   * corresponds to "present"
   *
   * @generated from protobuf enum value: CLINICAL_FEATURES_AFFECTED_STATUS_TYPE_PRESENT = 1;
   */
  CLINICAL_FEATURES_AFFECTED_STATUS_TYPE_PRESENT = 1,
  /**
   * corresponds to "absent"
   *
   * @generated from protobuf enum value: CLINICAL_FEATURES_AFFECTED_STATUS_TYPE_ABSENT = 2;
   */
  CLINICAL_FEATURES_AFFECTED_STATUS_TYPE_ABSENT = 2,
  /**
   * corresponds to "not tested"
   *
   * @generated from protobuf enum value: CLINICAL_FEATURES_AFFECTED_STATUS_TYPE_NOT_TESTED = 3;
   */
  CLINICAL_FEATURES_AFFECTED_STATUS_TYPE_NOT_TESTED = 3
}
/**
 * Enumeration describing haplotype variation types.
 *
 * @generated from protobuf enum annonars.clinvar_data.clinvar_public.HaploVariationType
 */
export enum HaploVariationType {
  /**
   * unspecified haplotype variation type
   *
   * @generated from protobuf enum value: HAPLO_VARIATION_TYPE_UNSPECIFIED = 0;
   */
  HAPLO_VARIATION_TYPE_UNSPECIFIED = 0,
  /**
   * corresponds to "Haplotype"
   *
   * @generated from protobuf enum value: HAPLO_VARIATION_TYPE_HAPLOTYPE = 1;
   */
  HAPLO_VARIATION_TYPE_HAPLOTYPE = 1,
  /**
   * corresponds to "Haplotype, single variant"
   *
   * @generated from protobuf enum value: HAPLO_VARIATION_TYPE_HAPLOTYPE_SINGLE_VARIANT = 2;
   */
  HAPLO_VARIATION_TYPE_HAPLOTYPE_SINGLE_VARIANT = 2,
  /**
   * corresponds to "Variation"
   *
   * @generated from protobuf enum value: HAPLO_VARIATION_TYPE_VARIATION = 3;
   */
  HAPLO_VARIATION_TYPE_VARIATION = 3,
  /**
   * corresponds to "Phase unknown"
   *
   * @generated from protobuf enum value: HAPLO_VARIATION_TYPE_PHASE_UNKNOWN = 4;
   */
  HAPLO_VARIATION_TYPE_PHASE_UNKNOWN = 4,
  /**
   * corresponds to "Haplotype defined by a single variant"
   *
   * @generated from protobuf enum value: HAPLO_VARIATION_TYPE_HAPLOTYPE_DEFINED_BY_SINGLE_VARIANT = 5;
   */
  HAPLO_VARIATION_TYPE_HAPLOTYPE_DEFINED_BY_SINGLE_VARIANT = 5
}
// @generated message type with reflection information, may provide speed optimized methods
class Comment$Type extends MessageType<Comment> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.Comment', [
      { no: 1, name: 'value', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'data_source', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: 'type',
        kind: 'enum',
        opt: true,
        T: () => ['annonars.clinvar_data.clinvar_public.CommentType', CommentType]
      }
    ])
  }
  create(value?: PartialMessage<Comment>): Comment {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.value = ''
    if (value !== undefined) reflectionMergePartial<Comment>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Comment
  ): Comment {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string value */ 1:
          message.value = reader.string()
          break
        case /* optional string data_source */ 2:
          message.dataSource = reader.string()
          break
        case /* optional annonars.clinvar_data.clinvar_public.CommentType type */ 3:
          message.type = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Comment,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string value = 1; */
    if (message.value !== '') writer.tag(1, WireType.LengthDelimited).string(message.value)
    /* optional string data_source = 2; */
    if (message.dataSource !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.dataSource)
    /* optional annonars.clinvar_data.clinvar_public.CommentType type = 3; */
    if (message.type !== undefined) writer.tag(3, WireType.Varint).int32(message.type)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.Comment
 */
export const Comment = new Comment$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Xref$Type extends MessageType<Xref> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.Xref', [
      { no: 1, name: 'db', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'type', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: 'url', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      {
        no: 5,
        name: 'status',
        kind: 'enum',
        opt: true,
        T: () => ['annonars.clinvar_data.clinvar_public.Status', Status]
      }
    ])
  }
  create(value?: PartialMessage<Xref>): Xref {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.db = ''
    message.id = ''
    if (value !== undefined) reflectionMergePartial<Xref>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Xref
  ): Xref {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string db */ 1:
          message.db = reader.string()
          break
        case /* string id */ 2:
          message.id = reader.string()
          break
        case /* optional string type */ 3:
          message.type = reader.string()
          break
        case /* optional string url */ 4:
          message.url = reader.string()
          break
        case /* optional annonars.clinvar_data.clinvar_public.Status status */ 5:
          message.status = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Xref,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string db = 1; */
    if (message.db !== '') writer.tag(1, WireType.LengthDelimited).string(message.db)
    /* string id = 2; */
    if (message.id !== '') writer.tag(2, WireType.LengthDelimited).string(message.id)
    /* optional string type = 3; */
    if (message.type !== undefined) writer.tag(3, WireType.LengthDelimited).string(message.type)
    /* optional string url = 4; */
    if (message.url !== undefined) writer.tag(4, WireType.LengthDelimited).string(message.url)
    /* optional annonars.clinvar_data.clinvar_public.Status status = 5; */
    if (message.status !== undefined) writer.tag(5, WireType.Varint).int32(message.status)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.Xref
 */
export const Xref = new Xref$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Citation$Type extends MessageType<Citation> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.Citation', [
      {
        no: 1,
        name: 'ids',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Citation_IdType
      },
      { no: 2, name: 'url', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'citation_text', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: 'type', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 5, name: 'abbrev', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(value?: PartialMessage<Citation>): Citation {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.ids = []
    if (value !== undefined) reflectionMergePartial<Citation>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Citation
  ): Citation {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated annonars.clinvar_data.clinvar_public.Citation.IdType ids */ 1:
          message.ids.push(Citation_IdType.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* optional string url */ 2:
          message.url = reader.string()
          break
        case /* optional string citation_text */ 3:
          message.citationText = reader.string()
          break
        case /* optional string type */ 4:
          message.type = reader.string()
          break
        case /* optional string abbrev */ 5:
          message.abbrev = reader.string()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Citation,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated annonars.clinvar_data.clinvar_public.Citation.IdType ids = 1; */
    for (let i = 0; i < message.ids.length; i++)
      Citation_IdType.internalBinaryWrite(
        message.ids[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional string url = 2; */
    if (message.url !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.url)
    /* optional string citation_text = 3; */
    if (message.citationText !== undefined)
      writer.tag(3, WireType.LengthDelimited).string(message.citationText)
    /* optional string type = 4; */
    if (message.type !== undefined) writer.tag(4, WireType.LengthDelimited).string(message.type)
    /* optional string abbrev = 5; */
    if (message.abbrev !== undefined) writer.tag(5, WireType.LengthDelimited).string(message.abbrev)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.Citation
 */
export const Citation = new Citation$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Citation_IdType$Type extends MessageType<Citation_IdType> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.Citation.IdType', [
      { no: 1, name: 'value', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'source', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(value?: PartialMessage<Citation_IdType>): Citation_IdType {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.value = ''
    message.source = ''
    if (value !== undefined) reflectionMergePartial<Citation_IdType>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Citation_IdType
  ): Citation_IdType {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string value */ 1:
          message.value = reader.string()
          break
        case /* string source */ 2:
          message.source = reader.string()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Citation_IdType,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string value = 1; */
    if (message.value !== '') writer.tag(1, WireType.LengthDelimited).string(message.value)
    /* string source = 2; */
    if (message.source !== '') writer.tag(2, WireType.LengthDelimited).string(message.source)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.Citation.IdType
 */
export const Citation_IdType = new Citation_IdType$Type()
// @generated message type with reflection information, may provide speed optimized methods
class BaseAttribute$Type extends MessageType<BaseAttribute> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.BaseAttribute', [
      { no: 1, name: 'value', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'integer_value', kind: 'scalar', opt: true, T: 3 /*ScalarType.INT64*/ },
      { no: 3, name: 'date_value', kind: 'message', T: () => Timestamp }
    ])
  }
  create(value?: PartialMessage<BaseAttribute>): BaseAttribute {
    const message = globalThis.Object.create(this.messagePrototype!)
    if (value !== undefined) reflectionMergePartial<BaseAttribute>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BaseAttribute
  ): BaseAttribute {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional string value */ 1:
          message.value = reader.string()
          break
        case /* optional int64 integer_value */ 2:
          message.integerValue = reader.int64().toString()
          break
        case /* optional google.protobuf.Timestamp date_value */ 3:
          message.dateValue = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.dateValue
          )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: BaseAttribute,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional string value = 1; */
    if (message.value !== undefined) writer.tag(1, WireType.LengthDelimited).string(message.value)
    /* optional int64 integer_value = 2; */
    if (message.integerValue !== undefined)
      writer.tag(2, WireType.Varint).int64(message.integerValue)
    /* optional google.protobuf.Timestamp date_value = 3; */
    if (message.dateValue)
      Timestamp.internalBinaryWrite(
        message.dateValue,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.BaseAttribute
 */
export const BaseAttribute = new BaseAttribute$Type()
// @generated message type with reflection information, may provide speed optimized methods
class HgvsNucleotideExpression$Type extends MessageType<HgvsNucleotideExpression> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.HgvsNucleotideExpression', [
      { no: 1, name: 'expression', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: 'sequence_type',
        kind: 'enum',
        opt: true,
        T: () => ['annonars.clinvar_data.clinvar_public.NucleotideSequence', NucleotideSequence]
      },
      {
        no: 3,
        name: 'sequence_accession_version',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/
      },
      { no: 4, name: 'sequence_accession', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 5, name: 'sequence_version', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      { no: 6, name: 'change', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 7, name: 'assembly', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 8, name: 'submitted', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 9, name: 'mane_select', kind: 'scalar', opt: true, T: 8 /*ScalarType.BOOL*/ },
      { no: 10, name: 'mane_plus_clinical', kind: 'scalar', opt: true, T: 8 /*ScalarType.BOOL*/ }
    ])
  }
  create(value?: PartialMessage<HgvsNucleotideExpression>): HgvsNucleotideExpression {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.expression = ''
    if (value !== undefined) reflectionMergePartial<HgvsNucleotideExpression>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: HgvsNucleotideExpression
  ): HgvsNucleotideExpression {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string expression */ 1:
          message.expression = reader.string()
          break
        case /* optional annonars.clinvar_data.clinvar_public.NucleotideSequence sequence_type */ 2:
          message.sequenceType = reader.int32()
          break
        case /* optional string sequence_accession_version */ 3:
          message.sequenceAccessionVersion = reader.string()
          break
        case /* optional string sequence_accession */ 4:
          message.sequenceAccession = reader.string()
          break
        case /* optional int32 sequence_version */ 5:
          message.sequenceVersion = reader.int32()
          break
        case /* optional string change */ 6:
          message.change = reader.string()
          break
        case /* optional string assembly */ 7:
          message.assembly = reader.string()
          break
        case /* optional string submitted */ 8:
          message.submitted = reader.string()
          break
        case /* optional bool mane_select */ 9:
          message.maneSelect = reader.bool()
          break
        case /* optional bool mane_plus_clinical */ 10:
          message.manePlusClinical = reader.bool()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: HgvsNucleotideExpression,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string expression = 1; */
    if (message.expression !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.expression)
    /* optional annonars.clinvar_data.clinvar_public.NucleotideSequence sequence_type = 2; */
    if (message.sequenceType !== undefined)
      writer.tag(2, WireType.Varint).int32(message.sequenceType)
    /* optional string sequence_accession_version = 3; */
    if (message.sequenceAccessionVersion !== undefined)
      writer.tag(3, WireType.LengthDelimited).string(message.sequenceAccessionVersion)
    /* optional string sequence_accession = 4; */
    if (message.sequenceAccession !== undefined)
      writer.tag(4, WireType.LengthDelimited).string(message.sequenceAccession)
    /* optional int32 sequence_version = 5; */
    if (message.sequenceVersion !== undefined)
      writer.tag(5, WireType.Varint).int32(message.sequenceVersion)
    /* optional string change = 6; */
    if (message.change !== undefined) writer.tag(6, WireType.LengthDelimited).string(message.change)
    /* optional string assembly = 7; */
    if (message.assembly !== undefined)
      writer.tag(7, WireType.LengthDelimited).string(message.assembly)
    /* optional string submitted = 8; */
    if (message.submitted !== undefined)
      writer.tag(8, WireType.LengthDelimited).string(message.submitted)
    /* optional bool mane_select = 9; */
    if (message.maneSelect !== undefined) writer.tag(9, WireType.Varint).bool(message.maneSelect)
    /* optional bool mane_plus_clinical = 10; */
    if (message.manePlusClinical !== undefined)
      writer.tag(10, WireType.Varint).bool(message.manePlusClinical)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.HgvsNucleotideExpression
 */
export const HgvsNucleotideExpression = new HgvsNucleotideExpression$Type()
// @generated message type with reflection information, may provide speed optimized methods
class HgvsProteinExpression$Type extends MessageType<HgvsProteinExpression> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.HgvsProteinExpression', [
      { no: 1, name: 'expression', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: 'sequence_accession_version',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/
      },
      { no: 3, name: 'sequence_accession', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: 'sequence_version', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      { no: 5, name: 'change', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(value?: PartialMessage<HgvsProteinExpression>): HgvsProteinExpression {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.expression = ''
    if (value !== undefined) reflectionMergePartial<HgvsProteinExpression>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: HgvsProteinExpression
  ): HgvsProteinExpression {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string expression */ 1:
          message.expression = reader.string()
          break
        case /* optional string sequence_accession_version */ 2:
          message.sequenceAccessionVersion = reader.string()
          break
        case /* optional string sequence_accession */ 3:
          message.sequenceAccession = reader.string()
          break
        case /* optional int32 sequence_version */ 4:
          message.sequenceVersion = reader.int32()
          break
        case /* optional string change */ 5:
          message.change = reader.string()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: HgvsProteinExpression,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string expression = 1; */
    if (message.expression !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.expression)
    /* optional string sequence_accession_version = 2; */
    if (message.sequenceAccessionVersion !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.sequenceAccessionVersion)
    /* optional string sequence_accession = 3; */
    if (message.sequenceAccession !== undefined)
      writer.tag(3, WireType.LengthDelimited).string(message.sequenceAccession)
    /* optional int32 sequence_version = 4; */
    if (message.sequenceVersion !== undefined)
      writer.tag(4, WireType.Varint).int32(message.sequenceVersion)
    /* optional string change = 5; */
    if (message.change !== undefined) writer.tag(5, WireType.LengthDelimited).string(message.change)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.HgvsProteinExpression
 */
export const HgvsProteinExpression = new HgvsProteinExpression$Type()
// @generated message type with reflection information, may provide speed optimized methods
class HgvsExpression$Type extends MessageType<HgvsExpression> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.HgvsExpression', [
      { no: 1, name: 'nucleotide_expression', kind: 'message', T: () => HgvsNucleotideExpression },
      { no: 2, name: 'protein_expression', kind: 'message', T: () => HgvsProteinExpression },
      {
        no: 3,
        name: 'molecular_consequences',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Xref
      },
      {
        no: 4,
        name: 'type',
        kind: 'enum',
        T: () => ['annonars.clinvar_data.clinvar_public.HgvsType', HgvsType]
      },
      { no: 5, name: 'assembly', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(value?: PartialMessage<HgvsExpression>): HgvsExpression {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.molecularConsequences = []
    message.type = 0
    if (value !== undefined) reflectionMergePartial<HgvsExpression>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: HgvsExpression
  ): HgvsExpression {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional annonars.clinvar_data.clinvar_public.HgvsNucleotideExpression nucleotide_expression */ 1:
          message.nucleotideExpression = HgvsNucleotideExpression.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.nucleotideExpression
          )
          break
        case /* optional annonars.clinvar_data.clinvar_public.HgvsProteinExpression protein_expression */ 2:
          message.proteinExpression = HgvsProteinExpression.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.proteinExpression
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Xref molecular_consequences */ 3:
          message.molecularConsequences.push(
            Xref.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* annonars.clinvar_data.clinvar_public.HgvsType type */ 4:
          message.type = reader.int32()
          break
        case /* optional string assembly */ 5:
          message.assembly = reader.string()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: HgvsExpression,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional annonars.clinvar_data.clinvar_public.HgvsNucleotideExpression nucleotide_expression = 1; */
    if (message.nucleotideExpression)
      HgvsNucleotideExpression.internalBinaryWrite(
        message.nucleotideExpression,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.clinvar_data.clinvar_public.HgvsProteinExpression protein_expression = 2; */
    if (message.proteinExpression)
      HgvsProteinExpression.internalBinaryWrite(
        message.proteinExpression,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Xref molecular_consequences = 3; */
    for (let i = 0; i < message.molecularConsequences.length; i++)
      Xref.internalBinaryWrite(
        message.molecularConsequences[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.clinvar_data.clinvar_public.HgvsType type = 4; */
    if (message.type !== 0) writer.tag(4, WireType.Varint).int32(message.type)
    /* optional string assembly = 5; */
    if (message.assembly !== undefined)
      writer.tag(5, WireType.LengthDelimited).string(message.assembly)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.HgvsExpression
 */
export const HgvsExpression = new HgvsExpression$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Software$Type extends MessageType<Software> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.Software', [
      { no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'version', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'purpose', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(value?: PartialMessage<Software>): Software {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.name = ''
    if (value !== undefined) reflectionMergePartial<Software>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Software
  ): Software {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string()
          break
        case /* optional string version */ 2:
          message.version = reader.string()
          break
        case /* optional string purpose */ 3:
          message.purpose = reader.string()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Software,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '') writer.tag(1, WireType.LengthDelimited).string(message.name)
    /* optional string version = 2; */
    if (message.version !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.version)
    /* optional string purpose = 3; */
    if (message.purpose !== undefined)
      writer.tag(3, WireType.LengthDelimited).string(message.purpose)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.Software
 */
export const Software = new Software$Type()
// @generated message type with reflection information, may provide speed optimized methods
class DescriptionHistory$Type extends MessageType<DescriptionHistory> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.DescriptionHistory', [
      { no: 1, name: 'description', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'dated', kind: 'message', T: () => Timestamp }
    ])
  }
  create(value?: PartialMessage<DescriptionHistory>): DescriptionHistory {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.description = ''
    if (value !== undefined) reflectionMergePartial<DescriptionHistory>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DescriptionHistory
  ): DescriptionHistory {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string description */ 1:
          message.description = reader.string()
          break
        case /* optional google.protobuf.Timestamp dated */ 2:
          message.dated = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.dated
          )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: DescriptionHistory,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string description = 1; */
    if (message.description !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.description)
    /* optional google.protobuf.Timestamp dated = 2; */
    if (message.dated)
      Timestamp.internalBinaryWrite(
        message.dated,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.DescriptionHistory
 */
export const DescriptionHistory = new DescriptionHistory$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GenericSetElement$Type extends MessageType<GenericSetElement> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.GenericSetElement', [
      { no: 1, name: 'value', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'type', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: 'citations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Citation
      },
      { no: 4, name: 'xrefs', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Xref },
      {
        no: 5,
        name: 'comments',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Comment
      }
    ])
  }
  create(value?: PartialMessage<GenericSetElement>): GenericSetElement {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.value = ''
    message.type = ''
    message.citations = []
    message.xrefs = []
    message.comments = []
    if (value !== undefined) reflectionMergePartial<GenericSetElement>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GenericSetElement
  ): GenericSetElement {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string value */ 1:
          message.value = reader.string()
          break
        case /* string type */ 2:
          message.type = reader.string()
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Citation citations */ 3:
          message.citations.push(Citation.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs */ 4:
          message.xrefs.push(Xref.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Comment comments */ 5:
          message.comments.push(Comment.internalBinaryRead(reader, reader.uint32(), options))
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: GenericSetElement,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string value = 1; */
    if (message.value !== '') writer.tag(1, WireType.LengthDelimited).string(message.value)
    /* string type = 2; */
    if (message.type !== '') writer.tag(2, WireType.LengthDelimited).string(message.type)
    /* repeated annonars.clinvar_data.clinvar_public.Citation citations = 3; */
    for (let i = 0; i < message.citations.length; i++)
      Citation.internalBinaryWrite(
        message.citations[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 4; */
    for (let i = 0; i < message.xrefs.length; i++)
      Xref.internalBinaryWrite(
        message.xrefs[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Comment comments = 5; */
    for (let i = 0; i < message.comments.length; i++)
      Comment.internalBinaryWrite(
        message.comments[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.GenericSetElement
 */
export const GenericSetElement = new GenericSetElement$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AttributeSetElement$Type extends MessageType<AttributeSetElement> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.AttributeSetElement', [
      { no: 1, name: 'attribute', kind: 'message', T: () => AttributeSetElement_Attribute },
      { no: 2, name: 'xrefs', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Xref },
      {
        no: 3,
        name: 'citations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Citation
      },
      {
        no: 4,
        name: 'comments',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Comment
      }
    ])
  }
  create(value?: PartialMessage<AttributeSetElement>): AttributeSetElement {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.xrefs = []
    message.citations = []
    message.comments = []
    if (value !== undefined) reflectionMergePartial<AttributeSetElement>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AttributeSetElement
  ): AttributeSetElement {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* annonars.clinvar_data.clinvar_public.AttributeSetElement.Attribute attribute */ 1:
          message.attribute = AttributeSetElement_Attribute.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.attribute
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs */ 2:
          message.xrefs.push(Xref.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Citation citations */ 3:
          message.citations.push(Citation.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Comment comments */ 4:
          message.comments.push(Comment.internalBinaryRead(reader, reader.uint32(), options))
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: AttributeSetElement,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* annonars.clinvar_data.clinvar_public.AttributeSetElement.Attribute attribute = 1; */
    if (message.attribute)
      AttributeSetElement_Attribute.internalBinaryWrite(
        message.attribute,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 2; */
    for (let i = 0; i < message.xrefs.length; i++)
      Xref.internalBinaryWrite(
        message.xrefs[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Citation citations = 3; */
    for (let i = 0; i < message.citations.length; i++)
      Citation.internalBinaryWrite(
        message.citations[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Comment comments = 4; */
    for (let i = 0; i < message.comments.length; i++)
      Comment.internalBinaryWrite(
        message.comments[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.AttributeSetElement
 */
export const AttributeSetElement = new AttributeSetElement$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AttributeSetElement_Attribute$Type extends MessageType<AttributeSetElement_Attribute> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.AttributeSetElement.Attribute', [
      { no: 1, name: 'base', kind: 'message', T: () => BaseAttribute },
      { no: 2, name: 'type', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(value?: PartialMessage<AttributeSetElement_Attribute>): AttributeSetElement_Attribute {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.type = ''
    if (value !== undefined)
      reflectionMergePartial<AttributeSetElement_Attribute>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AttributeSetElement_Attribute
  ): AttributeSetElement_Attribute {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* annonars.clinvar_data.clinvar_public.BaseAttribute base */ 1:
          message.base = BaseAttribute.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.base
          )
          break
        case /* string type */ 2:
          message.type = reader.string()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: AttributeSetElement_Attribute,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* annonars.clinvar_data.clinvar_public.BaseAttribute base = 1; */
    if (message.base)
      BaseAttribute.internalBinaryWrite(
        message.base,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* string type = 2; */
    if (message.type !== '') writer.tag(2, WireType.LengthDelimited).string(message.type)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.AttributeSetElement.Attribute
 */
export const AttributeSetElement_Attribute = new AttributeSetElement_Attribute$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Trait$Type extends MessageType<Trait> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.Trait', [
      {
        no: 1,
        name: 'names',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => GenericSetElement
      },
      {
        no: 2,
        name: 'symbols',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => GenericSetElement
      },
      {
        no: 3,
        name: 'attributes',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => AttributeSetElement
      },
      {
        no: 4,
        name: 'trait_relationships',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Trait_TraitRelationship
      },
      {
        no: 5,
        name: 'citations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Citation
      },
      { no: 6, name: 'xrefs', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Xref },
      {
        no: 7,
        name: 'comments',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Comment
      },
      {
        no: 8,
        name: 'sources',
        kind: 'scalar',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/
      }
    ])
  }
  create(value?: PartialMessage<Trait>): Trait {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.names = []
    message.symbols = []
    message.attributes = []
    message.traitRelationships = []
    message.citations = []
    message.xrefs = []
    message.comments = []
    message.sources = []
    if (value !== undefined) reflectionMergePartial<Trait>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Trait
  ): Trait {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated annonars.clinvar_data.clinvar_public.GenericSetElement names */ 1:
          message.names.push(GenericSetElement.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.GenericSetElement symbols */ 2:
          message.symbols.push(
            GenericSetElement.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.AttributeSetElement attributes */ 3:
          message.attributes.push(
            AttributeSetElement.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Trait.TraitRelationship trait_relationships */ 4:
          message.traitRelationships.push(
            Trait_TraitRelationship.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Citation citations */ 5:
          message.citations.push(Citation.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs */ 6:
          message.xrefs.push(Xref.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Comment comments */ 7:
          message.comments.push(Comment.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated string sources */ 8:
          message.sources.push(reader.string())
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Trait,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated annonars.clinvar_data.clinvar_public.GenericSetElement names = 1; */
    for (let i = 0; i < message.names.length; i++)
      GenericSetElement.internalBinaryWrite(
        message.names[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.GenericSetElement symbols = 2; */
    for (let i = 0; i < message.symbols.length; i++)
      GenericSetElement.internalBinaryWrite(
        message.symbols[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.AttributeSetElement attributes = 3; */
    for (let i = 0; i < message.attributes.length; i++)
      AttributeSetElement.internalBinaryWrite(
        message.attributes[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Trait.TraitRelationship trait_relationships = 4; */
    for (let i = 0; i < message.traitRelationships.length; i++)
      Trait_TraitRelationship.internalBinaryWrite(
        message.traitRelationships[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Citation citations = 5; */
    for (let i = 0; i < message.citations.length; i++)
      Citation.internalBinaryWrite(
        message.citations[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 6; */
    for (let i = 0; i < message.xrefs.length; i++)
      Xref.internalBinaryWrite(
        message.xrefs[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Comment comments = 7; */
    for (let i = 0; i < message.comments.length; i++)
      Comment.internalBinaryWrite(
        message.comments[i],
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated string sources = 8; */
    for (let i = 0; i < message.sources.length; i++)
      writer.tag(8, WireType.LengthDelimited).string(message.sources[i])
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.Trait
 */
export const Trait = new Trait$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Trait_TraitRelationship$Type extends MessageType<Trait_TraitRelationship> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.Trait.TraitRelationship', [
      {
        no: 1,
        name: 'names',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => GenericSetElement
      },
      {
        no: 2,
        name: 'citations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Citation
      },
      { no: 3, name: 'xrefs', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Xref },
      {
        no: 4,
        name: 'comments',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Comment
      },
      {
        no: 5,
        name: 'sources',
        kind: 'scalar',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: 'type',
        kind: 'enum',
        T: () => [
          'annonars.clinvar_data.clinvar_public.Trait.TraitRelationship.Type',
          Trait_TraitRelationship_Type
        ]
      }
    ])
  }
  create(value?: PartialMessage<Trait_TraitRelationship>): Trait_TraitRelationship {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.names = []
    message.citations = []
    message.xrefs = []
    message.comments = []
    message.sources = []
    message.type = 0
    if (value !== undefined) reflectionMergePartial<Trait_TraitRelationship>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Trait_TraitRelationship
  ): Trait_TraitRelationship {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated annonars.clinvar_data.clinvar_public.GenericSetElement names */ 1:
          message.names.push(GenericSetElement.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Citation citations */ 2:
          message.citations.push(Citation.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs */ 3:
          message.xrefs.push(Xref.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Comment comments */ 4:
          message.comments.push(Comment.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated string sources */ 5:
          message.sources.push(reader.string())
          break
        case /* annonars.clinvar_data.clinvar_public.Trait.TraitRelationship.Type type */ 6:
          message.type = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Trait_TraitRelationship,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated annonars.clinvar_data.clinvar_public.GenericSetElement names = 1; */
    for (let i = 0; i < message.names.length; i++)
      GenericSetElement.internalBinaryWrite(
        message.names[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Citation citations = 2; */
    for (let i = 0; i < message.citations.length; i++)
      Citation.internalBinaryWrite(
        message.citations[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 3; */
    for (let i = 0; i < message.xrefs.length; i++)
      Xref.internalBinaryWrite(
        message.xrefs[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Comment comments = 4; */
    for (let i = 0; i < message.comments.length; i++)
      Comment.internalBinaryWrite(
        message.comments[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated string sources = 5; */
    for (let i = 0; i < message.sources.length; i++)
      writer.tag(5, WireType.LengthDelimited).string(message.sources[i])
    /* annonars.clinvar_data.clinvar_public.Trait.TraitRelationship.Type type = 6; */
    if (message.type !== 0) writer.tag(6, WireType.Varint).int32(message.type)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.Trait.TraitRelationship
 */
export const Trait_TraitRelationship = new Trait_TraitRelationship$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Indication$Type extends MessageType<Indication> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.Indication', [
      { no: 1, name: 'traits', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Trait },
      {
        no: 2,
        name: 'names',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => GenericSetElement
      },
      {
        no: 3,
        name: 'attributes',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => AttributeSetElement
      },
      { no: 4, name: 'xrefs', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Xref },
      {
        no: 5,
        name: 'citations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Citation
      },
      {
        no: 6,
        name: 'comments',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Comment
      },
      {
        no: 7,
        name: 'type',
        kind: 'enum',
        T: () => ['annonars.clinvar_data.clinvar_public.Indication.Type', Indication_Type]
      }
    ])
  }
  create(value?: PartialMessage<Indication>): Indication {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.traits = []
    message.names = []
    message.attributes = []
    message.xrefs = []
    message.citations = []
    message.comments = []
    message.type = 0
    if (value !== undefined) reflectionMergePartial<Indication>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Indication
  ): Indication {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated annonars.clinvar_data.clinvar_public.Trait traits */ 1:
          message.traits.push(Trait.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.GenericSetElement names */ 2:
          message.names.push(GenericSetElement.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.AttributeSetElement attributes */ 3:
          message.attributes.push(
            AttributeSetElement.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs */ 4:
          message.xrefs.push(Xref.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Citation citations */ 5:
          message.citations.push(Citation.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Comment comments */ 6:
          message.comments.push(Comment.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* annonars.clinvar_data.clinvar_public.Indication.Type type */ 7:
          message.type = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Indication,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated annonars.clinvar_data.clinvar_public.Trait traits = 1; */
    for (let i = 0; i < message.traits.length; i++)
      Trait.internalBinaryWrite(
        message.traits[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.GenericSetElement names = 2; */
    for (let i = 0; i < message.names.length; i++)
      GenericSetElement.internalBinaryWrite(
        message.names[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.AttributeSetElement attributes = 3; */
    for (let i = 0; i < message.attributes.length; i++)
      AttributeSetElement.internalBinaryWrite(
        message.attributes[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 4; */
    for (let i = 0; i < message.xrefs.length; i++)
      Xref.internalBinaryWrite(
        message.xrefs[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Citation citations = 5; */
    for (let i = 0; i < message.citations.length; i++)
      Citation.internalBinaryWrite(
        message.citations[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Comment comments = 6; */
    for (let i = 0; i < message.comments.length; i++)
      Comment.internalBinaryWrite(
        message.comments[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.clinvar_data.clinvar_public.Indication.Type type = 7; */
    if (message.type !== 0) writer.tag(7, WireType.Varint).int32(message.type)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.Indication
 */
export const Indication = new Indication$Type()
// @generated message type with reflection information, may provide speed optimized methods
class TraitSet$Type extends MessageType<TraitSet> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.TraitSet', [
      { no: 1, name: 'traits', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Trait },
      {
        no: 2,
        name: 'names',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => GenericSetElement
      },
      {
        no: 3,
        name: 'symbols',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => GenericSetElement
      },
      {
        no: 4,
        name: 'attributes',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => AttributeSetElement
      },
      { no: 5, name: 'xrefs', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Xref },
      {
        no: 6,
        name: 'citations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Citation
      },
      {
        no: 7,
        name: 'comments',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Comment
      },
      {
        no: 8,
        name: 'type',
        kind: 'enum',
        T: () => ['annonars.clinvar_data.clinvar_public.TraitSet.Type', TraitSet_Type]
      },
      { no: 9, name: 'date_last_evaluated', kind: 'message', T: () => Timestamp },
      { no: 10, name: 'id', kind: 'scalar', opt: true, T: 3 /*ScalarType.INT64*/ },
      {
        no: 11,
        name: 'contributes_to_aggregate_classification',
        kind: 'scalar',
        opt: true,
        T: 8 /*ScalarType.BOOL*/
      },
      {
        no: 12,
        name: 'lower_level_of_evidence',
        kind: 'scalar',
        opt: true,
        T: 8 /*ScalarType.BOOL*/
      },
      {
        no: 13,
        name: 'multiple_condition_explanation',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/
      }
    ])
  }
  create(value?: PartialMessage<TraitSet>): TraitSet {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.traits = []
    message.names = []
    message.symbols = []
    message.attributes = []
    message.xrefs = []
    message.citations = []
    message.comments = []
    message.type = 0
    if (value !== undefined) reflectionMergePartial<TraitSet>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: TraitSet
  ): TraitSet {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated annonars.clinvar_data.clinvar_public.Trait traits */ 1:
          message.traits.push(Trait.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.GenericSetElement names */ 2:
          message.names.push(GenericSetElement.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.GenericSetElement symbols */ 3:
          message.symbols.push(
            GenericSetElement.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.AttributeSetElement attributes */ 4:
          message.attributes.push(
            AttributeSetElement.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs */ 5:
          message.xrefs.push(Xref.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Citation citations */ 6:
          message.citations.push(Citation.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Comment comments */ 7:
          message.comments.push(Comment.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* annonars.clinvar_data.clinvar_public.TraitSet.Type type */ 8:
          message.type = reader.int32()
          break
        case /* optional google.protobuf.Timestamp date_last_evaluated */ 9:
          message.dateLastEvaluated = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.dateLastEvaluated
          )
          break
        case /* optional int64 id */ 10:
          message.id = reader.int64().toString()
          break
        case /* optional bool contributes_to_aggregate_classification */ 11:
          message.contributesToAggregateClassification = reader.bool()
          break
        case /* optional bool lower_level_of_evidence */ 12:
          message.lowerLevelOfEvidence = reader.bool()
          break
        case /* optional string multiple_condition_explanation */ 13:
          message.multipleConditionExplanation = reader.string()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: TraitSet,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated annonars.clinvar_data.clinvar_public.Trait traits = 1; */
    for (let i = 0; i < message.traits.length; i++)
      Trait.internalBinaryWrite(
        message.traits[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.GenericSetElement names = 2; */
    for (let i = 0; i < message.names.length; i++)
      GenericSetElement.internalBinaryWrite(
        message.names[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.GenericSetElement symbols = 3; */
    for (let i = 0; i < message.symbols.length; i++)
      GenericSetElement.internalBinaryWrite(
        message.symbols[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.AttributeSetElement attributes = 4; */
    for (let i = 0; i < message.attributes.length; i++)
      AttributeSetElement.internalBinaryWrite(
        message.attributes[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 5; */
    for (let i = 0; i < message.xrefs.length; i++)
      Xref.internalBinaryWrite(
        message.xrefs[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Citation citations = 6; */
    for (let i = 0; i < message.citations.length; i++)
      Citation.internalBinaryWrite(
        message.citations[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Comment comments = 7; */
    for (let i = 0; i < message.comments.length; i++)
      Comment.internalBinaryWrite(
        message.comments[i],
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.clinvar_data.clinvar_public.TraitSet.Type type = 8; */
    if (message.type !== 0) writer.tag(8, WireType.Varint).int32(message.type)
    /* optional google.protobuf.Timestamp date_last_evaluated = 9; */
    if (message.dateLastEvaluated)
      Timestamp.internalBinaryWrite(
        message.dateLastEvaluated,
        writer.tag(9, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional int64 id = 10; */
    if (message.id !== undefined) writer.tag(10, WireType.Varint).int64(message.id)
    /* optional bool contributes_to_aggregate_classification = 11; */
    if (message.contributesToAggregateClassification !== undefined)
      writer.tag(11, WireType.Varint).bool(message.contributesToAggregateClassification)
    /* optional bool lower_level_of_evidence = 12; */
    if (message.lowerLevelOfEvidence !== undefined)
      writer.tag(12, WireType.Varint).bool(message.lowerLevelOfEvidence)
    /* optional string multiple_condition_explanation = 13; */
    if (message.multipleConditionExplanation !== undefined)
      writer.tag(13, WireType.LengthDelimited).string(message.multipleConditionExplanation)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.TraitSet
 */
export const TraitSet = new TraitSet$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AggregatedGermlineClassification$Type extends MessageType<AggregatedGermlineClassification> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.AggregatedGermlineClassification', [
      {
        no: 1,
        name: 'review_status',
        kind: 'enum',
        T: () => [
          'annonars.clinvar_data.clinvar_public.AggregateGermlineReviewStatus',
          AggregateGermlineReviewStatus
        ]
      },
      { no: 2, name: 'description', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'explanation', kind: 'message', T: () => Comment },
      { no: 4, name: 'xrefs', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Xref },
      {
        no: 5,
        name: 'citations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Citation
      },
      {
        no: 6,
        name: 'comments',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Comment
      },
      {
        no: 7,
        name: 'history_records',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => DescriptionHistory
      },
      {
        no: 8,
        name: 'conditions',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => TraitSet
      },
      { no: 9, name: 'date_last_evaluated', kind: 'message', T: () => Timestamp },
      { no: 10, name: 'date_created', kind: 'message', T: () => Timestamp },
      { no: 11, name: 'most_recent_submission', kind: 'message', T: () => Timestamp },
      {
        no: 12,
        name: 'number_of_submitters',
        kind: 'scalar',
        opt: true,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 13,
        name: 'number_of_submissions',
        kind: 'scalar',
        opt: true,
        T: 5 /*ScalarType.INT32*/
      }
    ])
  }
  create(
    value?: PartialMessage<AggregatedGermlineClassification>
  ): AggregatedGermlineClassification {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.reviewStatus = 0
    message.xrefs = []
    message.citations = []
    message.comments = []
    message.historyRecords = []
    message.conditions = []
    if (value !== undefined)
      reflectionMergePartial<AggregatedGermlineClassification>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AggregatedGermlineClassification
  ): AggregatedGermlineClassification {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* annonars.clinvar_data.clinvar_public.AggregateGermlineReviewStatus review_status */ 1:
          message.reviewStatus = reader.int32()
          break
        case /* optional string description */ 2:
          message.description = reader.string()
          break
        case /* optional annonars.clinvar_data.clinvar_public.Comment explanation */ 3:
          message.explanation = Comment.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.explanation
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs */ 4:
          message.xrefs.push(Xref.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Citation citations */ 5:
          message.citations.push(Citation.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Comment comments */ 6:
          message.comments.push(Comment.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.DescriptionHistory history_records */ 7:
          message.historyRecords.push(
            DescriptionHistory.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.TraitSet conditions */ 8:
          message.conditions.push(TraitSet.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* optional google.protobuf.Timestamp date_last_evaluated */ 9:
          message.dateLastEvaluated = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.dateLastEvaluated
          )
          break
        case /* google.protobuf.Timestamp date_created */ 10:
          message.dateCreated = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.dateCreated
          )
          break
        case /* google.protobuf.Timestamp most_recent_submission */ 11:
          message.mostRecentSubmission = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.mostRecentSubmission
          )
          break
        case /* optional int32 number_of_submitters */ 12:
          message.numberOfSubmitters = reader.int32()
          break
        case /* optional int32 number_of_submissions */ 13:
          message.numberOfSubmissions = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: AggregatedGermlineClassification,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* annonars.clinvar_data.clinvar_public.AggregateGermlineReviewStatus review_status = 1; */
    if (message.reviewStatus !== 0) writer.tag(1, WireType.Varint).int32(message.reviewStatus)
    /* optional string description = 2; */
    if (message.description !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.description)
    /* optional annonars.clinvar_data.clinvar_public.Comment explanation = 3; */
    if (message.explanation)
      Comment.internalBinaryWrite(
        message.explanation,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 4; */
    for (let i = 0; i < message.xrefs.length; i++)
      Xref.internalBinaryWrite(
        message.xrefs[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Citation citations = 5; */
    for (let i = 0; i < message.citations.length; i++)
      Citation.internalBinaryWrite(
        message.citations[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Comment comments = 6; */
    for (let i = 0; i < message.comments.length; i++)
      Comment.internalBinaryWrite(
        message.comments[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.DescriptionHistory history_records = 7; */
    for (let i = 0; i < message.historyRecords.length; i++)
      DescriptionHistory.internalBinaryWrite(
        message.historyRecords[i],
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.TraitSet conditions = 8; */
    for (let i = 0; i < message.conditions.length; i++)
      TraitSet.internalBinaryWrite(
        message.conditions[i],
        writer.tag(8, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional google.protobuf.Timestamp date_last_evaluated = 9; */
    if (message.dateLastEvaluated)
      Timestamp.internalBinaryWrite(
        message.dateLastEvaluated,
        writer.tag(9, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* google.protobuf.Timestamp date_created = 10; */
    if (message.dateCreated)
      Timestamp.internalBinaryWrite(
        message.dateCreated,
        writer.tag(10, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* google.protobuf.Timestamp most_recent_submission = 11; */
    if (message.mostRecentSubmission)
      Timestamp.internalBinaryWrite(
        message.mostRecentSubmission,
        writer.tag(11, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional int32 number_of_submitters = 12; */
    if (message.numberOfSubmitters !== undefined)
      writer.tag(12, WireType.Varint).int32(message.numberOfSubmitters)
    /* optional int32 number_of_submissions = 13; */
    if (message.numberOfSubmissions !== undefined)
      writer.tag(13, WireType.Varint).int32(message.numberOfSubmissions)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.AggregatedGermlineClassification
 */
export const AggregatedGermlineClassification = new AggregatedGermlineClassification$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AggregatedSomaticClinicalImpact$Type extends MessageType<AggregatedSomaticClinicalImpact> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.AggregatedSomaticClinicalImpact', [
      {
        no: 1,
        name: 'review_status',
        kind: 'enum',
        T: () => [
          'annonars.clinvar_data.clinvar_public.AggregateSomaticClinicalImpactReviewStatus',
          AggregateSomaticClinicalImpactReviewStatus
        ]
      },
      { no: 2, name: 'description', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'xrefs', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Xref },
      {
        no: 4,
        name: 'citations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Citation
      },
      {
        no: 5,
        name: 'comments',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Comment
      },
      {
        no: 6,
        name: 'history_records',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => DescriptionHistory
      },
      {
        no: 7,
        name: 'conditions',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => TraitSet
      },
      { no: 8, name: 'date_last_evaluated', kind: 'message', T: () => Timestamp },
      { no: 9, name: 'date_created', kind: 'message', T: () => Timestamp },
      { no: 10, name: 'most_recent_submission', kind: 'message', T: () => Timestamp },
      {
        no: 11,
        name: 'number_of_submitters',
        kind: 'scalar',
        opt: true,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 12,
        name: 'number_of_submissions',
        kind: 'scalar',
        opt: true,
        T: 5 /*ScalarType.INT32*/
      }
    ])
  }
  create(value?: PartialMessage<AggregatedSomaticClinicalImpact>): AggregatedSomaticClinicalImpact {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.reviewStatus = 0
    message.xrefs = []
    message.citations = []
    message.comments = []
    message.historyRecords = []
    message.conditions = []
    if (value !== undefined)
      reflectionMergePartial<AggregatedSomaticClinicalImpact>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AggregatedSomaticClinicalImpact
  ): AggregatedSomaticClinicalImpact {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* annonars.clinvar_data.clinvar_public.AggregateSomaticClinicalImpactReviewStatus review_status */ 1:
          message.reviewStatus = reader.int32()
          break
        case /* optional string description */ 2:
          message.description = reader.string()
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs */ 3:
          message.xrefs.push(Xref.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Citation citations */ 4:
          message.citations.push(Citation.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Comment comments */ 5:
          message.comments.push(Comment.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.DescriptionHistory history_records */ 6:
          message.historyRecords.push(
            DescriptionHistory.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.TraitSet conditions */ 7:
          message.conditions.push(TraitSet.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* optional google.protobuf.Timestamp date_last_evaluated */ 8:
          message.dateLastEvaluated = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.dateLastEvaluated
          )
          break
        case /* google.protobuf.Timestamp date_created */ 9:
          message.dateCreated = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.dateCreated
          )
          break
        case /* google.protobuf.Timestamp most_recent_submission */ 10:
          message.mostRecentSubmission = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.mostRecentSubmission
          )
          break
        case /* optional int32 number_of_submitters */ 11:
          message.numberOfSubmitters = reader.int32()
          break
        case /* optional int32 number_of_submissions */ 12:
          message.numberOfSubmissions = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: AggregatedSomaticClinicalImpact,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* annonars.clinvar_data.clinvar_public.AggregateSomaticClinicalImpactReviewStatus review_status = 1; */
    if (message.reviewStatus !== 0) writer.tag(1, WireType.Varint).int32(message.reviewStatus)
    /* optional string description = 2; */
    if (message.description !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.description)
    /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 3; */
    for (let i = 0; i < message.xrefs.length; i++)
      Xref.internalBinaryWrite(
        message.xrefs[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Citation citations = 4; */
    for (let i = 0; i < message.citations.length; i++)
      Citation.internalBinaryWrite(
        message.citations[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Comment comments = 5; */
    for (let i = 0; i < message.comments.length; i++)
      Comment.internalBinaryWrite(
        message.comments[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.DescriptionHistory history_records = 6; */
    for (let i = 0; i < message.historyRecords.length; i++)
      DescriptionHistory.internalBinaryWrite(
        message.historyRecords[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.TraitSet conditions = 7; */
    for (let i = 0; i < message.conditions.length; i++)
      TraitSet.internalBinaryWrite(
        message.conditions[i],
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional google.protobuf.Timestamp date_last_evaluated = 8; */
    if (message.dateLastEvaluated)
      Timestamp.internalBinaryWrite(
        message.dateLastEvaluated,
        writer.tag(8, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* google.protobuf.Timestamp date_created = 9; */
    if (message.dateCreated)
      Timestamp.internalBinaryWrite(
        message.dateCreated,
        writer.tag(9, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* google.protobuf.Timestamp most_recent_submission = 10; */
    if (message.mostRecentSubmission)
      Timestamp.internalBinaryWrite(
        message.mostRecentSubmission,
        writer.tag(10, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional int32 number_of_submitters = 11; */
    if (message.numberOfSubmitters !== undefined)
      writer.tag(11, WireType.Varint).int32(message.numberOfSubmitters)
    /* optional int32 number_of_submissions = 12; */
    if (message.numberOfSubmissions !== undefined)
      writer.tag(12, WireType.Varint).int32(message.numberOfSubmissions)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.AggregatedSomaticClinicalImpact
 */
export const AggregatedSomaticClinicalImpact = new AggregatedSomaticClinicalImpact$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AggregatedOncogenicityClassification$Type extends MessageType<AggregatedOncogenicityClassification> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.AggregatedOncogenicityClassification', [
      {
        no: 1,
        name: 'review_status',
        kind: 'enum',
        T: () => [
          'annonars.clinvar_data.clinvar_public.AggregateOncogenicityReviewStatus',
          AggregateOncogenicityReviewStatus
        ]
      },
      { no: 2, name: 'description', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'xrefs', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Xref },
      {
        no: 4,
        name: 'citations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Citation
      },
      {
        no: 5,
        name: 'comments',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Comment
      },
      {
        no: 6,
        name: 'history_records',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => DescriptionHistory
      },
      {
        no: 7,
        name: 'conditions',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => TraitSet
      },
      { no: 8, name: 'date_last_evaluated', kind: 'message', T: () => Timestamp },
      { no: 9, name: 'date_created', kind: 'message', T: () => Timestamp },
      { no: 10, name: 'most_recent_submission', kind: 'message', T: () => Timestamp },
      {
        no: 11,
        name: 'number_of_submitters',
        kind: 'scalar',
        opt: true,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 12,
        name: 'number_of_submissions',
        kind: 'scalar',
        opt: true,
        T: 5 /*ScalarType.INT32*/
      }
    ])
  }
  create(
    value?: PartialMessage<AggregatedOncogenicityClassification>
  ): AggregatedOncogenicityClassification {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.reviewStatus = 0
    message.xrefs = []
    message.citations = []
    message.comments = []
    message.historyRecords = []
    message.conditions = []
    if (value !== undefined)
      reflectionMergePartial<AggregatedOncogenicityClassification>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AggregatedOncogenicityClassification
  ): AggregatedOncogenicityClassification {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* annonars.clinvar_data.clinvar_public.AggregateOncogenicityReviewStatus review_status */ 1:
          message.reviewStatus = reader.int32()
          break
        case /* optional string description */ 2:
          message.description = reader.string()
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs */ 3:
          message.xrefs.push(Xref.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Citation citations */ 4:
          message.citations.push(Citation.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Comment comments */ 5:
          message.comments.push(Comment.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.DescriptionHistory history_records */ 6:
          message.historyRecords.push(
            DescriptionHistory.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.TraitSet conditions */ 7:
          message.conditions.push(TraitSet.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* optional google.protobuf.Timestamp date_last_evaluated */ 8:
          message.dateLastEvaluated = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.dateLastEvaluated
          )
          break
        case /* google.protobuf.Timestamp date_created */ 9:
          message.dateCreated = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.dateCreated
          )
          break
        case /* google.protobuf.Timestamp most_recent_submission */ 10:
          message.mostRecentSubmission = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.mostRecentSubmission
          )
          break
        case /* optional int32 number_of_submitters */ 11:
          message.numberOfSubmitters = reader.int32()
          break
        case /* optional int32 number_of_submissions */ 12:
          message.numberOfSubmissions = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: AggregatedOncogenicityClassification,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* annonars.clinvar_data.clinvar_public.AggregateOncogenicityReviewStatus review_status = 1; */
    if (message.reviewStatus !== 0) writer.tag(1, WireType.Varint).int32(message.reviewStatus)
    /* optional string description = 2; */
    if (message.description !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.description)
    /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 3; */
    for (let i = 0; i < message.xrefs.length; i++)
      Xref.internalBinaryWrite(
        message.xrefs[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Citation citations = 4; */
    for (let i = 0; i < message.citations.length; i++)
      Citation.internalBinaryWrite(
        message.citations[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Comment comments = 5; */
    for (let i = 0; i < message.comments.length; i++)
      Comment.internalBinaryWrite(
        message.comments[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.DescriptionHistory history_records = 6; */
    for (let i = 0; i < message.historyRecords.length; i++)
      DescriptionHistory.internalBinaryWrite(
        message.historyRecords[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.TraitSet conditions = 7; */
    for (let i = 0; i < message.conditions.length; i++)
      TraitSet.internalBinaryWrite(
        message.conditions[i],
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional google.protobuf.Timestamp date_last_evaluated = 8; */
    if (message.dateLastEvaluated)
      Timestamp.internalBinaryWrite(
        message.dateLastEvaluated,
        writer.tag(8, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* google.protobuf.Timestamp date_created = 9; */
    if (message.dateCreated)
      Timestamp.internalBinaryWrite(
        message.dateCreated,
        writer.tag(9, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* google.protobuf.Timestamp most_recent_submission = 10; */
    if (message.mostRecentSubmission)
      Timestamp.internalBinaryWrite(
        message.mostRecentSubmission,
        writer.tag(10, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional int32 number_of_submitters = 11; */
    if (message.numberOfSubmitters !== undefined)
      writer.tag(11, WireType.Varint).int32(message.numberOfSubmitters)
    /* optional int32 number_of_submissions = 12; */
    if (message.numberOfSubmissions !== undefined)
      writer.tag(12, WireType.Varint).int32(message.numberOfSubmissions)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.AggregatedOncogenicityClassification
 */
export const AggregatedOncogenicityClassification = new AggregatedOncogenicityClassification$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AggregateClassificationSet$Type extends MessageType<AggregateClassificationSet> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.AggregateClassificationSet', [
      {
        no: 1,
        name: 'germline_classification',
        kind: 'message',
        T: () => AggregatedGermlineClassification
      },
      {
        no: 2,
        name: 'somatic_clinical_impact',
        kind: 'message',
        T: () => AggregatedSomaticClinicalImpact
      },
      {
        no: 3,
        name: 'oncogenicity_classification',
        kind: 'message',
        T: () => AggregatedOncogenicityClassification
      }
    ])
  }
  create(value?: PartialMessage<AggregateClassificationSet>): AggregateClassificationSet {
    const message = globalThis.Object.create(this.messagePrototype!)
    if (value !== undefined)
      reflectionMergePartial<AggregateClassificationSet>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AggregateClassificationSet
  ): AggregateClassificationSet {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional annonars.clinvar_data.clinvar_public.AggregatedGermlineClassification germline_classification */ 1:
          message.germlineClassification = AggregatedGermlineClassification.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.germlineClassification
          )
          break
        case /* optional annonars.clinvar_data.clinvar_public.AggregatedSomaticClinicalImpact somatic_clinical_impact */ 2:
          message.somaticClinicalImpact = AggregatedSomaticClinicalImpact.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.somaticClinicalImpact
          )
          break
        case /* optional annonars.clinvar_data.clinvar_public.AggregatedOncogenicityClassification oncogenicity_classification */ 3:
          message.oncogenicityClassification =
            AggregatedOncogenicityClassification.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.oncogenicityClassification
            )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: AggregateClassificationSet,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional annonars.clinvar_data.clinvar_public.AggregatedGermlineClassification germline_classification = 1; */
    if (message.germlineClassification)
      AggregatedGermlineClassification.internalBinaryWrite(
        message.germlineClassification,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.clinvar_data.clinvar_public.AggregatedSomaticClinicalImpact somatic_clinical_impact = 2; */
    if (message.somaticClinicalImpact)
      AggregatedSomaticClinicalImpact.internalBinaryWrite(
        message.somaticClinicalImpact,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.clinvar_data.clinvar_public.AggregatedOncogenicityClassification oncogenicity_classification = 3; */
    if (message.oncogenicityClassification)
      AggregatedOncogenicityClassification.internalBinaryWrite(
        message.oncogenicityClassification,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.AggregateClassificationSet
 */
export const AggregateClassificationSet = new AggregateClassificationSet$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ClinicalSignificance$Type extends MessageType<ClinicalSignificance> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.ClinicalSignificance', [
      {
        no: 1,
        name: 'review_status',
        kind: 'enum',
        opt: true,
        T: () => [
          'annonars.clinvar_data.clinvar_public.SubmitterReviewStatus',
          SubmitterReviewStatus
        ]
      },
      { no: 2, name: 'description', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'explanation', kind: 'message', T: () => Comment },
      { no: 4, name: 'xrefs', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Xref },
      {
        no: 5,
        name: 'citations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Citation
      },
      {
        no: 6,
        name: 'comments',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Comment
      },
      { no: 7, name: 'date_last_evaluated', kind: 'message', T: () => Timestamp }
    ])
  }
  create(value?: PartialMessage<ClinicalSignificance>): ClinicalSignificance {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.xrefs = []
    message.citations = []
    message.comments = []
    if (value !== undefined) reflectionMergePartial<ClinicalSignificance>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ClinicalSignificance
  ): ClinicalSignificance {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional annonars.clinvar_data.clinvar_public.SubmitterReviewStatus review_status */ 1:
          message.reviewStatus = reader.int32()
          break
        case /* optional string description */ 2:
          message.description = reader.string()
          break
        case /* optional annonars.clinvar_data.clinvar_public.Comment explanation */ 3:
          message.explanation = Comment.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.explanation
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs */ 4:
          message.xrefs.push(Xref.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Citation citations */ 5:
          message.citations.push(Citation.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Comment comments */ 6:
          message.comments.push(Comment.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* optional google.protobuf.Timestamp date_last_evaluated */ 7:
          message.dateLastEvaluated = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.dateLastEvaluated
          )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ClinicalSignificance,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional annonars.clinvar_data.clinvar_public.SubmitterReviewStatus review_status = 1; */
    if (message.reviewStatus !== undefined)
      writer.tag(1, WireType.Varint).int32(message.reviewStatus)
    /* optional string description = 2; */
    if (message.description !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.description)
    /* optional annonars.clinvar_data.clinvar_public.Comment explanation = 3; */
    if (message.explanation)
      Comment.internalBinaryWrite(
        message.explanation,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 4; */
    for (let i = 0; i < message.xrefs.length; i++)
      Xref.internalBinaryWrite(
        message.xrefs[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Citation citations = 5; */
    for (let i = 0; i < message.citations.length; i++)
      Citation.internalBinaryWrite(
        message.citations[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Comment comments = 6; */
    for (let i = 0; i < message.comments.length; i++)
      Comment.internalBinaryWrite(
        message.comments[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional google.protobuf.Timestamp date_last_evaluated = 7; */
    if (message.dateLastEvaluated)
      Timestamp.internalBinaryWrite(
        message.dateLastEvaluated,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.ClinicalSignificance
 */
export const ClinicalSignificance = new ClinicalSignificance$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AlleleDescription$Type extends MessageType<AlleleDescription> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.AlleleDescription', [
      { no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: 'relative_orientation',
        kind: 'enum',
        opt: true,
        T: () => [
          'annonars.clinvar_data.clinvar_public.AlleleDescription.RelativeOrientation',
          AlleleDescription_RelativeOrientation
        ]
      },
      {
        no: 3,
        name: 'zygosity',
        kind: 'enum',
        opt: true,
        T: () => ['annonars.clinvar_data.clinvar_public.Zygosity', Zygosity]
      },
      { no: 4, name: 'clinical_significance', kind: 'message', T: () => ClinicalSignificance }
    ])
  }
  create(value?: PartialMessage<AlleleDescription>): AlleleDescription {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.name = ''
    if (value !== undefined) reflectionMergePartial<AlleleDescription>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AlleleDescription
  ): AlleleDescription {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string()
          break
        case /* optional annonars.clinvar_data.clinvar_public.AlleleDescription.RelativeOrientation relative_orientation */ 2:
          message.relativeOrientation = reader.int32()
          break
        case /* optional annonars.clinvar_data.clinvar_public.Zygosity zygosity */ 3:
          message.zygosity = reader.int32()
          break
        case /* optional annonars.clinvar_data.clinvar_public.ClinicalSignificance clinical_significance */ 4:
          message.clinicalSignificance = ClinicalSignificance.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.clinicalSignificance
          )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: AlleleDescription,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '') writer.tag(1, WireType.LengthDelimited).string(message.name)
    /* optional annonars.clinvar_data.clinvar_public.AlleleDescription.RelativeOrientation relative_orientation = 2; */
    if (message.relativeOrientation !== undefined)
      writer.tag(2, WireType.Varint).int32(message.relativeOrientation)
    /* optional annonars.clinvar_data.clinvar_public.Zygosity zygosity = 3; */
    if (message.zygosity !== undefined) writer.tag(3, WireType.Varint).int32(message.zygosity)
    /* optional annonars.clinvar_data.clinvar_public.ClinicalSignificance clinical_significance = 4; */
    if (message.clinicalSignificance)
      ClinicalSignificance.internalBinaryWrite(
        message.clinicalSignificance,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.AlleleDescription
 */
export const AlleleDescription = new AlleleDescription$Type()
// @generated message type with reflection information, may provide speed optimized methods
class RecordHistory$Type extends MessageType<RecordHistory> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.RecordHistory', [
      { no: 1, name: 'comment', kind: 'message', T: () => Comment },
      { no: 2, name: 'accession', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'version', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 4, name: 'date_changed', kind: 'message', T: () => Timestamp },
      { no: 5, name: 'variation_id', kind: 'scalar', opt: true, T: 3 /*ScalarType.INT64*/ }
    ])
  }
  create(value?: PartialMessage<RecordHistory>): RecordHistory {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.accession = ''
    message.version = 0
    if (value !== undefined) reflectionMergePartial<RecordHistory>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RecordHistory
  ): RecordHistory {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional annonars.clinvar_data.clinvar_public.Comment comment */ 1:
          message.comment = Comment.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.comment
          )
          break
        case /* string accession */ 2:
          message.accession = reader.string()
          break
        case /* int32 version */ 3:
          message.version = reader.int32()
          break
        case /* google.protobuf.Timestamp date_changed */ 4:
          message.dateChanged = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.dateChanged
          )
          break
        case /* optional int64 variation_id */ 5:
          message.variationId = reader.int64().toString()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: RecordHistory,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional annonars.clinvar_data.clinvar_public.Comment comment = 1; */
    if (message.comment)
      Comment.internalBinaryWrite(
        message.comment,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* string accession = 2; */
    if (message.accession !== '') writer.tag(2, WireType.LengthDelimited).string(message.accession)
    /* int32 version = 3; */
    if (message.version !== 0) writer.tag(3, WireType.Varint).int32(message.version)
    /* google.protobuf.Timestamp date_changed = 4; */
    if (message.dateChanged)
      Timestamp.internalBinaryWrite(
        message.dateChanged,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional int64 variation_id = 5; */
    if (message.variationId !== undefined) writer.tag(5, WireType.Varint).int64(message.variationId)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.RecordHistory
 */
export const RecordHistory = new RecordHistory$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ClassificationScv$Type extends MessageType<ClassificationScv> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.ClassificationScv', [
      {
        no: 1,
        name: 'review_status',
        kind: 'enum',
        T: () => [
          'annonars.clinvar_data.clinvar_public.SubmitterReviewStatus',
          SubmitterReviewStatus
        ]
      },
      {
        no: 2,
        name: 'germline_classification',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: 'somatic_clinical_impact',
        kind: 'message',
        T: () => ClassificationScv_SomaticClinicalImpact
      },
      {
        no: 4,
        name: 'oncogenicity_classification',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: 'explanation_of_classification',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: 'classification_scores',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => ClassificationScv_ClassificationScore
      },
      { no: 7, name: 'xrefs', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Xref },
      {
        no: 8,
        name: 'citations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Citation
      },
      {
        no: 9,
        name: 'comments',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Comment
      },
      { no: 10, name: 'date_last_evaluated', kind: 'message', T: () => Timestamp }
    ])
  }
  create(value?: PartialMessage<ClassificationScv>): ClassificationScv {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.reviewStatus = 0
    message.classificationScores = []
    message.xrefs = []
    message.citations = []
    message.comments = []
    if (value !== undefined) reflectionMergePartial<ClassificationScv>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ClassificationScv
  ): ClassificationScv {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* annonars.clinvar_data.clinvar_public.SubmitterReviewStatus review_status */ 1:
          message.reviewStatus = reader.int32()
          break
        case /* optional string germline_classification */ 2:
          message.germlineClassification = reader.string()
          break
        case /* optional annonars.clinvar_data.clinvar_public.ClassificationScv.SomaticClinicalImpact somatic_clinical_impact */ 3:
          message.somaticClinicalImpact =
            ClassificationScv_SomaticClinicalImpact.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.somaticClinicalImpact
            )
          break
        case /* optional string oncogenicity_classification */ 4:
          message.oncogenicityClassification = reader.string()
          break
        case /* optional string explanation_of_classification */ 5:
          message.explanationOfClassification = reader.string()
          break
        case /* repeated annonars.clinvar_data.clinvar_public.ClassificationScv.ClassificationScore classification_scores */ 6:
          message.classificationScores.push(
            ClassificationScv_ClassificationScore.internalBinaryRead(
              reader,
              reader.uint32(),
              options
            )
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs */ 7:
          message.xrefs.push(Xref.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Citation citations */ 8:
          message.citations.push(Citation.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Comment comments */ 9:
          message.comments.push(Comment.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* optional google.protobuf.Timestamp date_last_evaluated */ 10:
          message.dateLastEvaluated = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.dateLastEvaluated
          )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ClassificationScv,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* annonars.clinvar_data.clinvar_public.SubmitterReviewStatus review_status = 1; */
    if (message.reviewStatus !== 0) writer.tag(1, WireType.Varint).int32(message.reviewStatus)
    /* optional string germline_classification = 2; */
    if (message.germlineClassification !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.germlineClassification)
    /* optional annonars.clinvar_data.clinvar_public.ClassificationScv.SomaticClinicalImpact somatic_clinical_impact = 3; */
    if (message.somaticClinicalImpact)
      ClassificationScv_SomaticClinicalImpact.internalBinaryWrite(
        message.somaticClinicalImpact,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional string oncogenicity_classification = 4; */
    if (message.oncogenicityClassification !== undefined)
      writer.tag(4, WireType.LengthDelimited).string(message.oncogenicityClassification)
    /* optional string explanation_of_classification = 5; */
    if (message.explanationOfClassification !== undefined)
      writer.tag(5, WireType.LengthDelimited).string(message.explanationOfClassification)
    /* repeated annonars.clinvar_data.clinvar_public.ClassificationScv.ClassificationScore classification_scores = 6; */
    for (let i = 0; i < message.classificationScores.length; i++)
      ClassificationScv_ClassificationScore.internalBinaryWrite(
        message.classificationScores[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 7; */
    for (let i = 0; i < message.xrefs.length; i++)
      Xref.internalBinaryWrite(
        message.xrefs[i],
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Citation citations = 8; */
    for (let i = 0; i < message.citations.length; i++)
      Citation.internalBinaryWrite(
        message.citations[i],
        writer.tag(8, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Comment comments = 9; */
    for (let i = 0; i < message.comments.length; i++)
      Comment.internalBinaryWrite(
        message.comments[i],
        writer.tag(9, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional google.protobuf.Timestamp date_last_evaluated = 10; */
    if (message.dateLastEvaluated)
      Timestamp.internalBinaryWrite(
        message.dateLastEvaluated,
        writer.tag(10, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.ClassificationScv
 */
export const ClassificationScv = new ClassificationScv$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ClassificationScv_SomaticClinicalImpact$Type extends MessageType<ClassificationScv_SomaticClinicalImpact> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.ClassificationScv.SomaticClinicalImpact', [
      { no: 1, name: 'value', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: 'clinical_impact_assertion_type',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: 'clinical_impact_clinical_significance',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: 'drug_for_therapeutic_assertion',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/
      }
    ])
  }
  create(
    value?: PartialMessage<ClassificationScv_SomaticClinicalImpact>
  ): ClassificationScv_SomaticClinicalImpact {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.value = ''
    if (value !== undefined)
      reflectionMergePartial<ClassificationScv_SomaticClinicalImpact>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ClassificationScv_SomaticClinicalImpact
  ): ClassificationScv_SomaticClinicalImpact {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string value */ 1:
          message.value = reader.string()
          break
        case /* optional string clinical_impact_assertion_type */ 2:
          message.clinicalImpactAssertionType = reader.string()
          break
        case /* optional string clinical_impact_clinical_significance */ 3:
          message.clinicalImpactClinicalSignificance = reader.string()
          break
        case /* optional string drug_for_therapeutic_assertion */ 4:
          message.drugForTherapeuticAssertion = reader.string()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ClassificationScv_SomaticClinicalImpact,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string value = 1; */
    if (message.value !== '') writer.tag(1, WireType.LengthDelimited).string(message.value)
    /* optional string clinical_impact_assertion_type = 2; */
    if (message.clinicalImpactAssertionType !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.clinicalImpactAssertionType)
    /* optional string clinical_impact_clinical_significance = 3; */
    if (message.clinicalImpactClinicalSignificance !== undefined)
      writer.tag(3, WireType.LengthDelimited).string(message.clinicalImpactClinicalSignificance)
    /* optional string drug_for_therapeutic_assertion = 4; */
    if (message.drugForTherapeuticAssertion !== undefined)
      writer.tag(4, WireType.LengthDelimited).string(message.drugForTherapeuticAssertion)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.ClassificationScv.SomaticClinicalImpact
 */
export const ClassificationScv_SomaticClinicalImpact =
  new ClassificationScv_SomaticClinicalImpact$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ClassificationScv_ClassificationScore$Type extends MessageType<ClassificationScv_ClassificationScore> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.ClassificationScv.ClassificationScore', [
      { no: 1, name: 'value', kind: 'scalar', T: 1 /*ScalarType.DOUBLE*/ },
      { no: 2, name: 'type', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(
    value?: PartialMessage<ClassificationScv_ClassificationScore>
  ): ClassificationScv_ClassificationScore {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.value = 0
    if (value !== undefined)
      reflectionMergePartial<ClassificationScv_ClassificationScore>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ClassificationScv_ClassificationScore
  ): ClassificationScv_ClassificationScore {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* double value */ 1:
          message.value = reader.double()
          break
        case /* optional string type */ 2:
          message.type = reader.string()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ClassificationScv_ClassificationScore,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* double value = 1; */
    if (message.value !== 0) writer.tag(1, WireType.Bit64).double(message.value)
    /* optional string type = 2; */
    if (message.type !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.type)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.ClassificationScv.ClassificationScore
 */
export const ClassificationScv_ClassificationScore =
  new ClassificationScv_ClassificationScore$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SubmitterIdentifiers$Type extends MessageType<SubmitterIdentifiers> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.SubmitterIdentifiers', [
      { no: 1, name: 'submitter_name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'org_id', kind: 'scalar', T: 3 /*ScalarType.INT64*/ },
      { no: 3, name: 'org_category', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: 'org_abbreviation', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(value?: PartialMessage<SubmitterIdentifiers>): SubmitterIdentifiers {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.submitterName = ''
    message.orgId = '0'
    message.orgCategory = ''
    if (value !== undefined) reflectionMergePartial<SubmitterIdentifiers>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SubmitterIdentifiers
  ): SubmitterIdentifiers {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string submitter_name */ 1:
          message.submitterName = reader.string()
          break
        case /* int64 org_id */ 2:
          message.orgId = reader.int64().toString()
          break
        case /* string org_category */ 3:
          message.orgCategory = reader.string()
          break
        case /* optional string org_abbreviation */ 4:
          message.orgAbbreviation = reader.string()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: SubmitterIdentifiers,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string submitter_name = 1; */
    if (message.submitterName !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.submitterName)
    /* int64 org_id = 2; */
    if (message.orgId !== '0') writer.tag(2, WireType.Varint).int64(message.orgId)
    /* string org_category = 3; */
    if (message.orgCategory !== '')
      writer.tag(3, WireType.LengthDelimited).string(message.orgCategory)
    /* optional string org_abbreviation = 4; */
    if (message.orgAbbreviation !== undefined)
      writer.tag(4, WireType.LengthDelimited).string(message.orgAbbreviation)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.SubmitterIdentifiers
 */
export const SubmitterIdentifiers = new SubmitterIdentifiers$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Species$Type extends MessageType<Species> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.Species', [
      { no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'taxonomy_id', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ }
    ])
  }
  create(value?: PartialMessage<Species>): Species {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.name = ''
    if (value !== undefined) reflectionMergePartial<Species>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Species
  ): Species {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string()
          break
        case /* optional int32 taxonomy_id */ 2:
          message.taxonomyId = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Species,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '') writer.tag(1, WireType.LengthDelimited).string(message.name)
    /* optional int32 taxonomy_id = 2; */
    if (message.taxonomyId !== undefined) writer.tag(2, WireType.Varint).int32(message.taxonomyId)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.Species
 */
export const Species = new Species$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ClassifiedCondition$Type extends MessageType<ClassifiedCondition> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.ClassifiedCondition', [
      { no: 1, name: 'value', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'db', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'id', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(value?: PartialMessage<ClassifiedCondition>): ClassifiedCondition {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.value = ''
    if (value !== undefined) reflectionMergePartial<ClassifiedCondition>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ClassifiedCondition
  ): ClassifiedCondition {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string value */ 1:
          message.value = reader.string()
          break
        case /* optional string db */ 2:
          message.db = reader.string()
          break
        case /* optional string id */ 3:
          message.id = reader.string()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ClassifiedCondition,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string value = 1; */
    if (message.value !== '') writer.tag(1, WireType.LengthDelimited).string(message.value)
    /* optional string db = 2; */
    if (message.db !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.db)
    /* optional string id = 3; */
    if (message.id !== undefined) writer.tag(3, WireType.LengthDelimited).string(message.id)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.ClassifiedCondition
 */
export const ClassifiedCondition = new ClassifiedCondition$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ClinicalAssertionRecordHistory$Type extends MessageType<ClinicalAssertionRecordHistory> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.ClinicalAssertionRecordHistory', [
      { no: 1, name: 'comment', kind: 'message', T: () => Comment },
      { no: 2, name: 'accession', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'version', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      { no: 4, name: 'date_changed', kind: 'message', T: () => Timestamp }
    ])
  }
  create(value?: PartialMessage<ClinicalAssertionRecordHistory>): ClinicalAssertionRecordHistory {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.accession = ''
    if (value !== undefined)
      reflectionMergePartial<ClinicalAssertionRecordHistory>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ClinicalAssertionRecordHistory
  ): ClinicalAssertionRecordHistory {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional annonars.clinvar_data.clinvar_public.Comment comment */ 1:
          message.comment = Comment.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.comment
          )
          break
        case /* string accession */ 2:
          message.accession = reader.string()
          break
        case /* optional int32 version */ 3:
          message.version = reader.int32()
          break
        case /* google.protobuf.Timestamp date_changed */ 4:
          message.dateChanged = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.dateChanged
          )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ClinicalAssertionRecordHistory,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional annonars.clinvar_data.clinvar_public.Comment comment = 1; */
    if (message.comment)
      Comment.internalBinaryWrite(
        message.comment,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* string accession = 2; */
    if (message.accession !== '') writer.tag(2, WireType.LengthDelimited).string(message.accession)
    /* optional int32 version = 3; */
    if (message.version !== undefined) writer.tag(3, WireType.Varint).int32(message.version)
    /* google.protobuf.Timestamp date_changed = 4; */
    if (message.dateChanged)
      Timestamp.internalBinaryWrite(
        message.dateChanged,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.ClinicalAssertionRecordHistory
 */
export const ClinicalAssertionRecordHistory = new ClinicalAssertionRecordHistory$Type()
// @generated message type with reflection information, may provide speed optimized methods
class FunctionalConsequence$Type extends MessageType<FunctionalConsequence> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.FunctionalConsequence', [
      { no: 1, name: 'xrefs', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Xref },
      {
        no: 2,
        name: 'citations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Citation
      },
      {
        no: 3,
        name: 'comments',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Comment
      },
      { no: 4, name: 'value', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(value?: PartialMessage<FunctionalConsequence>): FunctionalConsequence {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.xrefs = []
    message.citations = []
    message.comments = []
    message.value = ''
    if (value !== undefined) reflectionMergePartial<FunctionalConsequence>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: FunctionalConsequence
  ): FunctionalConsequence {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs */ 1:
          message.xrefs.push(Xref.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Citation citations */ 2:
          message.citations.push(Citation.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Comment comments */ 3:
          message.comments.push(Comment.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* string value */ 4:
          message.value = reader.string()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: FunctionalConsequence,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 1; */
    for (let i = 0; i < message.xrefs.length; i++)
      Xref.internalBinaryWrite(
        message.xrefs[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Citation citations = 2; */
    for (let i = 0; i < message.citations.length; i++)
      Citation.internalBinaryWrite(
        message.citations[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Comment comments = 3; */
    for (let i = 0; i < message.comments.length; i++)
      Comment.internalBinaryWrite(
        message.comments[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* string value = 4; */
    if (message.value !== '') writer.tag(4, WireType.LengthDelimited).string(message.value)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.FunctionalConsequence
 */
export const FunctionalConsequence = new FunctionalConsequence$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GeneralCitations$Type extends MessageType<GeneralCitations> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.GeneralCitations', [
      { no: 1, name: 'xrefs', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Xref },
      {
        no: 2,
        name: 'citations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Citation
      }
    ])
  }
  create(value?: PartialMessage<GeneralCitations>): GeneralCitations {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.xrefs = []
    message.citations = []
    if (value !== undefined) reflectionMergePartial<GeneralCitations>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GeneralCitations
  ): GeneralCitations {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs */ 1:
          message.xrefs.push(Xref.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Citation citations */ 2:
          message.citations.push(Citation.internalBinaryRead(reader, reader.uint32(), options))
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: GeneralCitations,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 1; */
    for (let i = 0; i < message.xrefs.length; i++)
      Xref.internalBinaryWrite(
        message.xrefs[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Citation citations = 2; */
    for (let i = 0; i < message.citations.length; i++)
      Citation.internalBinaryWrite(
        message.citations[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.GeneralCitations
 */
export const GeneralCitations = new GeneralCitations$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Cooccurrence$Type extends MessageType<Cooccurrence> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.Cooccurrence', [
      {
        no: 1,
        name: 'zygosity',
        kind: 'enum',
        opt: true,
        T: () => ['annonars.clinvar_data.clinvar_public.Zygosity', Zygosity]
      },
      {
        no: 2,
        name: 'allele_descriptions',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => AlleleDescription
      },
      { no: 3, name: 'count', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ }
    ])
  }
  create(value?: PartialMessage<Cooccurrence>): Cooccurrence {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.alleleDescriptions = []
    if (value !== undefined) reflectionMergePartial<Cooccurrence>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Cooccurrence
  ): Cooccurrence {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional annonars.clinvar_data.clinvar_public.Zygosity zygosity */ 1:
          message.zygosity = reader.int32()
          break
        case /* repeated annonars.clinvar_data.clinvar_public.AlleleDescription allele_descriptions */ 2:
          message.alleleDescriptions.push(
            AlleleDescription.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* optional int32 count */ 3:
          message.count = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Cooccurrence,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional annonars.clinvar_data.clinvar_public.Zygosity zygosity = 1; */
    if (message.zygosity !== undefined) writer.tag(1, WireType.Varint).int32(message.zygosity)
    /* repeated annonars.clinvar_data.clinvar_public.AlleleDescription allele_descriptions = 2; */
    for (let i = 0; i < message.alleleDescriptions.length; i++)
      AlleleDescription.internalBinaryWrite(
        message.alleleDescriptions[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional int32 count = 3; */
    if (message.count !== undefined) writer.tag(3, WireType.Varint).int32(message.count)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.Cooccurrence
 */
export const Cooccurrence = new Cooccurrence$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Submitter$Type extends MessageType<Submitter> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.Submitter', [
      { no: 1, name: 'submitter_identifiers', kind: 'message', T: () => SubmitterIdentifiers },
      {
        no: 2,
        name: 'type',
        kind: 'enum',
        T: () => ['annonars.clinvar_data.clinvar_public.Submitter.Type', Submitter_Type]
      }
    ])
  }
  create(value?: PartialMessage<Submitter>): Submitter {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.type = 0
    if (value !== undefined) reflectionMergePartial<Submitter>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Submitter
  ): Submitter {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* annonars.clinvar_data.clinvar_public.SubmitterIdentifiers submitter_identifiers */ 1:
          message.submitterIdentifiers = SubmitterIdentifiers.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.submitterIdentifiers
          )
          break
        case /* annonars.clinvar_data.clinvar_public.Submitter.Type type */ 2:
          message.type = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Submitter,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* annonars.clinvar_data.clinvar_public.SubmitterIdentifiers submitter_identifiers = 1; */
    if (message.submitterIdentifiers)
      SubmitterIdentifiers.internalBinaryWrite(
        message.submitterIdentifiers,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.clinvar_data.clinvar_public.Submitter.Type type = 2; */
    if (message.type !== 0) writer.tag(2, WireType.Varint).int32(message.type)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.Submitter
 */
export const Submitter = new Submitter$Type()
// @generated message type with reflection information, may provide speed optimized methods
class DosageSensitivity$Type extends MessageType<DosageSensitivity> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.DosageSensitivity', [
      { no: 1, name: 'value', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'last_evaluated', kind: 'message', T: () => Timestamp },
      { no: 3, name: 'clingen', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(value?: PartialMessage<DosageSensitivity>): DosageSensitivity {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.value = ''
    if (value !== undefined) reflectionMergePartial<DosageSensitivity>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DosageSensitivity
  ): DosageSensitivity {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string value */ 1:
          message.value = reader.string()
          break
        case /* optional google.protobuf.Timestamp last_evaluated */ 2:
          message.lastEvaluated = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.lastEvaluated
          )
          break
        case /* optional string clingen */ 3:
          message.clingen = reader.string()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: DosageSensitivity,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string value = 1; */
    if (message.value !== '') writer.tag(1, WireType.LengthDelimited).string(message.value)
    /* optional google.protobuf.Timestamp last_evaluated = 2; */
    if (message.lastEvaluated)
      Timestamp.internalBinaryWrite(
        message.lastEvaluated,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional string clingen = 3; */
    if (message.clingen !== undefined)
      writer.tag(3, WireType.LengthDelimited).string(message.clingen)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.DosageSensitivity
 */
export const DosageSensitivity = new DosageSensitivity$Type()
// @generated message type with reflection information, may provide speed optimized methods
class OtherName$Type extends MessageType<OtherName> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.OtherName', [
      { no: 1, name: 'value', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'type', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(value?: PartialMessage<OtherName>): OtherName {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.value = ''
    if (value !== undefined) reflectionMergePartial<OtherName>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: OtherName
  ): OtherName {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string value */ 1:
          message.value = reader.string()
          break
        case /* optional string type */ 2:
          message.type = reader.string()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: OtherName,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string value = 1; */
    if (message.value !== '') writer.tag(1, WireType.LengthDelimited).string(message.value)
    /* optional string type = 2; */
    if (message.type !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.type)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.OtherName
 */
export const OtherName = new OtherName$Type()
// @generated message type with reflection information, may provide speed optimized methods
class DeletedScv$Type extends MessageType<DeletedScv> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.DeletedScv', [
      { no: 1, name: 'accession', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'version', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 3, name: 'date_deleted', kind: 'message', T: () => Timestamp }
    ])
  }
  create(value?: PartialMessage<DeletedScv>): DeletedScv {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.accession = ''
    message.version = 0
    if (value !== undefined) reflectionMergePartial<DeletedScv>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DeletedScv
  ): DeletedScv {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string accession */ 1:
          message.accession = reader.string()
          break
        case /* int32 version */ 2:
          message.version = reader.int32()
          break
        case /* google.protobuf.Timestamp date_deleted */ 3:
          message.dateDeleted = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.dateDeleted
          )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: DeletedScv,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string accession = 1; */
    if (message.accession !== '') writer.tag(1, WireType.LengthDelimited).string(message.accession)
    /* int32 version = 2; */
    if (message.version !== 0) writer.tag(2, WireType.Varint).int32(message.version)
    /* google.protobuf.Timestamp date_deleted = 3; */
    if (message.dateDeleted)
      Timestamp.internalBinaryWrite(
        message.dateDeleted,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.DeletedScv
 */
export const DeletedScv = new DeletedScv$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Location$Type extends MessageType<Location> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.Location', [
      {
        no: 1,
        name: 'cytogenetic_locations',
        kind: 'scalar',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: 'sequence_locations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Location_SequenceLocation
      },
      {
        no: 3,
        name: 'gene_locations',
        kind: 'scalar',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/
      },
      { no: 4, name: 'xrefs', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Xref }
    ])
  }
  create(value?: PartialMessage<Location>): Location {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.cytogeneticLocations = []
    message.sequenceLocations = []
    message.geneLocations = []
    message.xrefs = []
    if (value !== undefined) reflectionMergePartial<Location>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Location
  ): Location {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated string cytogenetic_locations */ 1:
          message.cytogeneticLocations.push(reader.string())
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Location.SequenceLocation sequence_locations */ 2:
          message.sequenceLocations.push(
            Location_SequenceLocation.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* repeated string gene_locations */ 3:
          message.geneLocations.push(reader.string())
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs */ 4:
          message.xrefs.push(Xref.internalBinaryRead(reader, reader.uint32(), options))
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Location,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated string cytogenetic_locations = 1; */
    for (let i = 0; i < message.cytogeneticLocations.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.cytogeneticLocations[i])
    /* repeated annonars.clinvar_data.clinvar_public.Location.SequenceLocation sequence_locations = 2; */
    for (let i = 0; i < message.sequenceLocations.length; i++)
      Location_SequenceLocation.internalBinaryWrite(
        message.sequenceLocations[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated string gene_locations = 3; */
    for (let i = 0; i < message.geneLocations.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.geneLocations[i])
    /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 4; */
    for (let i = 0; i < message.xrefs.length; i++)
      Xref.internalBinaryWrite(
        message.xrefs[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.Location
 */
export const Location = new Location$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Location_SequenceLocation$Type extends MessageType<Location_SequenceLocation> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.Location.SequenceLocation', [
      { no: 1, name: 'for_display', kind: 'scalar', opt: true, T: 8 /*ScalarType.BOOL*/ },
      { no: 2, name: 'assembly', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: 'chr',
        kind: 'enum',
        T: () => ['annonars.clinvar_data.clinvar_public.Chromosome', Chromosome]
      },
      { no: 4, name: 'accession', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 5, name: 'outer_start', kind: 'scalar', opt: true, T: 13 /*ScalarType.UINT32*/ },
      { no: 6, name: 'inner_start', kind: 'scalar', opt: true, T: 13 /*ScalarType.UINT32*/ },
      { no: 7, name: 'start', kind: 'scalar', opt: true, T: 13 /*ScalarType.UINT32*/ },
      { no: 8, name: 'stop', kind: 'scalar', opt: true, T: 13 /*ScalarType.UINT32*/ },
      { no: 9, name: 'inner_stop', kind: 'scalar', opt: true, T: 13 /*ScalarType.UINT32*/ },
      { no: 10, name: 'outer_stop', kind: 'scalar', opt: true, T: 13 /*ScalarType.UINT32*/ },
      { no: 11, name: 'display_start', kind: 'scalar', opt: true, T: 13 /*ScalarType.UINT32*/ },
      { no: 12, name: 'display_stop', kind: 'scalar', opt: true, T: 13 /*ScalarType.UINT32*/ },
      { no: 13, name: 'strand', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 14, name: 'variant_length', kind: 'scalar', opt: true, T: 13 /*ScalarType.UINT32*/ },
      { no: 15, name: 'reference_allele', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 16, name: 'alternate_allele', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      {
        no: 17,
        name: 'assembly_accession_version',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/
      },
      {
        no: 18,
        name: 'assembly_status',
        kind: 'enum',
        opt: true,
        T: () => [
          'annonars.clinvar_data.clinvar_public.Location.SequenceLocation.AssemblyStatus',
          Location_SequenceLocation_AssemblyStatus
        ]
      },
      { no: 19, name: 'position_vcf', kind: 'scalar', opt: true, T: 13 /*ScalarType.UINT32*/ },
      {
        no: 20,
        name: 'reference_allele_vcf',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/
      },
      {
        no: 21,
        name: 'alternate_allele_vcf',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/
      },
      { no: 22, name: 'for_display_length', kind: 'scalar', opt: true, T: 13 /*ScalarType.UINT32*/ }
    ])
  }
  create(value?: PartialMessage<Location_SequenceLocation>): Location_SequenceLocation {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.assembly = ''
    message.chr = 0
    if (value !== undefined) reflectionMergePartial<Location_SequenceLocation>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Location_SequenceLocation
  ): Location_SequenceLocation {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional bool for_display */ 1:
          message.forDisplay = reader.bool()
          break
        case /* string assembly */ 2:
          message.assembly = reader.string()
          break
        case /* annonars.clinvar_data.clinvar_public.Chromosome chr */ 3:
          message.chr = reader.int32()
          break
        case /* optional string accession */ 4:
          message.accession = reader.string()
          break
        case /* optional uint32 outer_start */ 5:
          message.outerStart = reader.uint32()
          break
        case /* optional uint32 inner_start */ 6:
          message.innerStart = reader.uint32()
          break
        case /* optional uint32 start */ 7:
          message.start = reader.uint32()
          break
        case /* optional uint32 stop */ 8:
          message.stop = reader.uint32()
          break
        case /* optional uint32 inner_stop */ 9:
          message.innerStop = reader.uint32()
          break
        case /* optional uint32 outer_stop */ 10:
          message.outerStop = reader.uint32()
          break
        case /* optional uint32 display_start */ 11:
          message.displayStart = reader.uint32()
          break
        case /* optional uint32 display_stop */ 12:
          message.displayStop = reader.uint32()
          break
        case /* optional string strand */ 13:
          message.strand = reader.string()
          break
        case /* optional uint32 variant_length */ 14:
          message.variantLength = reader.uint32()
          break
        case /* optional string reference_allele */ 15:
          message.referenceAllele = reader.string()
          break
        case /* optional string alternate_allele */ 16:
          message.alternateAllele = reader.string()
          break
        case /* optional string assembly_accession_version */ 17:
          message.assemblyAccessionVersion = reader.string()
          break
        case /* optional annonars.clinvar_data.clinvar_public.Location.SequenceLocation.AssemblyStatus assembly_status */ 18:
          message.assemblyStatus = reader.int32()
          break
        case /* optional uint32 position_vcf */ 19:
          message.positionVcf = reader.uint32()
          break
        case /* optional string reference_allele_vcf */ 20:
          message.referenceAlleleVcf = reader.string()
          break
        case /* optional string alternate_allele_vcf */ 21:
          message.alternateAlleleVcf = reader.string()
          break
        case /* optional uint32 for_display_length */ 22:
          message.forDisplayLength = reader.uint32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Location_SequenceLocation,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional bool for_display = 1; */
    if (message.forDisplay !== undefined) writer.tag(1, WireType.Varint).bool(message.forDisplay)
    /* string assembly = 2; */
    if (message.assembly !== '') writer.tag(2, WireType.LengthDelimited).string(message.assembly)
    /* annonars.clinvar_data.clinvar_public.Chromosome chr = 3; */
    if (message.chr !== 0) writer.tag(3, WireType.Varint).int32(message.chr)
    /* optional string accession = 4; */
    if (message.accession !== undefined)
      writer.tag(4, WireType.LengthDelimited).string(message.accession)
    /* optional uint32 outer_start = 5; */
    if (message.outerStart !== undefined) writer.tag(5, WireType.Varint).uint32(message.outerStart)
    /* optional uint32 inner_start = 6; */
    if (message.innerStart !== undefined) writer.tag(6, WireType.Varint).uint32(message.innerStart)
    /* optional uint32 start = 7; */
    if (message.start !== undefined) writer.tag(7, WireType.Varint).uint32(message.start)
    /* optional uint32 stop = 8; */
    if (message.stop !== undefined) writer.tag(8, WireType.Varint).uint32(message.stop)
    /* optional uint32 inner_stop = 9; */
    if (message.innerStop !== undefined) writer.tag(9, WireType.Varint).uint32(message.innerStop)
    /* optional uint32 outer_stop = 10; */
    if (message.outerStop !== undefined) writer.tag(10, WireType.Varint).uint32(message.outerStop)
    /* optional uint32 display_start = 11; */
    if (message.displayStart !== undefined)
      writer.tag(11, WireType.Varint).uint32(message.displayStart)
    /* optional uint32 display_stop = 12; */
    if (message.displayStop !== undefined)
      writer.tag(12, WireType.Varint).uint32(message.displayStop)
    /* optional string strand = 13; */
    if (message.strand !== undefined)
      writer.tag(13, WireType.LengthDelimited).string(message.strand)
    /* optional uint32 variant_length = 14; */
    if (message.variantLength !== undefined)
      writer.tag(14, WireType.Varint).uint32(message.variantLength)
    /* optional string reference_allele = 15; */
    if (message.referenceAllele !== undefined)
      writer.tag(15, WireType.LengthDelimited).string(message.referenceAllele)
    /* optional string alternate_allele = 16; */
    if (message.alternateAllele !== undefined)
      writer.tag(16, WireType.LengthDelimited).string(message.alternateAllele)
    /* optional string assembly_accession_version = 17; */
    if (message.assemblyAccessionVersion !== undefined)
      writer.tag(17, WireType.LengthDelimited).string(message.assemblyAccessionVersion)
    /* optional annonars.clinvar_data.clinvar_public.Location.SequenceLocation.AssemblyStatus assembly_status = 18; */
    if (message.assemblyStatus !== undefined)
      writer.tag(18, WireType.Varint).int32(message.assemblyStatus)
    /* optional uint32 position_vcf = 19; */
    if (message.positionVcf !== undefined)
      writer.tag(19, WireType.Varint).uint32(message.positionVcf)
    /* optional string reference_allele_vcf = 20; */
    if (message.referenceAlleleVcf !== undefined)
      writer.tag(20, WireType.LengthDelimited).string(message.referenceAlleleVcf)
    /* optional string alternate_allele_vcf = 21; */
    if (message.alternateAlleleVcf !== undefined)
      writer.tag(21, WireType.LengthDelimited).string(message.alternateAlleleVcf)
    /* optional uint32 for_display_length = 22; */
    if (message.forDisplayLength !== undefined)
      writer.tag(22, WireType.Varint).uint32(message.forDisplayLength)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.Location.SequenceLocation
 */
export const Location_SequenceLocation = new Location_SequenceLocation$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Scv$Type extends MessageType<Scv> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.Scv', [
      { no: 1, name: 'title', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'accession', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'version', kind: 'scalar', T: 5 /*ScalarType.INT32*/ }
    ])
  }
  create(value?: PartialMessage<Scv>): Scv {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.accession = ''
    message.version = 0
    if (value !== undefined) reflectionMergePartial<Scv>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Scv
  ): Scv {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional string title */ 1:
          message.title = reader.string()
          break
        case /* string accession */ 2:
          message.accession = reader.string()
          break
        case /* int32 version */ 3:
          message.version = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Scv,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional string title = 1; */
    if (message.title !== undefined) writer.tag(1, WireType.LengthDelimited).string(message.title)
    /* string accession = 2; */
    if (message.accession !== '') writer.tag(2, WireType.LengthDelimited).string(message.accession)
    /* int32 version = 3; */
    if (message.version !== 0) writer.tag(3, WireType.Varint).int32(message.version)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.Scv
 */
export const Scv = new Scv$Type()
// @generated message type with reflection information, may provide speed optimized methods
class FamilyData$Type extends MessageType<FamilyData> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.FamilyData', [
      { no: 1, name: 'family_history', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'num_families', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      {
        no: 3,
        name: 'num_families_with_variant',
        kind: 'scalar',
        opt: true,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: 'num_families_with_segregation_observed',
        kind: 'scalar',
        opt: true,
        T: 5 /*ScalarType.INT32*/
      },
      { no: 5, name: 'pedigree_id', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 6, name: 'segregation_observed', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(value?: PartialMessage<FamilyData>): FamilyData {
    const message = globalThis.Object.create(this.messagePrototype!)
    if (value !== undefined) reflectionMergePartial<FamilyData>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: FamilyData
  ): FamilyData {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional string family_history */ 1:
          message.familyHistory = reader.string()
          break
        case /* optional int32 num_families */ 2:
          message.numFamilies = reader.int32()
          break
        case /* optional int32 num_families_with_variant */ 3:
          message.numFamiliesWithVariant = reader.int32()
          break
        case /* optional int32 num_families_with_segregation_observed */ 4:
          message.numFamiliesWithSegregationObserved = reader.int32()
          break
        case /* optional string pedigree_id */ 5:
          message.pedigreeId = reader.string()
          break
        case /* optional string segregation_observed */ 6:
          message.segregationObserved = reader.string()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: FamilyData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional string family_history = 1; */
    if (message.familyHistory !== undefined)
      writer.tag(1, WireType.LengthDelimited).string(message.familyHistory)
    /* optional int32 num_families = 2; */
    if (message.numFamilies !== undefined) writer.tag(2, WireType.Varint).int32(message.numFamilies)
    /* optional int32 num_families_with_variant = 3; */
    if (message.numFamiliesWithVariant !== undefined)
      writer.tag(3, WireType.Varint).int32(message.numFamiliesWithVariant)
    /* optional int32 num_families_with_segregation_observed = 4; */
    if (message.numFamiliesWithSegregationObserved !== undefined)
      writer.tag(4, WireType.Varint).int32(message.numFamiliesWithSegregationObserved)
    /* optional string pedigree_id = 5; */
    if (message.pedigreeId !== undefined)
      writer.tag(5, WireType.LengthDelimited).string(message.pedigreeId)
    /* optional string segregation_observed = 6; */
    if (message.segregationObserved !== undefined)
      writer.tag(6, WireType.LengthDelimited).string(message.segregationObserved)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.FamilyData
 */
export const FamilyData = new FamilyData$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Sample$Type extends MessageType<Sample> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.Sample', [
      { no: 1, name: 'sample_description', kind: 'message', T: () => Sample_SampleDescription },
      {
        no: 2,
        name: 'origin',
        kind: 'enum',
        opt: true,
        T: () => ['annonars.clinvar_data.clinvar_public.Origin', Origin]
      },
      { no: 3, name: 'ethnicity', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: 'geographic_origin', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 5, name: 'tissue', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      {
        no: 6,
        name: 'somatic_variant_in_normal_tissue',
        kind: 'enum',
        opt: true,
        T: () => [
          'annonars.clinvar_data.clinvar_public.Sample.SomaticVariantInNormalTissue',
          Sample_SomaticVariantInNormalTissue
        ]
      },
      {
        no: 7,
        name: 'somatic_variant_allele_fraction',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/
      },
      { no: 8, name: 'cell_line', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 9, name: 'species', kind: 'message', T: () => Species },
      {
        no: 10,
        name: 'ages',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Sample_Age
      },
      { no: 11, name: 'strain', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      {
        no: 12,
        name: 'affected_status',
        kind: 'enum',
        opt: true,
        T: () => [
          'annonars.clinvar_data.clinvar_public.Sample.AffectedStatus',
          Sample_AffectedStatus
        ]
      },
      { no: 13, name: 'numer_tested', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      { no: 14, name: 'number_males', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      { no: 15, name: 'number_females', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      { no: 16, name: 'number_chr_tested', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      {
        no: 17,
        name: 'gender',
        kind: 'enum',
        opt: true,
        T: () => ['annonars.clinvar_data.clinvar_public.Sample.Gender', Sample_Gender]
      },
      { no: 18, name: 'family_data', kind: 'message', T: () => FamilyData },
      { no: 19, name: 'proband', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 20, name: 'indication', kind: 'message', T: () => Indication },
      {
        no: 21,
        name: 'citations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Citation
      },
      { no: 22, name: 'xrefs', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Xref },
      {
        no: 23,
        name: 'comments',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Comment
      },
      {
        no: 24,
        name: 'source_type',
        kind: 'enum',
        opt: true,
        T: () => ['annonars.clinvar_data.clinvar_public.Sample.SourceType', Sample_SourceType]
      }
    ])
  }
  create(value?: PartialMessage<Sample>): Sample {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.ages = []
    message.citations = []
    message.xrefs = []
    message.comments = []
    if (value !== undefined) reflectionMergePartial<Sample>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Sample
  ): Sample {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional annonars.clinvar_data.clinvar_public.Sample.SampleDescription sample_description */ 1:
          message.sampleDescription = Sample_SampleDescription.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.sampleDescription
          )
          break
        case /* optional annonars.clinvar_data.clinvar_public.Origin origin */ 2:
          message.origin = reader.int32()
          break
        case /* optional string ethnicity */ 3:
          message.ethnicity = reader.string()
          break
        case /* optional string geographic_origin */ 4:
          message.geographicOrigin = reader.string()
          break
        case /* optional string tissue */ 5:
          message.tissue = reader.string()
          break
        case /* optional annonars.clinvar_data.clinvar_public.Sample.SomaticVariantInNormalTissue somatic_variant_in_normal_tissue */ 6:
          message.somaticVariantInNormalTissue = reader.int32()
          break
        case /* optional string somatic_variant_allele_fraction */ 7:
          message.somaticVariantAlleleFraction = reader.string()
          break
        case /* optional string cell_line */ 8:
          message.cellLine = reader.string()
          break
        case /* optional annonars.clinvar_data.clinvar_public.Species species */ 9:
          message.species = Species.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.species
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Sample.Age ages */ 10:
          message.ages.push(Sample_Age.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* optional string strain */ 11:
          message.strain = reader.string()
          break
        case /* optional annonars.clinvar_data.clinvar_public.Sample.AffectedStatus affected_status */ 12:
          message.affectedStatus = reader.int32()
          break
        case /* optional int32 numer_tested */ 13:
          message.numerTested = reader.int32()
          break
        case /* optional int32 number_males */ 14:
          message.numberMales = reader.int32()
          break
        case /* optional int32 number_females */ 15:
          message.numberFemales = reader.int32()
          break
        case /* optional int32 number_chr_tested */ 16:
          message.numberChrTested = reader.int32()
          break
        case /* optional annonars.clinvar_data.clinvar_public.Sample.Gender gender */ 17:
          message.gender = reader.int32()
          break
        case /* optional annonars.clinvar_data.clinvar_public.FamilyData family_data */ 18:
          message.familyData = FamilyData.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.familyData
          )
          break
        case /* optional string proband */ 19:
          message.proband = reader.string()
          break
        case /* optional annonars.clinvar_data.clinvar_public.Indication indication */ 20:
          message.indication = Indication.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.indication
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Citation citations */ 21:
          message.citations.push(Citation.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs */ 22:
          message.xrefs.push(Xref.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Comment comments */ 23:
          message.comments.push(Comment.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* optional annonars.clinvar_data.clinvar_public.Sample.SourceType source_type */ 24:
          message.sourceType = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Sample,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional annonars.clinvar_data.clinvar_public.Sample.SampleDescription sample_description = 1; */
    if (message.sampleDescription)
      Sample_SampleDescription.internalBinaryWrite(
        message.sampleDescription,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.clinvar_data.clinvar_public.Origin origin = 2; */
    if (message.origin !== undefined) writer.tag(2, WireType.Varint).int32(message.origin)
    /* optional string ethnicity = 3; */
    if (message.ethnicity !== undefined)
      writer.tag(3, WireType.LengthDelimited).string(message.ethnicity)
    /* optional string geographic_origin = 4; */
    if (message.geographicOrigin !== undefined)
      writer.tag(4, WireType.LengthDelimited).string(message.geographicOrigin)
    /* optional string tissue = 5; */
    if (message.tissue !== undefined) writer.tag(5, WireType.LengthDelimited).string(message.tissue)
    /* optional annonars.clinvar_data.clinvar_public.Sample.SomaticVariantInNormalTissue somatic_variant_in_normal_tissue = 6; */
    if (message.somaticVariantInNormalTissue !== undefined)
      writer.tag(6, WireType.Varint).int32(message.somaticVariantInNormalTissue)
    /* optional string somatic_variant_allele_fraction = 7; */
    if (message.somaticVariantAlleleFraction !== undefined)
      writer.tag(7, WireType.LengthDelimited).string(message.somaticVariantAlleleFraction)
    /* optional string cell_line = 8; */
    if (message.cellLine !== undefined)
      writer.tag(8, WireType.LengthDelimited).string(message.cellLine)
    /* optional annonars.clinvar_data.clinvar_public.Species species = 9; */
    if (message.species)
      Species.internalBinaryWrite(
        message.species,
        writer.tag(9, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Sample.Age ages = 10; */
    for (let i = 0; i < message.ages.length; i++)
      Sample_Age.internalBinaryWrite(
        message.ages[i],
        writer.tag(10, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional string strain = 11; */
    if (message.strain !== undefined)
      writer.tag(11, WireType.LengthDelimited).string(message.strain)
    /* optional annonars.clinvar_data.clinvar_public.Sample.AffectedStatus affected_status = 12; */
    if (message.affectedStatus !== undefined)
      writer.tag(12, WireType.Varint).int32(message.affectedStatus)
    /* optional int32 numer_tested = 13; */
    if (message.numerTested !== undefined)
      writer.tag(13, WireType.Varint).int32(message.numerTested)
    /* optional int32 number_males = 14; */
    if (message.numberMales !== undefined)
      writer.tag(14, WireType.Varint).int32(message.numberMales)
    /* optional int32 number_females = 15; */
    if (message.numberFemales !== undefined)
      writer.tag(15, WireType.Varint).int32(message.numberFemales)
    /* optional int32 number_chr_tested = 16; */
    if (message.numberChrTested !== undefined)
      writer.tag(16, WireType.Varint).int32(message.numberChrTested)
    /* optional annonars.clinvar_data.clinvar_public.Sample.Gender gender = 17; */
    if (message.gender !== undefined) writer.tag(17, WireType.Varint).int32(message.gender)
    /* optional annonars.clinvar_data.clinvar_public.FamilyData family_data = 18; */
    if (message.familyData)
      FamilyData.internalBinaryWrite(
        message.familyData,
        writer.tag(18, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional string proband = 19; */
    if (message.proband !== undefined)
      writer.tag(19, WireType.LengthDelimited).string(message.proband)
    /* optional annonars.clinvar_data.clinvar_public.Indication indication = 20; */
    if (message.indication)
      Indication.internalBinaryWrite(
        message.indication,
        writer.tag(20, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Citation citations = 21; */
    for (let i = 0; i < message.citations.length; i++)
      Citation.internalBinaryWrite(
        message.citations[i],
        writer.tag(21, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 22; */
    for (let i = 0; i < message.xrefs.length; i++)
      Xref.internalBinaryWrite(
        message.xrefs[i],
        writer.tag(22, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Comment comments = 23; */
    for (let i = 0; i < message.comments.length; i++)
      Comment.internalBinaryWrite(
        message.comments[i],
        writer.tag(23, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.clinvar_data.clinvar_public.Sample.SourceType source_type = 24; */
    if (message.sourceType !== undefined) writer.tag(24, WireType.Varint).int32(message.sourceType)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.Sample
 */
export const Sample = new Sample$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Sample_SampleDescription$Type extends MessageType<Sample_SampleDescription> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.Sample.SampleDescription', [
      { no: 1, name: 'description', kind: 'message', T: () => Comment },
      { no: 2, name: 'citation', kind: 'message', T: () => Citation }
    ])
  }
  create(value?: PartialMessage<Sample_SampleDescription>): Sample_SampleDescription {
    const message = globalThis.Object.create(this.messagePrototype!)
    if (value !== undefined) reflectionMergePartial<Sample_SampleDescription>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Sample_SampleDescription
  ): Sample_SampleDescription {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional annonars.clinvar_data.clinvar_public.Comment description */ 1:
          message.description = Comment.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.description
          )
          break
        case /* optional annonars.clinvar_data.clinvar_public.Citation citation */ 2:
          message.citation = Citation.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.citation
          )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Sample_SampleDescription,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional annonars.clinvar_data.clinvar_public.Comment description = 1; */
    if (message.description)
      Comment.internalBinaryWrite(
        message.description,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.clinvar_data.clinvar_public.Citation citation = 2; */
    if (message.citation)
      Citation.internalBinaryWrite(
        message.citation,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.Sample.SampleDescription
 */
export const Sample_SampleDescription = new Sample_SampleDescription$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Sample_Age$Type extends MessageType<Sample_Age> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.Sample.Age', [
      { no: 1, name: 'value', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      {
        no: 2,
        name: 'unit',
        kind: 'enum',
        T: () => ['annonars.clinvar_data.clinvar_public.Sample.AgeUnit', Sample_AgeUnit]
      },
      {
        no: 3,
        name: 'type',
        kind: 'enum',
        T: () => ['annonars.clinvar_data.clinvar_public.Sample.AgeType', Sample_AgeType]
      }
    ])
  }
  create(value?: PartialMessage<Sample_Age>): Sample_Age {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.value = 0
    message.unit = 0
    message.type = 0
    if (value !== undefined) reflectionMergePartial<Sample_Age>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Sample_Age
  ): Sample_Age {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* int32 value */ 1:
          message.value = reader.int32()
          break
        case /* annonars.clinvar_data.clinvar_public.Sample.AgeUnit unit */ 2:
          message.unit = reader.int32()
          break
        case /* annonars.clinvar_data.clinvar_public.Sample.AgeType type */ 3:
          message.type = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Sample_Age,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* int32 value = 1; */
    if (message.value !== 0) writer.tag(1, WireType.Varint).int32(message.value)
    /* annonars.clinvar_data.clinvar_public.Sample.AgeUnit unit = 2; */
    if (message.unit !== 0) writer.tag(2, WireType.Varint).int32(message.unit)
    /* annonars.clinvar_data.clinvar_public.Sample.AgeType type = 3; */
    if (message.type !== 0) writer.tag(3, WireType.Varint).int32(message.type)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.Sample.Age
 */
export const Sample_Age = new Sample_Age$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Method$Type extends MessageType<Method> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.Method', [
      { no: 1, name: 'name_platform', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'type_platform', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'purpose', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      {
        no: 4,
        name: 'result_type',
        kind: 'enum',
        opt: true,
        T: () => ['annonars.clinvar_data.clinvar_public.Method.ResultType', Method_ResultType]
      },
      { no: 5, name: 'min_reported', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 6, name: 'max_reported', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 7, name: 'reference_standard', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      {
        no: 8,
        name: 'citations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Citation
      },
      { no: 9, name: 'xrefs', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Xref },
      { no: 10, name: 'description', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      {
        no: 11,
        name: 'software',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Software
      },
      {
        no: 12,
        name: 'source_type',
        kind: 'enum',
        opt: true,
        T: () => ['annonars.clinvar_data.clinvar_public.Method.SourceType', Method_SourceType]
      },
      {
        no: 13,
        name: 'method_type',
        kind: 'enum',
        T: () => ['annonars.clinvar_data.clinvar_public.MethodListType', MethodListType]
      },
      {
        no: 14,
        name: 'method_attributes',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Method_MethodAttribute
      },
      {
        no: 15,
        name: 'obs_method_attributes',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Method_ObsMethodAttribute
      }
    ])
  }
  create(value?: PartialMessage<Method>): Method {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.citations = []
    message.xrefs = []
    message.software = []
    message.methodType = 0
    message.methodAttributes = []
    message.obsMethodAttributes = []
    if (value !== undefined) reflectionMergePartial<Method>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Method
  ): Method {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional string name_platform */ 1:
          message.namePlatform = reader.string()
          break
        case /* optional string type_platform */ 2:
          message.typePlatform = reader.string()
          break
        case /* optional string purpose */ 3:
          message.purpose = reader.string()
          break
        case /* optional annonars.clinvar_data.clinvar_public.Method.ResultType result_type */ 4:
          message.resultType = reader.int32()
          break
        case /* optional string min_reported */ 5:
          message.minReported = reader.string()
          break
        case /* optional string max_reported */ 6:
          message.maxReported = reader.string()
          break
        case /* optional string reference_standard */ 7:
          message.referenceStandard = reader.string()
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Citation citations */ 8:
          message.citations.push(Citation.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs */ 9:
          message.xrefs.push(Xref.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* optional string description */ 10:
          message.description = reader.string()
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Software software */ 11:
          message.software.push(Software.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* optional annonars.clinvar_data.clinvar_public.Method.SourceType source_type */ 12:
          message.sourceType = reader.int32()
          break
        case /* annonars.clinvar_data.clinvar_public.MethodListType method_type */ 13:
          message.methodType = reader.int32()
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Method.MethodAttribute method_attributes */ 14:
          message.methodAttributes.push(
            Method_MethodAttribute.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Method.ObsMethodAttribute obs_method_attributes */ 15:
          message.obsMethodAttributes.push(
            Method_ObsMethodAttribute.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Method,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional string name_platform = 1; */
    if (message.namePlatform !== undefined)
      writer.tag(1, WireType.LengthDelimited).string(message.namePlatform)
    /* optional string type_platform = 2; */
    if (message.typePlatform !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.typePlatform)
    /* optional string purpose = 3; */
    if (message.purpose !== undefined)
      writer.tag(3, WireType.LengthDelimited).string(message.purpose)
    /* optional annonars.clinvar_data.clinvar_public.Method.ResultType result_type = 4; */
    if (message.resultType !== undefined) writer.tag(4, WireType.Varint).int32(message.resultType)
    /* optional string min_reported = 5; */
    if (message.minReported !== undefined)
      writer.tag(5, WireType.LengthDelimited).string(message.minReported)
    /* optional string max_reported = 6; */
    if (message.maxReported !== undefined)
      writer.tag(6, WireType.LengthDelimited).string(message.maxReported)
    /* optional string reference_standard = 7; */
    if (message.referenceStandard !== undefined)
      writer.tag(7, WireType.LengthDelimited).string(message.referenceStandard)
    /* repeated annonars.clinvar_data.clinvar_public.Citation citations = 8; */
    for (let i = 0; i < message.citations.length; i++)
      Citation.internalBinaryWrite(
        message.citations[i],
        writer.tag(8, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 9; */
    for (let i = 0; i < message.xrefs.length; i++)
      Xref.internalBinaryWrite(
        message.xrefs[i],
        writer.tag(9, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional string description = 10; */
    if (message.description !== undefined)
      writer.tag(10, WireType.LengthDelimited).string(message.description)
    /* repeated annonars.clinvar_data.clinvar_public.Software software = 11; */
    for (let i = 0; i < message.software.length; i++)
      Software.internalBinaryWrite(
        message.software[i],
        writer.tag(11, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.clinvar_data.clinvar_public.Method.SourceType source_type = 12; */
    if (message.sourceType !== undefined) writer.tag(12, WireType.Varint).int32(message.sourceType)
    /* annonars.clinvar_data.clinvar_public.MethodListType method_type = 13; */
    if (message.methodType !== 0) writer.tag(13, WireType.Varint).int32(message.methodType)
    /* repeated annonars.clinvar_data.clinvar_public.Method.MethodAttribute method_attributes = 14; */
    for (let i = 0; i < message.methodAttributes.length; i++)
      Method_MethodAttribute.internalBinaryWrite(
        message.methodAttributes[i],
        writer.tag(14, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Method.ObsMethodAttribute obs_method_attributes = 15; */
    for (let i = 0; i < message.obsMethodAttributes.length; i++)
      Method_ObsMethodAttribute.internalBinaryWrite(
        message.obsMethodAttributes[i],
        writer.tag(15, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.Method
 */
export const Method = new Method$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Method_MethodAttribute$Type extends MessageType<Method_MethodAttribute> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.Method.MethodAttribute', [
      { no: 1, name: 'base', kind: 'message', T: () => BaseAttribute },
      {
        no: 2,
        name: 'type',
        kind: 'enum',
        T: () => [
          'annonars.clinvar_data.clinvar_public.Method.MethodAttribute.AttributeType',
          Method_MethodAttribute_AttributeType
        ]
      }
    ])
  }
  create(value?: PartialMessage<Method_MethodAttribute>): Method_MethodAttribute {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.type = 0
    if (value !== undefined) reflectionMergePartial<Method_MethodAttribute>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Method_MethodAttribute
  ): Method_MethodAttribute {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* annonars.clinvar_data.clinvar_public.BaseAttribute base */ 1:
          message.base = BaseAttribute.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.base
          )
          break
        case /* annonars.clinvar_data.clinvar_public.Method.MethodAttribute.AttributeType type */ 2:
          message.type = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Method_MethodAttribute,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* annonars.clinvar_data.clinvar_public.BaseAttribute base = 1; */
    if (message.base)
      BaseAttribute.internalBinaryWrite(
        message.base,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.clinvar_data.clinvar_public.Method.MethodAttribute.AttributeType type = 2; */
    if (message.type !== 0) writer.tag(2, WireType.Varint).int32(message.type)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.Method.MethodAttribute
 */
export const Method_MethodAttribute = new Method_MethodAttribute$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Method_ObsMethodAttribute$Type extends MessageType<Method_ObsMethodAttribute> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.Method.ObsMethodAttribute', [
      { no: 1, name: 'base', kind: 'message', T: () => BaseAttribute },
      {
        no: 2,
        name: 'type',
        kind: 'enum',
        T: () => [
          'annonars.clinvar_data.clinvar_public.Method.ObsMethodAttribute.AttributeType',
          Method_ObsMethodAttribute_AttributeType
        ]
      },
      {
        no: 3,
        name: 'comments',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Comment
      }
    ])
  }
  create(value?: PartialMessage<Method_ObsMethodAttribute>): Method_ObsMethodAttribute {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.type = 0
    message.comments = []
    if (value !== undefined) reflectionMergePartial<Method_ObsMethodAttribute>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Method_ObsMethodAttribute
  ): Method_ObsMethodAttribute {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* annonars.clinvar_data.clinvar_public.BaseAttribute base */ 1:
          message.base = BaseAttribute.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.base
          )
          break
        case /* annonars.clinvar_data.clinvar_public.Method.ObsMethodAttribute.AttributeType type */ 2:
          message.type = reader.int32()
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Comment comments */ 3:
          message.comments.push(Comment.internalBinaryRead(reader, reader.uint32(), options))
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Method_ObsMethodAttribute,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* annonars.clinvar_data.clinvar_public.BaseAttribute base = 1; */
    if (message.base)
      BaseAttribute.internalBinaryWrite(
        message.base,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.clinvar_data.clinvar_public.Method.ObsMethodAttribute.AttributeType type = 2; */
    if (message.type !== 0) writer.tag(2, WireType.Varint).int32(message.type)
    /* repeated annonars.clinvar_data.clinvar_public.Comment comments = 3; */
    for (let i = 0; i < message.comments.length; i++)
      Comment.internalBinaryWrite(
        message.comments[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.Method.ObsMethodAttribute
 */
export const Method_ObsMethodAttribute = new Method_ObsMethodAttribute$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AlleleScv$Type extends MessageType<AlleleScv> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.AlleleScv', [
      {
        no: 1,
        name: 'genes',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => AlleleScv_Gene
      },
      { no: 2, name: 'name', kind: 'message', T: () => OtherName },
      { no: 3, name: 'variant_type', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: 'location', kind: 'message', T: () => Location },
      {
        no: 5,
        name: 'other_names',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => OtherName
      },
      {
        no: 6,
        name: 'protein_changes',
        kind: 'scalar',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/
      },
      { no: 7, name: 'xrefs', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Xref },
      {
        no: 8,
        name: 'citations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Citation
      },
      {
        no: 9,
        name: 'comments',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Comment
      },
      {
        no: 10,
        name: 'molecular_consequences',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => AlleleScv_MolecularConsequence
      },
      {
        no: 11,
        name: 'functional_consequences',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => FunctionalConsequence
      },
      {
        no: 12,
        name: 'attributes',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => AttributeSetElement
      },
      { no: 13, name: 'allele_id', kind: 'scalar', opt: true, T: 3 /*ScalarType.INT64*/ }
    ])
  }
  create(value?: PartialMessage<AlleleScv>): AlleleScv {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.genes = []
    message.otherNames = []
    message.proteinChanges = []
    message.xrefs = []
    message.citations = []
    message.comments = []
    message.molecularConsequences = []
    message.functionalConsequences = []
    message.attributes = []
    if (value !== undefined) reflectionMergePartial<AlleleScv>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AlleleScv
  ): AlleleScv {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated annonars.clinvar_data.clinvar_public.AlleleScv.Gene genes */ 1:
          message.genes.push(AlleleScv_Gene.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* annonars.clinvar_data.clinvar_public.OtherName name */ 2:
          message.name = OtherName.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.name
          )
          break
        case /* optional string variant_type */ 3:
          message.variantType = reader.string()
          break
        case /* optional annonars.clinvar_data.clinvar_public.Location location */ 4:
          message.location = Location.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.location
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.OtherName other_names */ 5:
          message.otherNames.push(OtherName.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated string protein_changes */ 6:
          message.proteinChanges.push(reader.string())
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs */ 7:
          message.xrefs.push(Xref.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Citation citations */ 8:
          message.citations.push(Citation.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Comment comments */ 9:
          message.comments.push(Comment.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.AlleleScv.MolecularConsequence molecular_consequences */ 10:
          message.molecularConsequences.push(
            AlleleScv_MolecularConsequence.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.FunctionalConsequence functional_consequences */ 11:
          message.functionalConsequences.push(
            FunctionalConsequence.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.AttributeSetElement attributes */ 12:
          message.attributes.push(
            AttributeSetElement.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* optional int64 allele_id */ 13:
          message.alleleId = reader.int64().toString()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: AlleleScv,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated annonars.clinvar_data.clinvar_public.AlleleScv.Gene genes = 1; */
    for (let i = 0; i < message.genes.length; i++)
      AlleleScv_Gene.internalBinaryWrite(
        message.genes[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.clinvar_data.clinvar_public.OtherName name = 2; */
    if (message.name)
      OtherName.internalBinaryWrite(
        message.name,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional string variant_type = 3; */
    if (message.variantType !== undefined)
      writer.tag(3, WireType.LengthDelimited).string(message.variantType)
    /* optional annonars.clinvar_data.clinvar_public.Location location = 4; */
    if (message.location)
      Location.internalBinaryWrite(
        message.location,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.OtherName other_names = 5; */
    for (let i = 0; i < message.otherNames.length; i++)
      OtherName.internalBinaryWrite(
        message.otherNames[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated string protein_changes = 6; */
    for (let i = 0; i < message.proteinChanges.length; i++)
      writer.tag(6, WireType.LengthDelimited).string(message.proteinChanges[i])
    /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 7; */
    for (let i = 0; i < message.xrefs.length; i++)
      Xref.internalBinaryWrite(
        message.xrefs[i],
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Citation citations = 8; */
    for (let i = 0; i < message.citations.length; i++)
      Citation.internalBinaryWrite(
        message.citations[i],
        writer.tag(8, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Comment comments = 9; */
    for (let i = 0; i < message.comments.length; i++)
      Comment.internalBinaryWrite(
        message.comments[i],
        writer.tag(9, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.AlleleScv.MolecularConsequence molecular_consequences = 10; */
    for (let i = 0; i < message.molecularConsequences.length; i++)
      AlleleScv_MolecularConsequence.internalBinaryWrite(
        message.molecularConsequences[i],
        writer.tag(10, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.FunctionalConsequence functional_consequences = 11; */
    for (let i = 0; i < message.functionalConsequences.length; i++)
      FunctionalConsequence.internalBinaryWrite(
        message.functionalConsequences[i],
        writer.tag(11, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.AttributeSetElement attributes = 12; */
    for (let i = 0; i < message.attributes.length; i++)
      AttributeSetElement.internalBinaryWrite(
        message.attributes[i],
        writer.tag(12, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional int64 allele_id = 13; */
    if (message.alleleId !== undefined) writer.tag(13, WireType.Varint).int64(message.alleleId)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.AlleleScv
 */
export const AlleleScv = new AlleleScv$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AlleleScv_Gene$Type extends MessageType<AlleleScv_Gene> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.AlleleScv.Gene', [
      { no: 1, name: 'name', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: 'properties',
        kind: 'scalar',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/
      },
      { no: 3, name: 'xrefs', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Xref },
      { no: 4, name: 'symbol', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      {
        no: 5,
        name: 'relationship_type',
        kind: 'enum',
        opt: true,
        T: () => [
          'annonars.clinvar_data.clinvar_public.GeneVariantRelationship',
          GeneVariantRelationship
        ]
      }
    ])
  }
  create(value?: PartialMessage<AlleleScv_Gene>): AlleleScv_Gene {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.properties = []
    message.xrefs = []
    if (value !== undefined) reflectionMergePartial<AlleleScv_Gene>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AlleleScv_Gene
  ): AlleleScv_Gene {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional string name */ 1:
          message.name = reader.string()
          break
        case /* repeated string properties */ 2:
          message.properties.push(reader.string())
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs */ 3:
          message.xrefs.push(Xref.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* optional string symbol */ 4:
          message.symbol = reader.string()
          break
        case /* optional annonars.clinvar_data.clinvar_public.GeneVariantRelationship relationship_type */ 5:
          message.relationshipType = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: AlleleScv_Gene,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional string name = 1; */
    if (message.name !== undefined) writer.tag(1, WireType.LengthDelimited).string(message.name)
    /* repeated string properties = 2; */
    for (let i = 0; i < message.properties.length; i++)
      writer.tag(2, WireType.LengthDelimited).string(message.properties[i])
    /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 3; */
    for (let i = 0; i < message.xrefs.length; i++)
      Xref.internalBinaryWrite(
        message.xrefs[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional string symbol = 4; */
    if (message.symbol !== undefined) writer.tag(4, WireType.LengthDelimited).string(message.symbol)
    /* optional annonars.clinvar_data.clinvar_public.GeneVariantRelationship relationship_type = 5; */
    if (message.relationshipType !== undefined)
      writer.tag(5, WireType.Varint).int32(message.relationshipType)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.AlleleScv.Gene
 */
export const AlleleScv_Gene = new AlleleScv_Gene$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AlleleScv_MolecularConsequence$Type extends MessageType<AlleleScv_MolecularConsequence> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.AlleleScv.MolecularConsequence', [
      { no: 1, name: 'xrefs', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Xref },
      {
        no: 2,
        name: 'citations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Citation
      },
      {
        no: 3,
        name: 'comments',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Comment
      },
      { no: 4, name: 'rs', kind: 'scalar', opt: true, T: 3 /*ScalarType.INT64*/ },
      { no: 5, name: 'hgvs', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 6, name: 'so_id', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 7, name: 'function', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(value?: PartialMessage<AlleleScv_MolecularConsequence>): AlleleScv_MolecularConsequence {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.xrefs = []
    message.citations = []
    message.comments = []
    message.function = ''
    if (value !== undefined)
      reflectionMergePartial<AlleleScv_MolecularConsequence>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AlleleScv_MolecularConsequence
  ): AlleleScv_MolecularConsequence {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs */ 1:
          message.xrefs.push(Xref.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Citation citations */ 2:
          message.citations.push(Citation.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Comment comments */ 3:
          message.comments.push(Comment.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* optional int64 rs */ 4:
          message.rs = reader.int64().toString()
          break
        case /* optional string hgvs */ 5:
          message.hgvs = reader.string()
          break
        case /* optional string so_id */ 6:
          message.soId = reader.string()
          break
        case /* string function */ 7:
          message.function = reader.string()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: AlleleScv_MolecularConsequence,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 1; */
    for (let i = 0; i < message.xrefs.length; i++)
      Xref.internalBinaryWrite(
        message.xrefs[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Citation citations = 2; */
    for (let i = 0; i < message.citations.length; i++)
      Citation.internalBinaryWrite(
        message.citations[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Comment comments = 3; */
    for (let i = 0; i < message.comments.length; i++)
      Comment.internalBinaryWrite(
        message.comments[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional int64 rs = 4; */
    if (message.rs !== undefined) writer.tag(4, WireType.Varint).int64(message.rs)
    /* optional string hgvs = 5; */
    if (message.hgvs !== undefined) writer.tag(5, WireType.LengthDelimited).string(message.hgvs)
    /* optional string so_id = 6; */
    if (message.soId !== undefined) writer.tag(6, WireType.LengthDelimited).string(message.soId)
    /* string function = 7; */
    if (message.function !== '') writer.tag(7, WireType.LengthDelimited).string(message.function)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.AlleleScv.MolecularConsequence
 */
export const AlleleScv_MolecularConsequence = new AlleleScv_MolecularConsequence$Type()
// @generated message type with reflection information, may provide speed optimized methods
class HaplotypeScv$Type extends MessageType<HaplotypeScv> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.HaplotypeScv', [
      {
        no: 1,
        name: 'simple_alleles',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => AlleleScv
      },
      { no: 2, name: 'name', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: 'other_names',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => OtherName
      },
      { no: 4, name: 'classifications', kind: 'message', T: () => AggregateClassificationSet },
      {
        no: 5,
        name: 'functional_consequences',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => FunctionalConsequence
      },
      {
        no: 6,
        name: 'attributes',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => AttributeSetElement
      },
      {
        no: 7,
        name: 'citations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Citation
      },
      { no: 8, name: 'xrefs', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Xref },
      {
        no: 9,
        name: 'comments',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Comment
      },
      { no: 10, name: 'variation_id', kind: 'scalar', opt: true, T: 3 /*ScalarType.INT64*/ },
      { no: 11, name: 'number_of_copies', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      {
        no: 12,
        name: 'number_of_chromosomes',
        kind: 'scalar',
        opt: true,
        T: 5 /*ScalarType.INT32*/
      }
    ])
  }
  create(value?: PartialMessage<HaplotypeScv>): HaplotypeScv {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.simpleAlleles = []
    message.otherNames = []
    message.functionalConsequences = []
    message.attributes = []
    message.citations = []
    message.xrefs = []
    message.comments = []
    if (value !== undefined) reflectionMergePartial<HaplotypeScv>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: HaplotypeScv
  ): HaplotypeScv {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated annonars.clinvar_data.clinvar_public.AlleleScv simple_alleles */ 1:
          message.simpleAlleles.push(AlleleScv.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* optional string name */ 2:
          message.name = reader.string()
          break
        case /* repeated annonars.clinvar_data.clinvar_public.OtherName other_names */ 3:
          message.otherNames.push(OtherName.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* optional annonars.clinvar_data.clinvar_public.AggregateClassificationSet classifications */ 4:
          message.classifications = AggregateClassificationSet.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.classifications
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.FunctionalConsequence functional_consequences */ 5:
          message.functionalConsequences.push(
            FunctionalConsequence.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.AttributeSetElement attributes */ 6:
          message.attributes.push(
            AttributeSetElement.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Citation citations */ 7:
          message.citations.push(Citation.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs */ 8:
          message.xrefs.push(Xref.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Comment comments */ 9:
          message.comments.push(Comment.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* optional int64 variation_id */ 10:
          message.variationId = reader.int64().toString()
          break
        case /* optional int32 number_of_copies */ 11:
          message.numberOfCopies = reader.int32()
          break
        case /* optional int32 number_of_chromosomes */ 12:
          message.numberOfChromosomes = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: HaplotypeScv,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated annonars.clinvar_data.clinvar_public.AlleleScv simple_alleles = 1; */
    for (let i = 0; i < message.simpleAlleles.length; i++)
      AlleleScv.internalBinaryWrite(
        message.simpleAlleles[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional string name = 2; */
    if (message.name !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.name)
    /* repeated annonars.clinvar_data.clinvar_public.OtherName other_names = 3; */
    for (let i = 0; i < message.otherNames.length; i++)
      OtherName.internalBinaryWrite(
        message.otherNames[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.clinvar_data.clinvar_public.AggregateClassificationSet classifications = 4; */
    if (message.classifications)
      AggregateClassificationSet.internalBinaryWrite(
        message.classifications,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.FunctionalConsequence functional_consequences = 5; */
    for (let i = 0; i < message.functionalConsequences.length; i++)
      FunctionalConsequence.internalBinaryWrite(
        message.functionalConsequences[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.AttributeSetElement attributes = 6; */
    for (let i = 0; i < message.attributes.length; i++)
      AttributeSetElement.internalBinaryWrite(
        message.attributes[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Citation citations = 7; */
    for (let i = 0; i < message.citations.length; i++)
      Citation.internalBinaryWrite(
        message.citations[i],
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 8; */
    for (let i = 0; i < message.xrefs.length; i++)
      Xref.internalBinaryWrite(
        message.xrefs[i],
        writer.tag(8, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Comment comments = 9; */
    for (let i = 0; i < message.comments.length; i++)
      Comment.internalBinaryWrite(
        message.comments[i],
        writer.tag(9, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional int64 variation_id = 10; */
    if (message.variationId !== undefined)
      writer.tag(10, WireType.Varint).int64(message.variationId)
    /* optional int32 number_of_copies = 11; */
    if (message.numberOfCopies !== undefined)
      writer.tag(11, WireType.Varint).int32(message.numberOfCopies)
    /* optional int32 number_of_chromosomes = 12; */
    if (message.numberOfChromosomes !== undefined)
      writer.tag(12, WireType.Varint).int32(message.numberOfChromosomes)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.HaplotypeScv
 */
export const HaplotypeScv = new HaplotypeScv$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GenotypeScv$Type extends MessageType<GenotypeScv> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.GenotypeScv', [
      {
        no: 1,
        name: 'simple_alleles',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => AlleleScv
      },
      {
        no: 2,
        name: 'haplotypes',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => HaplotypeScv
      },
      { no: 3, name: 'name', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      {
        no: 4,
        name: 'other_names',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => OtherName
      },
      {
        no: 5,
        name: 'variation_type',
        kind: 'enum',
        T: () => ['annonars.clinvar_data.clinvar_public.VariationType', VariationType]
      },
      {
        no: 6,
        name: 'functional_consequences',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => FunctionalConsequence
      },
      {
        no: 7,
        name: 'attributes',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => AttributeSetElement
      },
      {
        no: 8,
        name: 'citations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Citation
      },
      { no: 9, name: 'xrefs', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Xref },
      {
        no: 10,
        name: 'comments',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Comment
      },
      { no: 11, name: 'variation_id', kind: 'scalar', opt: true, T: 3 /*ScalarType.INT64*/ }
    ])
  }
  create(value?: PartialMessage<GenotypeScv>): GenotypeScv {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.simpleAlleles = []
    message.haplotypes = []
    message.otherNames = []
    message.variationType = 0
    message.functionalConsequences = []
    message.attributes = []
    message.citations = []
    message.xrefs = []
    message.comments = []
    if (value !== undefined) reflectionMergePartial<GenotypeScv>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GenotypeScv
  ): GenotypeScv {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated annonars.clinvar_data.clinvar_public.AlleleScv simple_alleles */ 1:
          message.simpleAlleles.push(AlleleScv.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.HaplotypeScv haplotypes */ 2:
          message.haplotypes.push(HaplotypeScv.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* optional string name */ 3:
          message.name = reader.string()
          break
        case /* repeated annonars.clinvar_data.clinvar_public.OtherName other_names */ 4:
          message.otherNames.push(OtherName.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* annonars.clinvar_data.clinvar_public.VariationType variation_type */ 5:
          message.variationType = reader.int32()
          break
        case /* repeated annonars.clinvar_data.clinvar_public.FunctionalConsequence functional_consequences */ 6:
          message.functionalConsequences.push(
            FunctionalConsequence.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.AttributeSetElement attributes */ 7:
          message.attributes.push(
            AttributeSetElement.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Citation citations */ 8:
          message.citations.push(Citation.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs */ 9:
          message.xrefs.push(Xref.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Comment comments */ 10:
          message.comments.push(Comment.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* optional int64 variation_id */ 11:
          message.variationId = reader.int64().toString()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: GenotypeScv,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated annonars.clinvar_data.clinvar_public.AlleleScv simple_alleles = 1; */
    for (let i = 0; i < message.simpleAlleles.length; i++)
      AlleleScv.internalBinaryWrite(
        message.simpleAlleles[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.HaplotypeScv haplotypes = 2; */
    for (let i = 0; i < message.haplotypes.length; i++)
      HaplotypeScv.internalBinaryWrite(
        message.haplotypes[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional string name = 3; */
    if (message.name !== undefined) writer.tag(3, WireType.LengthDelimited).string(message.name)
    /* repeated annonars.clinvar_data.clinvar_public.OtherName other_names = 4; */
    for (let i = 0; i < message.otherNames.length; i++)
      OtherName.internalBinaryWrite(
        message.otherNames[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.clinvar_data.clinvar_public.VariationType variation_type = 5; */
    if (message.variationType !== 0) writer.tag(5, WireType.Varint).int32(message.variationType)
    /* repeated annonars.clinvar_data.clinvar_public.FunctionalConsequence functional_consequences = 6; */
    for (let i = 0; i < message.functionalConsequences.length; i++)
      FunctionalConsequence.internalBinaryWrite(
        message.functionalConsequences[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.AttributeSetElement attributes = 7; */
    for (let i = 0; i < message.attributes.length; i++)
      AttributeSetElement.internalBinaryWrite(
        message.attributes[i],
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Citation citations = 8; */
    for (let i = 0; i < message.citations.length; i++)
      Citation.internalBinaryWrite(
        message.citations[i],
        writer.tag(8, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 9; */
    for (let i = 0; i < message.xrefs.length; i++)
      Xref.internalBinaryWrite(
        message.xrefs[i],
        writer.tag(9, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Comment comments = 10; */
    for (let i = 0; i < message.comments.length; i++)
      Comment.internalBinaryWrite(
        message.comments[i],
        writer.tag(10, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional int64 variation_id = 11; */
    if (message.variationId !== undefined)
      writer.tag(11, WireType.Varint).int64(message.variationId)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.GenotypeScv
 */
export const GenotypeScv = new GenotypeScv$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ObservedIn$Type extends MessageType<ObservedIn> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.ObservedIn', [
      { no: 1, name: 'sample', kind: 'message', T: () => Sample },
      {
        no: 2,
        name: 'observed_data',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => ObservedIn_ObservedData
      },
      {
        no: 3,
        name: 'cooccurrence_sets',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Cooccurrence
      },
      { no: 4, name: 'trait_set', kind: 'message', T: () => TraitSet },
      {
        no: 5,
        name: 'citations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Citation
      },
      { no: 6, name: 'xrefs', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Xref },
      {
        no: 7,
        name: 'comments',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Comment
      }
    ])
  }
  create(value?: PartialMessage<ObservedIn>): ObservedIn {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.observedData = []
    message.cooccurrenceSets = []
    message.citations = []
    message.xrefs = []
    message.comments = []
    if (value !== undefined) reflectionMergePartial<ObservedIn>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ObservedIn
  ): ObservedIn {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* annonars.clinvar_data.clinvar_public.Sample sample */ 1:
          message.sample = Sample.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.sample
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.ObservedIn.ObservedData observed_data */ 2:
          message.observedData.push(
            ObservedIn_ObservedData.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Cooccurrence cooccurrence_sets */ 3:
          message.cooccurrenceSets.push(
            Cooccurrence.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* optional annonars.clinvar_data.clinvar_public.TraitSet trait_set */ 4:
          message.traitSet = TraitSet.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.traitSet
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Citation citations */ 5:
          message.citations.push(Citation.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs */ 6:
          message.xrefs.push(Xref.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Comment comments */ 7:
          message.comments.push(Comment.internalBinaryRead(reader, reader.uint32(), options))
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ObservedIn,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* annonars.clinvar_data.clinvar_public.Sample sample = 1; */
    if (message.sample)
      Sample.internalBinaryWrite(
        message.sample,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.ObservedIn.ObservedData observed_data = 2; */
    for (let i = 0; i < message.observedData.length; i++)
      ObservedIn_ObservedData.internalBinaryWrite(
        message.observedData[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Cooccurrence cooccurrence_sets = 3; */
    for (let i = 0; i < message.cooccurrenceSets.length; i++)
      Cooccurrence.internalBinaryWrite(
        message.cooccurrenceSets[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.clinvar_data.clinvar_public.TraitSet trait_set = 4; */
    if (message.traitSet)
      TraitSet.internalBinaryWrite(
        message.traitSet,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Citation citations = 5; */
    for (let i = 0; i < message.citations.length; i++)
      Citation.internalBinaryWrite(
        message.citations[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 6; */
    for (let i = 0; i < message.xrefs.length; i++)
      Xref.internalBinaryWrite(
        message.xrefs[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Comment comments = 7; */
    for (let i = 0; i < message.comments.length; i++)
      Comment.internalBinaryWrite(
        message.comments[i],
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.ObservedIn
 */
export const ObservedIn = new ObservedIn$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ObservedIn_ObservedDataAttribute$Type extends MessageType<ObservedIn_ObservedDataAttribute> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.ObservedIn.ObservedDataAttribute', [
      { no: 1, name: 'base', kind: 'message', T: () => BaseAttribute },
      {
        no: 2,
        name: 'type',
        kind: 'enum',
        T: () => [
          'annonars.clinvar_data.clinvar_public.ObservedIn.ObservedDataAttribute.Type',
          ObservedIn_ObservedDataAttribute_Type
        ]
      }
    ])
  }
  create(
    value?: PartialMessage<ObservedIn_ObservedDataAttribute>
  ): ObservedIn_ObservedDataAttribute {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.type = 0
    if (value !== undefined)
      reflectionMergePartial<ObservedIn_ObservedDataAttribute>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ObservedIn_ObservedDataAttribute
  ): ObservedIn_ObservedDataAttribute {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* annonars.clinvar_data.clinvar_public.BaseAttribute base */ 1:
          message.base = BaseAttribute.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.base
          )
          break
        case /* annonars.clinvar_data.clinvar_public.ObservedIn.ObservedDataAttribute.Type type */ 2:
          message.type = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ObservedIn_ObservedDataAttribute,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* annonars.clinvar_data.clinvar_public.BaseAttribute base = 1; */
    if (message.base)
      BaseAttribute.internalBinaryWrite(
        message.base,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.clinvar_data.clinvar_public.ObservedIn.ObservedDataAttribute.Type type = 2; */
    if (message.type !== 0) writer.tag(2, WireType.Varint).int32(message.type)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.ObservedIn.ObservedDataAttribute
 */
export const ObservedIn_ObservedDataAttribute = new ObservedIn_ObservedDataAttribute$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ObservedIn_ObservedData$Type extends MessageType<ObservedIn_ObservedData> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.ObservedIn.ObservedData', [
      {
        no: 1,
        name: 'attributes',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => ObservedIn_ObservedDataAttribute
      },
      {
        no: 2,
        name: 'severity',
        kind: 'enum',
        opt: true,
        T: () => ['annonars.clinvar_data.clinvar_public.Severity', Severity]
      },
      {
        no: 3,
        name: 'citations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Citation
      },
      { no: 4, name: 'xrefs', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Xref },
      {
        no: 5,
        name: 'comments',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Comment
      }
    ])
  }
  create(value?: PartialMessage<ObservedIn_ObservedData>): ObservedIn_ObservedData {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.attributes = []
    message.citations = []
    message.xrefs = []
    message.comments = []
    if (value !== undefined) reflectionMergePartial<ObservedIn_ObservedData>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ObservedIn_ObservedData
  ): ObservedIn_ObservedData {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated annonars.clinvar_data.clinvar_public.ObservedIn.ObservedDataAttribute attributes */ 1:
          message.attributes.push(
            ObservedIn_ObservedDataAttribute.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* optional annonars.clinvar_data.clinvar_public.Severity severity */ 2:
          message.severity = reader.int32()
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Citation citations */ 3:
          message.citations.push(Citation.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs */ 4:
          message.xrefs.push(Xref.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Comment comments */ 5:
          message.comments.push(Comment.internalBinaryRead(reader, reader.uint32(), options))
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ObservedIn_ObservedData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated annonars.clinvar_data.clinvar_public.ObservedIn.ObservedDataAttribute attributes = 1; */
    for (let i = 0; i < message.attributes.length; i++)
      ObservedIn_ObservedDataAttribute.internalBinaryWrite(
        message.attributes[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.clinvar_data.clinvar_public.Severity severity = 2; */
    if (message.severity !== undefined) writer.tag(2, WireType.Varint).int32(message.severity)
    /* repeated annonars.clinvar_data.clinvar_public.Citation citations = 3; */
    for (let i = 0; i < message.citations.length; i++)
      Citation.internalBinaryWrite(
        message.citations[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 4; */
    for (let i = 0; i < message.xrefs.length; i++)
      Xref.internalBinaryWrite(
        message.xrefs[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Comment comments = 5; */
    for (let i = 0; i < message.comments.length; i++)
      Comment.internalBinaryWrite(
        message.comments[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.ObservedIn.ObservedData
 */
export const ObservedIn_ObservedData = new ObservedIn_ObservedData$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ClinicalAssertion$Type extends MessageType<ClinicalAssertion> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.ClinicalAssertion', [
      {
        no: 1,
        name: 'clinvar_submission_id',
        kind: 'message',
        T: () => ClinicalAssertion_ClinvarSubmissionId
      },
      {
        no: 2,
        name: 'clinvar_accession',
        kind: 'message',
        T: () => ClinicalAssertion_ClinvarAccession
      },
      {
        no: 3,
        name: 'additional_submitters',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Submitter
      },
      {
        no: 4,
        name: 'record_status',
        kind: 'enum',
        T: () => [
          'annonars.clinvar_data.clinvar_public.ClinicalAssertion.RecordStatus',
          ClinicalAssertion_RecordStatus
        ]
      },
      {
        no: 5,
        name: 'replaces',
        kind: 'scalar',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: 'replaceds',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => ClinicalAssertionRecordHistory
      },
      { no: 7, name: 'classifications', kind: 'message', T: () => ClassificationScv },
      {
        no: 8,
        name: 'assertion',
        kind: 'enum',
        T: () => ['annonars.clinvar_data.clinvar_public.Assertion', Assertion]
      },
      {
        no: 9,
        name: 'attributes',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => ClinicalAssertion_AttributeSetElement
      },
      {
        no: 10,
        name: 'observed_ins',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => ObservedIn
      },
      { no: 11, name: 'simple_allele', kind: 'message', T: () => AlleleScv },
      { no: 12, name: 'haplotype', kind: 'message', T: () => HaplotypeScv },
      { no: 13, name: 'genotype', kind: 'message', T: () => GenotypeScv },
      { no: 14, name: 'trait_set', kind: 'message', T: () => TraitSet },
      {
        no: 15,
        name: 'citations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Citation
      },
      { no: 16, name: 'study_name', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 17, name: 'study_description', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      {
        no: 18,
        name: 'comments',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Comment
      },
      {
        no: 19,
        name: 'submission_names',
        kind: 'scalar',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/
      },
      { no: 20, name: 'date_created', kind: 'message', T: () => Timestamp },
      { no: 21, name: 'date_last_updated', kind: 'message', T: () => Timestamp },
      { no: 22, name: 'submission_date', kind: 'message', T: () => Timestamp },
      { no: 23, name: 'id', kind: 'scalar', opt: true, T: 4 /*ScalarType.UINT64*/ },
      {
        no: 24,
        name: 'fda_recognized_database',
        kind: 'scalar',
        opt: true,
        T: 8 /*ScalarType.BOOL*/
      }
    ])
  }
  create(value?: PartialMessage<ClinicalAssertion>): ClinicalAssertion {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.additionalSubmitters = []
    message.recordStatus = 0
    message.replaces = []
    message.replaceds = []
    message.assertion = 0
    message.attributes = []
    message.observedIns = []
    message.citations = []
    message.comments = []
    message.submissionNames = []
    if (value !== undefined) reflectionMergePartial<ClinicalAssertion>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ClinicalAssertion
  ): ClinicalAssertion {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* annonars.clinvar_data.clinvar_public.ClinicalAssertion.ClinvarSubmissionId clinvar_submission_id */ 1:
          message.clinvarSubmissionId = ClinicalAssertion_ClinvarSubmissionId.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.clinvarSubmissionId
          )
          break
        case /* annonars.clinvar_data.clinvar_public.ClinicalAssertion.ClinvarAccession clinvar_accession */ 2:
          message.clinvarAccession = ClinicalAssertion_ClinvarAccession.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.clinvarAccession
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Submitter additional_submitters */ 3:
          message.additionalSubmitters.push(
            Submitter.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* annonars.clinvar_data.clinvar_public.ClinicalAssertion.RecordStatus record_status */ 4:
          message.recordStatus = reader.int32()
          break
        case /* repeated string replaces */ 5:
          message.replaces.push(reader.string())
          break
        case /* repeated annonars.clinvar_data.clinvar_public.ClinicalAssertionRecordHistory replaceds */ 6:
          message.replaceds.push(
            ClinicalAssertionRecordHistory.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* annonars.clinvar_data.clinvar_public.ClassificationScv classifications */ 7:
          message.classifications = ClassificationScv.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.classifications
          )
          break
        case /* annonars.clinvar_data.clinvar_public.Assertion assertion */ 8:
          message.assertion = reader.int32()
          break
        case /* repeated annonars.clinvar_data.clinvar_public.ClinicalAssertion.AttributeSetElement attributes */ 9:
          message.attributes.push(
            ClinicalAssertion_AttributeSetElement.internalBinaryRead(
              reader,
              reader.uint32(),
              options
            )
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.ObservedIn observed_ins */ 10:
          message.observedIns.push(ObservedIn.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* optional annonars.clinvar_data.clinvar_public.AlleleScv simple_allele */ 11:
          message.simpleAllele = AlleleScv.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.simpleAllele
          )
          break
        case /* optional annonars.clinvar_data.clinvar_public.HaplotypeScv haplotype */ 12:
          message.haplotype = HaplotypeScv.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.haplotype
          )
          break
        case /* optional annonars.clinvar_data.clinvar_public.GenotypeScv genotype */ 13:
          message.genotype = GenotypeScv.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.genotype
          )
          break
        case /* annonars.clinvar_data.clinvar_public.TraitSet trait_set */ 14:
          message.traitSet = TraitSet.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.traitSet
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Citation citations */ 15:
          message.citations.push(Citation.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* optional string study_name */ 16:
          message.studyName = reader.string()
          break
        case /* optional string study_description */ 17:
          message.studyDescription = reader.string()
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Comment comments */ 18:
          message.comments.push(Comment.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated string submission_names */ 19:
          message.submissionNames.push(reader.string())
          break
        case /* google.protobuf.Timestamp date_created */ 20:
          message.dateCreated = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.dateCreated
          )
          break
        case /* google.protobuf.Timestamp date_last_updated */ 21:
          message.dateLastUpdated = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.dateLastUpdated
          )
          break
        case /* google.protobuf.Timestamp submission_date */ 22:
          message.submissionDate = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.submissionDate
          )
          break
        case /* optional uint64 id */ 23:
          message.id = reader.uint64().toString()
          break
        case /* optional bool fda_recognized_database */ 24:
          message.fdaRecognizedDatabase = reader.bool()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ClinicalAssertion,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* annonars.clinvar_data.clinvar_public.ClinicalAssertion.ClinvarSubmissionId clinvar_submission_id = 1; */
    if (message.clinvarSubmissionId)
      ClinicalAssertion_ClinvarSubmissionId.internalBinaryWrite(
        message.clinvarSubmissionId,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.clinvar_data.clinvar_public.ClinicalAssertion.ClinvarAccession clinvar_accession = 2; */
    if (message.clinvarAccession)
      ClinicalAssertion_ClinvarAccession.internalBinaryWrite(
        message.clinvarAccession,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Submitter additional_submitters = 3; */
    for (let i = 0; i < message.additionalSubmitters.length; i++)
      Submitter.internalBinaryWrite(
        message.additionalSubmitters[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.clinvar_data.clinvar_public.ClinicalAssertion.RecordStatus record_status = 4; */
    if (message.recordStatus !== 0) writer.tag(4, WireType.Varint).int32(message.recordStatus)
    /* repeated string replaces = 5; */
    for (let i = 0; i < message.replaces.length; i++)
      writer.tag(5, WireType.LengthDelimited).string(message.replaces[i])
    /* repeated annonars.clinvar_data.clinvar_public.ClinicalAssertionRecordHistory replaceds = 6; */
    for (let i = 0; i < message.replaceds.length; i++)
      ClinicalAssertionRecordHistory.internalBinaryWrite(
        message.replaceds[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.clinvar_data.clinvar_public.ClassificationScv classifications = 7; */
    if (message.classifications)
      ClassificationScv.internalBinaryWrite(
        message.classifications,
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.clinvar_data.clinvar_public.Assertion assertion = 8; */
    if (message.assertion !== 0) writer.tag(8, WireType.Varint).int32(message.assertion)
    /* repeated annonars.clinvar_data.clinvar_public.ClinicalAssertion.AttributeSetElement attributes = 9; */
    for (let i = 0; i < message.attributes.length; i++)
      ClinicalAssertion_AttributeSetElement.internalBinaryWrite(
        message.attributes[i],
        writer.tag(9, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.ObservedIn observed_ins = 10; */
    for (let i = 0; i < message.observedIns.length; i++)
      ObservedIn.internalBinaryWrite(
        message.observedIns[i],
        writer.tag(10, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.clinvar_data.clinvar_public.AlleleScv simple_allele = 11; */
    if (message.simpleAllele)
      AlleleScv.internalBinaryWrite(
        message.simpleAllele,
        writer.tag(11, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.clinvar_data.clinvar_public.HaplotypeScv haplotype = 12; */
    if (message.haplotype)
      HaplotypeScv.internalBinaryWrite(
        message.haplotype,
        writer.tag(12, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.clinvar_data.clinvar_public.GenotypeScv genotype = 13; */
    if (message.genotype)
      GenotypeScv.internalBinaryWrite(
        message.genotype,
        writer.tag(13, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.clinvar_data.clinvar_public.TraitSet trait_set = 14; */
    if (message.traitSet)
      TraitSet.internalBinaryWrite(
        message.traitSet,
        writer.tag(14, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Citation citations = 15; */
    for (let i = 0; i < message.citations.length; i++)
      Citation.internalBinaryWrite(
        message.citations[i],
        writer.tag(15, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional string study_name = 16; */
    if (message.studyName !== undefined)
      writer.tag(16, WireType.LengthDelimited).string(message.studyName)
    /* optional string study_description = 17; */
    if (message.studyDescription !== undefined)
      writer.tag(17, WireType.LengthDelimited).string(message.studyDescription)
    /* repeated annonars.clinvar_data.clinvar_public.Comment comments = 18; */
    for (let i = 0; i < message.comments.length; i++)
      Comment.internalBinaryWrite(
        message.comments[i],
        writer.tag(18, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated string submission_names = 19; */
    for (let i = 0; i < message.submissionNames.length; i++)
      writer.tag(19, WireType.LengthDelimited).string(message.submissionNames[i])
    /* google.protobuf.Timestamp date_created = 20; */
    if (message.dateCreated)
      Timestamp.internalBinaryWrite(
        message.dateCreated,
        writer.tag(20, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* google.protobuf.Timestamp date_last_updated = 21; */
    if (message.dateLastUpdated)
      Timestamp.internalBinaryWrite(
        message.dateLastUpdated,
        writer.tag(21, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* google.protobuf.Timestamp submission_date = 22; */
    if (message.submissionDate)
      Timestamp.internalBinaryWrite(
        message.submissionDate,
        writer.tag(22, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional uint64 id = 23; */
    if (message.id !== undefined) writer.tag(23, WireType.Varint).uint64(message.id)
    /* optional bool fda_recognized_database = 24; */
    if (message.fdaRecognizedDatabase !== undefined)
      writer.tag(24, WireType.Varint).bool(message.fdaRecognizedDatabase)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.ClinicalAssertion
 */
export const ClinicalAssertion = new ClinicalAssertion$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ClinicalAssertion_ClinvarSubmissionId$Type extends MessageType<ClinicalAssertion_ClinvarSubmissionId> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.ClinicalAssertion.ClinvarSubmissionId', [
      { no: 1, name: 'local_key', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'title', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: 'local_key_is_submitted',
        kind: 'scalar',
        opt: true,
        T: 8 /*ScalarType.BOOL*/
      },
      { no: 4, name: 'submitted_assembly', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(
    value?: PartialMessage<ClinicalAssertion_ClinvarSubmissionId>
  ): ClinicalAssertion_ClinvarSubmissionId {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.localKey = ''
    if (value !== undefined)
      reflectionMergePartial<ClinicalAssertion_ClinvarSubmissionId>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ClinicalAssertion_ClinvarSubmissionId
  ): ClinicalAssertion_ClinvarSubmissionId {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string local_key */ 1:
          message.localKey = reader.string()
          break
        case /* optional string title */ 2:
          message.title = reader.string()
          break
        case /* optional bool local_key_is_submitted */ 3:
          message.localKeyIsSubmitted = reader.bool()
          break
        case /* optional string submitted_assembly */ 4:
          message.submittedAssembly = reader.string()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ClinicalAssertion_ClinvarSubmissionId,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string local_key = 1; */
    if (message.localKey !== '') writer.tag(1, WireType.LengthDelimited).string(message.localKey)
    /* optional string title = 2; */
    if (message.title !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.title)
    /* optional bool local_key_is_submitted = 3; */
    if (message.localKeyIsSubmitted !== undefined)
      writer.tag(3, WireType.Varint).bool(message.localKeyIsSubmitted)
    /* optional string submitted_assembly = 4; */
    if (message.submittedAssembly !== undefined)
      writer.tag(4, WireType.LengthDelimited).string(message.submittedAssembly)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.ClinicalAssertion.ClinvarSubmissionId
 */
export const ClinicalAssertion_ClinvarSubmissionId =
  new ClinicalAssertion_ClinvarSubmissionId$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ClinicalAssertion_AttributeSetElement$Type extends MessageType<ClinicalAssertion_AttributeSetElement> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.ClinicalAssertion.AttributeSetElement', [
      { no: 1, name: 'attribute', kind: 'message', T: () => BaseAttribute },
      {
        no: 2,
        name: 'type',
        kind: 'enum',
        T: () => [
          'annonars.clinvar_data.clinvar_public.ClinicalAssertion.AttributeSetElement.Type',
          ClinicalAssertion_AttributeSetElement_Type
        ]
      },
      { no: 3, name: 'xrefs', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Xref },
      {
        no: 4,
        name: 'citations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Citation
      },
      {
        no: 5,
        name: 'comments',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Comment
      }
    ])
  }
  create(
    value?: PartialMessage<ClinicalAssertion_AttributeSetElement>
  ): ClinicalAssertion_AttributeSetElement {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.type = 0
    message.xrefs = []
    message.citations = []
    message.comments = []
    if (value !== undefined)
      reflectionMergePartial<ClinicalAssertion_AttributeSetElement>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ClinicalAssertion_AttributeSetElement
  ): ClinicalAssertion_AttributeSetElement {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* annonars.clinvar_data.clinvar_public.BaseAttribute attribute */ 1:
          message.attribute = BaseAttribute.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.attribute
          )
          break
        case /* annonars.clinvar_data.clinvar_public.ClinicalAssertion.AttributeSetElement.Type type */ 2:
          message.type = reader.int32()
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs */ 3:
          message.xrefs.push(Xref.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Citation citations */ 4:
          message.citations.push(Citation.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Comment comments */ 5:
          message.comments.push(Comment.internalBinaryRead(reader, reader.uint32(), options))
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ClinicalAssertion_AttributeSetElement,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* annonars.clinvar_data.clinvar_public.BaseAttribute attribute = 1; */
    if (message.attribute)
      BaseAttribute.internalBinaryWrite(
        message.attribute,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.clinvar_data.clinvar_public.ClinicalAssertion.AttributeSetElement.Type type = 2; */
    if (message.type !== 0) writer.tag(2, WireType.Varint).int32(message.type)
    /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 3; */
    for (let i = 0; i < message.xrefs.length; i++)
      Xref.internalBinaryWrite(
        message.xrefs[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Citation citations = 4; */
    for (let i = 0; i < message.citations.length; i++)
      Citation.internalBinaryWrite(
        message.citations[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Comment comments = 5; */
    for (let i = 0; i < message.comments.length; i++)
      Comment.internalBinaryWrite(
        message.comments[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.ClinicalAssertion.AttributeSetElement
 */
export const ClinicalAssertion_AttributeSetElement =
  new ClinicalAssertion_AttributeSetElement$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ClinicalAssertion_ClinvarAccession$Type extends MessageType<ClinicalAssertion_ClinvarAccession> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.ClinicalAssertion.ClinvarAccession', [
      { no: 1, name: 'accession', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'version', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 3, name: 'submitter_identifiers', kind: 'message', T: () => SubmitterIdentifiers },
      { no: 4, name: 'date_updated', kind: 'message', T: () => Timestamp },
      { no: 5, name: 'date_created', kind: 'message', T: () => Timestamp }
    ])
  }
  create(
    value?: PartialMessage<ClinicalAssertion_ClinvarAccession>
  ): ClinicalAssertion_ClinvarAccession {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.accession = ''
    message.version = 0
    if (value !== undefined)
      reflectionMergePartial<ClinicalAssertion_ClinvarAccession>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ClinicalAssertion_ClinvarAccession
  ): ClinicalAssertion_ClinvarAccession {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string accession */ 1:
          message.accession = reader.string()
          break
        case /* int32 version */ 2:
          message.version = reader.int32()
          break
        case /* annonars.clinvar_data.clinvar_public.SubmitterIdentifiers submitter_identifiers */ 3:
          message.submitterIdentifiers = SubmitterIdentifiers.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.submitterIdentifiers
          )
          break
        case /* optional google.protobuf.Timestamp date_updated */ 4:
          message.dateUpdated = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.dateUpdated
          )
          break
        case /* optional google.protobuf.Timestamp date_created */ 5:
          message.dateCreated = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.dateCreated
          )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ClinicalAssertion_ClinvarAccession,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string accession = 1; */
    if (message.accession !== '') writer.tag(1, WireType.LengthDelimited).string(message.accession)
    /* int32 version = 2; */
    if (message.version !== 0) writer.tag(2, WireType.Varint).int32(message.version)
    /* annonars.clinvar_data.clinvar_public.SubmitterIdentifiers submitter_identifiers = 3; */
    if (message.submitterIdentifiers)
      SubmitterIdentifiers.internalBinaryWrite(
        message.submitterIdentifiers,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional google.protobuf.Timestamp date_updated = 4; */
    if (message.dateUpdated)
      Timestamp.internalBinaryWrite(
        message.dateUpdated,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional google.protobuf.Timestamp date_created = 5; */
    if (message.dateCreated)
      Timestamp.internalBinaryWrite(
        message.dateCreated,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.ClinicalAssertion.ClinvarAccession
 */
export const ClinicalAssertion_ClinvarAccession = new ClinicalAssertion_ClinvarAccession$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Allele$Type extends MessageType<Allele> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.Allele', [
      {
        no: 1,
        name: 'genes',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Allele_Gene
      },
      { no: 2, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'canonical_spdi', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      {
        no: 4,
        name: 'variant_types',
        kind: 'scalar',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: 'locations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Location
      },
      {
        no: 6,
        name: 'other_names',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => OtherName
      },
      {
        no: 7,
        name: 'protein_changes',
        kind: 'scalar',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/
      },
      {
        no: 8,
        name: 'hgvs_expressions',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => HgvsExpression
      },
      { no: 9, name: 'classifications', kind: 'message', T: () => AggregateClassificationSet },
      { no: 10, name: 'xrefs', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Xref },
      {
        no: 11,
        name: 'comments',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Comment
      },
      {
        no: 12,
        name: 'functional_consequences',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => FunctionalConsequence
      },
      {
        no: 13,
        name: 'allele_frequencies',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Allele_AlleleFrequency
      },
      {
        no: 14,
        name: 'global_minor_allele_frequency',
        kind: 'message',
        T: () => Allele_GlobalMinorAlleleFrequency
      },
      { no: 15, name: 'allele_id', kind: 'scalar', T: 3 /*ScalarType.INT64*/ },
      { no: 16, name: 'variation_id', kind: 'scalar', T: 3 /*ScalarType.INT64*/ }
    ])
  }
  create(value?: PartialMessage<Allele>): Allele {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.genes = []
    message.name = ''
    message.variantTypes = []
    message.locations = []
    message.otherNames = []
    message.proteinChanges = []
    message.hgvsExpressions = []
    message.xrefs = []
    message.comments = []
    message.functionalConsequences = []
    message.alleleFrequencies = []
    message.alleleId = '0'
    message.variationId = '0'
    if (value !== undefined) reflectionMergePartial<Allele>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Allele
  ): Allele {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated annonars.clinvar_data.clinvar_public.Allele.Gene genes */ 1:
          message.genes.push(Allele_Gene.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* string name */ 2:
          message.name = reader.string()
          break
        case /* optional string canonical_spdi */ 3:
          message.canonicalSpdi = reader.string()
          break
        case /* repeated string variant_types */ 4:
          message.variantTypes.push(reader.string())
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Location locations */ 5:
          message.locations.push(Location.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.OtherName other_names */ 6:
          message.otherNames.push(OtherName.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated string protein_changes */ 7:
          message.proteinChanges.push(reader.string())
          break
        case /* repeated annonars.clinvar_data.clinvar_public.HgvsExpression hgvs_expressions */ 8:
          message.hgvsExpressions.push(
            HgvsExpression.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* optional annonars.clinvar_data.clinvar_public.AggregateClassificationSet classifications */ 9:
          message.classifications = AggregateClassificationSet.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.classifications
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs */ 10:
          message.xrefs.push(Xref.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Comment comments */ 11:
          message.comments.push(Comment.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.FunctionalConsequence functional_consequences */ 12:
          message.functionalConsequences.push(
            FunctionalConsequence.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Allele.AlleleFrequency allele_frequencies */ 13:
          message.alleleFrequencies.push(
            Allele_AlleleFrequency.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* optional annonars.clinvar_data.clinvar_public.Allele.GlobalMinorAlleleFrequency global_minor_allele_frequency */ 14:
          message.globalMinorAlleleFrequency = Allele_GlobalMinorAlleleFrequency.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.globalMinorAlleleFrequency
          )
          break
        case /* int64 allele_id */ 15:
          message.alleleId = reader.int64().toString()
          break
        case /* int64 variation_id */ 16:
          message.variationId = reader.int64().toString()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Allele,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated annonars.clinvar_data.clinvar_public.Allele.Gene genes = 1; */
    for (let i = 0; i < message.genes.length; i++)
      Allele_Gene.internalBinaryWrite(
        message.genes[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* string name = 2; */
    if (message.name !== '') writer.tag(2, WireType.LengthDelimited).string(message.name)
    /* optional string canonical_spdi = 3; */
    if (message.canonicalSpdi !== undefined)
      writer.tag(3, WireType.LengthDelimited).string(message.canonicalSpdi)
    /* repeated string variant_types = 4; */
    for (let i = 0; i < message.variantTypes.length; i++)
      writer.tag(4, WireType.LengthDelimited).string(message.variantTypes[i])
    /* repeated annonars.clinvar_data.clinvar_public.Location locations = 5; */
    for (let i = 0; i < message.locations.length; i++)
      Location.internalBinaryWrite(
        message.locations[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.OtherName other_names = 6; */
    for (let i = 0; i < message.otherNames.length; i++)
      OtherName.internalBinaryWrite(
        message.otherNames[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated string protein_changes = 7; */
    for (let i = 0; i < message.proteinChanges.length; i++)
      writer.tag(7, WireType.LengthDelimited).string(message.proteinChanges[i])
    /* repeated annonars.clinvar_data.clinvar_public.HgvsExpression hgvs_expressions = 8; */
    for (let i = 0; i < message.hgvsExpressions.length; i++)
      HgvsExpression.internalBinaryWrite(
        message.hgvsExpressions[i],
        writer.tag(8, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.clinvar_data.clinvar_public.AggregateClassificationSet classifications = 9; */
    if (message.classifications)
      AggregateClassificationSet.internalBinaryWrite(
        message.classifications,
        writer.tag(9, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 10; */
    for (let i = 0; i < message.xrefs.length; i++)
      Xref.internalBinaryWrite(
        message.xrefs[i],
        writer.tag(10, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Comment comments = 11; */
    for (let i = 0; i < message.comments.length; i++)
      Comment.internalBinaryWrite(
        message.comments[i],
        writer.tag(11, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.FunctionalConsequence functional_consequences = 12; */
    for (let i = 0; i < message.functionalConsequences.length; i++)
      FunctionalConsequence.internalBinaryWrite(
        message.functionalConsequences[i],
        writer.tag(12, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Allele.AlleleFrequency allele_frequencies = 13; */
    for (let i = 0; i < message.alleleFrequencies.length; i++)
      Allele_AlleleFrequency.internalBinaryWrite(
        message.alleleFrequencies[i],
        writer.tag(13, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.clinvar_data.clinvar_public.Allele.GlobalMinorAlleleFrequency global_minor_allele_frequency = 14; */
    if (message.globalMinorAlleleFrequency)
      Allele_GlobalMinorAlleleFrequency.internalBinaryWrite(
        message.globalMinorAlleleFrequency,
        writer.tag(14, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* int64 allele_id = 15; */
    if (message.alleleId !== '0') writer.tag(15, WireType.Varint).int64(message.alleleId)
    /* int64 variation_id = 16; */
    if (message.variationId !== '0') writer.tag(16, WireType.Varint).int64(message.variationId)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.Allele
 */
export const Allele = new Allele$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Allele_Gene$Type extends MessageType<Allele_Gene> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.Allele.Gene', [
      {
        no: 1,
        name: 'locations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Location
      },
      {
        no: 2,
        name: 'omims',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 4 /*ScalarType.UINT64*/
      },
      { no: 3, name: 'haploinsufficiency', kind: 'message', T: () => DosageSensitivity },
      { no: 4, name: 'triplosensitivity', kind: 'message', T: () => DosageSensitivity },
      {
        no: 5,
        name: 'properties',
        kind: 'scalar',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/
      },
      { no: 6, name: 'symbol', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 7, name: 'full_name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 8, name: 'gene_id', kind: 'scalar', T: 3 /*ScalarType.INT64*/ },
      { no: 9, name: 'hgnc_id', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 10, name: 'source', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 11,
        name: 'relationship_type',
        kind: 'enum',
        opt: true,
        T: () => [
          'annonars.clinvar_data.clinvar_public.GeneVariantRelationship',
          GeneVariantRelationship
        ]
      }
    ])
  }
  create(value?: PartialMessage<Allele_Gene>): Allele_Gene {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.locations = []
    message.omims = []
    message.properties = []
    message.fullName = ''
    message.geneId = '0'
    message.source = ''
    if (value !== undefined) reflectionMergePartial<Allele_Gene>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Allele_Gene
  ): Allele_Gene {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated annonars.clinvar_data.clinvar_public.Location locations */ 1:
          message.locations.push(Location.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated uint64 omims */ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.omims.push(reader.uint64().toString())
          else message.omims.push(reader.uint64().toString())
          break
        case /* optional annonars.clinvar_data.clinvar_public.DosageSensitivity haploinsufficiency */ 3:
          message.haploinsufficiency = DosageSensitivity.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.haploinsufficiency
          )
          break
        case /* optional annonars.clinvar_data.clinvar_public.DosageSensitivity triplosensitivity */ 4:
          message.triplosensitivity = DosageSensitivity.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.triplosensitivity
          )
          break
        case /* repeated string properties */ 5:
          message.properties.push(reader.string())
          break
        case /* optional string symbol */ 6:
          message.symbol = reader.string()
          break
        case /* string full_name */ 7:
          message.fullName = reader.string()
          break
        case /* int64 gene_id */ 8:
          message.geneId = reader.int64().toString()
          break
        case /* optional string hgnc_id */ 9:
          message.hgncId = reader.string()
          break
        case /* string source */ 10:
          message.source = reader.string()
          break
        case /* optional annonars.clinvar_data.clinvar_public.GeneVariantRelationship relationship_type */ 11:
          message.relationshipType = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Allele_Gene,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated annonars.clinvar_data.clinvar_public.Location locations = 1; */
    for (let i = 0; i < message.locations.length; i++)
      Location.internalBinaryWrite(
        message.locations[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated uint64 omims = 2; */
    if (message.omims.length) {
      writer.tag(2, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.omims.length; i++) writer.uint64(message.omims[i])
      writer.join()
    }
    /* optional annonars.clinvar_data.clinvar_public.DosageSensitivity haploinsufficiency = 3; */
    if (message.haploinsufficiency)
      DosageSensitivity.internalBinaryWrite(
        message.haploinsufficiency,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.clinvar_data.clinvar_public.DosageSensitivity triplosensitivity = 4; */
    if (message.triplosensitivity)
      DosageSensitivity.internalBinaryWrite(
        message.triplosensitivity,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated string properties = 5; */
    for (let i = 0; i < message.properties.length; i++)
      writer.tag(5, WireType.LengthDelimited).string(message.properties[i])
    /* optional string symbol = 6; */
    if (message.symbol !== undefined) writer.tag(6, WireType.LengthDelimited).string(message.symbol)
    /* string full_name = 7; */
    if (message.fullName !== '') writer.tag(7, WireType.LengthDelimited).string(message.fullName)
    /* int64 gene_id = 8; */
    if (message.geneId !== '0') writer.tag(8, WireType.Varint).int64(message.geneId)
    /* optional string hgnc_id = 9; */
    if (message.hgncId !== undefined) writer.tag(9, WireType.LengthDelimited).string(message.hgncId)
    /* string source = 10; */
    if (message.source !== '') writer.tag(10, WireType.LengthDelimited).string(message.source)
    /* optional annonars.clinvar_data.clinvar_public.GeneVariantRelationship relationship_type = 11; */
    if (message.relationshipType !== undefined)
      writer.tag(11, WireType.Varint).int32(message.relationshipType)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.Allele.Gene
 */
export const Allele_Gene = new Allele_Gene$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Allele_AlleleFrequency$Type extends MessageType<Allele_AlleleFrequency> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.Allele.AlleleFrequency', [
      { no: 1, name: 'value', kind: 'scalar', T: 1 /*ScalarType.DOUBLE*/ },
      { no: 2, name: 'source', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'url', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(value?: PartialMessage<Allele_AlleleFrequency>): Allele_AlleleFrequency {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.value = 0
    message.source = ''
    if (value !== undefined) reflectionMergePartial<Allele_AlleleFrequency>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Allele_AlleleFrequency
  ): Allele_AlleleFrequency {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* double value */ 1:
          message.value = reader.double()
          break
        case /* string source */ 2:
          message.source = reader.string()
          break
        case /* optional string url */ 3:
          message.url = reader.string()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Allele_AlleleFrequency,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* double value = 1; */
    if (message.value !== 0) writer.tag(1, WireType.Bit64).double(message.value)
    /* string source = 2; */
    if (message.source !== '') writer.tag(2, WireType.LengthDelimited).string(message.source)
    /* optional string url = 3; */
    if (message.url !== undefined) writer.tag(3, WireType.LengthDelimited).string(message.url)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.Allele.AlleleFrequency
 */
export const Allele_AlleleFrequency = new Allele_AlleleFrequency$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Allele_GlobalMinorAlleleFrequency$Type extends MessageType<Allele_GlobalMinorAlleleFrequency> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.Allele.GlobalMinorAlleleFrequency', [
      { no: 1, name: 'value', kind: 'scalar', T: 1 /*ScalarType.DOUBLE*/ },
      { no: 2, name: 'source', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'minor_allele', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: 'url', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(
    value?: PartialMessage<Allele_GlobalMinorAlleleFrequency>
  ): Allele_GlobalMinorAlleleFrequency {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.value = 0
    message.source = ''
    if (value !== undefined)
      reflectionMergePartial<Allele_GlobalMinorAlleleFrequency>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Allele_GlobalMinorAlleleFrequency
  ): Allele_GlobalMinorAlleleFrequency {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* double value */ 1:
          message.value = reader.double()
          break
        case /* string source */ 2:
          message.source = reader.string()
          break
        case /* optional string minor_allele */ 3:
          message.minorAllele = reader.string()
          break
        case /* optional string url */ 4:
          message.url = reader.string()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Allele_GlobalMinorAlleleFrequency,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* double value = 1; */
    if (message.value !== 0) writer.tag(1, WireType.Bit64).double(message.value)
    /* string source = 2; */
    if (message.source !== '') writer.tag(2, WireType.LengthDelimited).string(message.source)
    /* optional string minor_allele = 3; */
    if (message.minorAllele !== undefined)
      writer.tag(3, WireType.LengthDelimited).string(message.minorAllele)
    /* optional string url = 4; */
    if (message.url !== undefined) writer.tag(4, WireType.LengthDelimited).string(message.url)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.Allele.GlobalMinorAlleleFrequency
 */
export const Allele_GlobalMinorAlleleFrequency = new Allele_GlobalMinorAlleleFrequency$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Allele_Name$Type extends MessageType<Allele_Name> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.Allele.Name', [
      { no: 1, name: 'value', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'type', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(value?: PartialMessage<Allele_Name>): Allele_Name {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.value = ''
    if (value !== undefined) reflectionMergePartial<Allele_Name>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Allele_Name
  ): Allele_Name {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string value */ 1:
          message.value = reader.string()
          break
        case /* optional string type */ 2:
          message.type = reader.string()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Allele_Name,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string value = 1; */
    if (message.value !== '') writer.tag(1, WireType.LengthDelimited).string(message.value)
    /* optional string type = 2; */
    if (message.type !== undefined) writer.tag(2, WireType.LengthDelimited).string(message.type)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.Allele.Name
 */
export const Allele_Name = new Allele_Name$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Haplotype$Type extends MessageType<Haplotype> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.Haplotype', [
      {
        no: 1,
        name: 'simple_alleles',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Allele
      },
      { no: 2, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 3,
        name: 'variation_type',
        kind: 'enum',
        T: () => ['annonars.clinvar_data.clinvar_public.HaploVariationType', HaploVariationType]
      },
      {
        no: 4,
        name: 'other_names',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => OtherName
      },
      {
        no: 5,
        name: 'hgvs_expressions',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => HgvsExpression
      },
      { no: 6, name: 'classifications', kind: 'message', T: () => AggregateClassificationSet },
      {
        no: 7,
        name: 'functional_consequences',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => FunctionalConsequence
      },
      { no: 8, name: 'xrefs', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Xref },
      {
        no: 9,
        name: 'comments',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Comment
      },
      { no: 10, name: 'variation_id', kind: 'scalar', T: 3 /*ScalarType.INT64*/ },
      { no: 11, name: 'number_of_copies', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      {
        no: 12,
        name: 'number_of_chromosomes',
        kind: 'scalar',
        opt: true,
        T: 5 /*ScalarType.INT32*/
      }
    ])
  }
  create(value?: PartialMessage<Haplotype>): Haplotype {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.simpleAlleles = []
    message.name = ''
    message.variationType = 0
    message.otherNames = []
    message.hgvsExpressions = []
    message.functionalConsequences = []
    message.xrefs = []
    message.comments = []
    message.variationId = '0'
    if (value !== undefined) reflectionMergePartial<Haplotype>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Haplotype
  ): Haplotype {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated annonars.clinvar_data.clinvar_public.Allele simple_alleles */ 1:
          message.simpleAlleles.push(Allele.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* string name */ 2:
          message.name = reader.string()
          break
        case /* annonars.clinvar_data.clinvar_public.HaploVariationType variation_type */ 3:
          message.variationType = reader.int32()
          break
        case /* repeated annonars.clinvar_data.clinvar_public.OtherName other_names */ 4:
          message.otherNames.push(OtherName.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.HgvsExpression hgvs_expressions */ 5:
          message.hgvsExpressions.push(
            HgvsExpression.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* optional annonars.clinvar_data.clinvar_public.AggregateClassificationSet classifications */ 6:
          message.classifications = AggregateClassificationSet.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.classifications
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.FunctionalConsequence functional_consequences */ 7:
          message.functionalConsequences.push(
            FunctionalConsequence.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs */ 8:
          message.xrefs.push(Xref.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Comment comments */ 9:
          message.comments.push(Comment.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* int64 variation_id */ 10:
          message.variationId = reader.int64().toString()
          break
        case /* optional int32 number_of_copies */ 11:
          message.numberOfCopies = reader.int32()
          break
        case /* optional int32 number_of_chromosomes */ 12:
          message.numberOfChromosomes = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Haplotype,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated annonars.clinvar_data.clinvar_public.Allele simple_alleles = 1; */
    for (let i = 0; i < message.simpleAlleles.length; i++)
      Allele.internalBinaryWrite(
        message.simpleAlleles[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* string name = 2; */
    if (message.name !== '') writer.tag(2, WireType.LengthDelimited).string(message.name)
    /* annonars.clinvar_data.clinvar_public.HaploVariationType variation_type = 3; */
    if (message.variationType !== 0) writer.tag(3, WireType.Varint).int32(message.variationType)
    /* repeated annonars.clinvar_data.clinvar_public.OtherName other_names = 4; */
    for (let i = 0; i < message.otherNames.length; i++)
      OtherName.internalBinaryWrite(
        message.otherNames[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.HgvsExpression hgvs_expressions = 5; */
    for (let i = 0; i < message.hgvsExpressions.length; i++)
      HgvsExpression.internalBinaryWrite(
        message.hgvsExpressions[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.clinvar_data.clinvar_public.AggregateClassificationSet classifications = 6; */
    if (message.classifications)
      AggregateClassificationSet.internalBinaryWrite(
        message.classifications,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.FunctionalConsequence functional_consequences = 7; */
    for (let i = 0; i < message.functionalConsequences.length; i++)
      FunctionalConsequence.internalBinaryWrite(
        message.functionalConsequences[i],
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 8; */
    for (let i = 0; i < message.xrefs.length; i++)
      Xref.internalBinaryWrite(
        message.xrefs[i],
        writer.tag(8, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Comment comments = 9; */
    for (let i = 0; i < message.comments.length; i++)
      Comment.internalBinaryWrite(
        message.comments[i],
        writer.tag(9, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* int64 variation_id = 10; */
    if (message.variationId !== '0') writer.tag(10, WireType.Varint).int64(message.variationId)
    /* optional int32 number_of_copies = 11; */
    if (message.numberOfCopies !== undefined)
      writer.tag(11, WireType.Varint).int32(message.numberOfCopies)
    /* optional int32 number_of_chromosomes = 12; */
    if (message.numberOfChromosomes !== undefined)
      writer.tag(12, WireType.Varint).int32(message.numberOfChromosomes)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.Haplotype
 */
export const Haplotype = new Haplotype$Type()
// @generated message type with reflection information, may provide speed optimized methods
class IncludedRecord$Type extends MessageType<IncludedRecord> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.IncludedRecord', [
      { no: 1, name: 'simple_allele', kind: 'message', T: () => Allele },
      { no: 2, name: 'haplotype', kind: 'message', T: () => Haplotype },
      { no: 3, name: 'classifications', kind: 'message', T: () => AggregateClassificationSet },
      {
        no: 4,
        name: 'submitted_classifications',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Scv
      },
      {
        no: 5,
        name: 'classified_variations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => IncludedRecord_ClassifiedVariation
      },
      {
        no: 6,
        name: 'general_citations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => GeneralCitations
      }
    ])
  }
  create(value?: PartialMessage<IncludedRecord>): IncludedRecord {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.submittedClassifications = []
    message.classifiedVariations = []
    message.generalCitations = []
    if (value !== undefined) reflectionMergePartial<IncludedRecord>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: IncludedRecord
  ): IncludedRecord {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional annonars.clinvar_data.clinvar_public.Allele simple_allele */ 1:
          message.simpleAllele = Allele.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.simpleAllele
          )
          break
        case /* optional annonars.clinvar_data.clinvar_public.Haplotype haplotype */ 2:
          message.haplotype = Haplotype.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.haplotype
          )
          break
        case /* optional annonars.clinvar_data.clinvar_public.AggregateClassificationSet classifications */ 3:
          message.classifications = AggregateClassificationSet.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.classifications
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Scv submitted_classifications */ 4:
          message.submittedClassifications.push(
            Scv.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.IncludedRecord.ClassifiedVariation classified_variations */ 5:
          message.classifiedVariations.push(
            IncludedRecord_ClassifiedVariation.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.GeneralCitations general_citations */ 6:
          message.generalCitations.push(
            GeneralCitations.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: IncludedRecord,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional annonars.clinvar_data.clinvar_public.Allele simple_allele = 1; */
    if (message.simpleAllele)
      Allele.internalBinaryWrite(
        message.simpleAllele,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.clinvar_data.clinvar_public.Haplotype haplotype = 2; */
    if (message.haplotype)
      Haplotype.internalBinaryWrite(
        message.haplotype,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.clinvar_data.clinvar_public.AggregateClassificationSet classifications = 3; */
    if (message.classifications)
      AggregateClassificationSet.internalBinaryWrite(
        message.classifications,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Scv submitted_classifications = 4; */
    for (let i = 0; i < message.submittedClassifications.length; i++)
      Scv.internalBinaryWrite(
        message.submittedClassifications[i],
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.IncludedRecord.ClassifiedVariation classified_variations = 5; */
    for (let i = 0; i < message.classifiedVariations.length; i++)
      IncludedRecord_ClassifiedVariation.internalBinaryWrite(
        message.classifiedVariations[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.GeneralCitations general_citations = 6; */
    for (let i = 0; i < message.generalCitations.length; i++)
      GeneralCitations.internalBinaryWrite(
        message.generalCitations[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.IncludedRecord
 */
export const IncludedRecord = new IncludedRecord$Type()
// @generated message type with reflection information, may provide speed optimized methods
class IncludedRecord_ClassifiedVariation$Type extends MessageType<IncludedRecord_ClassifiedVariation> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.IncludedRecord.ClassifiedVariation', [
      { no: 1, name: 'variation_id', kind: 'scalar', T: 3 /*ScalarType.INT64*/ },
      { no: 2, name: 'accession', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'version', kind: 'scalar', T: 5 /*ScalarType.INT32*/ }
    ])
  }
  create(
    value?: PartialMessage<IncludedRecord_ClassifiedVariation>
  ): IncludedRecord_ClassifiedVariation {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.variationId = '0'
    message.version = 0
    if (value !== undefined)
      reflectionMergePartial<IncludedRecord_ClassifiedVariation>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: IncludedRecord_ClassifiedVariation
  ): IncludedRecord_ClassifiedVariation {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* int64 variation_id */ 1:
          message.variationId = reader.int64().toString()
          break
        case /* optional string accession */ 2:
          message.accession = reader.string()
          break
        case /* int32 version */ 3:
          message.version = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: IncludedRecord_ClassifiedVariation,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* int64 variation_id = 1; */
    if (message.variationId !== '0') writer.tag(1, WireType.Varint).int64(message.variationId)
    /* optional string accession = 2; */
    if (message.accession !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.accession)
    /* int32 version = 3; */
    if (message.version !== 0) writer.tag(3, WireType.Varint).int32(message.version)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.IncludedRecord.ClassifiedVariation
 */
export const IncludedRecord_ClassifiedVariation = new IncludedRecord_ClassifiedVariation$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Genotype$Type extends MessageType<Genotype> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.Genotype', [
      {
        no: 1,
        name: 'simple_alleles',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Allele
      },
      {
        no: 2,
        name: 'haplotypes',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Haplotype
      },
      { no: 3, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 4,
        name: 'variation_type',
        kind: 'enum',
        T: () => ['annonars.clinvar_data.clinvar_public.VariationType', VariationType]
      },
      {
        no: 5,
        name: 'other_names',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => OtherName
      },
      {
        no: 6,
        name: 'hgvs_expressions',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => HgvsExpression
      },
      {
        no: 7,
        name: 'functional_consequences',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => FunctionalConsequence
      },
      { no: 8, name: 'classifications', kind: 'message', T: () => AggregateClassificationSet },
      { no: 9, name: 'xrefs', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Xref },
      {
        no: 10,
        name: 'citations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Citation
      },
      {
        no: 11,
        name: 'comments',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Comment
      },
      {
        no: 12,
        name: 'attributes',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => AttributeSetElement
      },
      { no: 13, name: 'variation_id', kind: 'scalar', opt: true, T: 3 /*ScalarType.INT64*/ }
    ])
  }
  create(value?: PartialMessage<Genotype>): Genotype {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.simpleAlleles = []
    message.haplotypes = []
    message.name = ''
    message.variationType = 0
    message.otherNames = []
    message.hgvsExpressions = []
    message.functionalConsequences = []
    message.xrefs = []
    message.citations = []
    message.comments = []
    message.attributes = []
    if (value !== undefined) reflectionMergePartial<Genotype>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Genotype
  ): Genotype {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated annonars.clinvar_data.clinvar_public.Allele simple_alleles */ 1:
          message.simpleAlleles.push(Allele.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Haplotype haplotypes */ 2:
          message.haplotypes.push(Haplotype.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* string name */ 3:
          message.name = reader.string()
          break
        case /* annonars.clinvar_data.clinvar_public.VariationType variation_type */ 4:
          message.variationType = reader.int32()
          break
        case /* repeated annonars.clinvar_data.clinvar_public.OtherName other_names */ 5:
          message.otherNames.push(OtherName.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.HgvsExpression hgvs_expressions */ 6:
          message.hgvsExpressions.push(
            HgvsExpression.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.FunctionalConsequence functional_consequences */ 7:
          message.functionalConsequences.push(
            FunctionalConsequence.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* optional annonars.clinvar_data.clinvar_public.AggregateClassificationSet classifications */ 8:
          message.classifications = AggregateClassificationSet.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.classifications
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs */ 9:
          message.xrefs.push(Xref.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Citation citations */ 10:
          message.citations.push(Citation.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.Comment comments */ 11:
          message.comments.push(Comment.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.AttributeSetElement attributes */ 12:
          message.attributes.push(
            AttributeSetElement.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* optional int64 variation_id */ 13:
          message.variationId = reader.int64().toString()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Genotype,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated annonars.clinvar_data.clinvar_public.Allele simple_alleles = 1; */
    for (let i = 0; i < message.simpleAlleles.length; i++)
      Allele.internalBinaryWrite(
        message.simpleAlleles[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Haplotype haplotypes = 2; */
    for (let i = 0; i < message.haplotypes.length; i++)
      Haplotype.internalBinaryWrite(
        message.haplotypes[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* string name = 3; */
    if (message.name !== '') writer.tag(3, WireType.LengthDelimited).string(message.name)
    /* annonars.clinvar_data.clinvar_public.VariationType variation_type = 4; */
    if (message.variationType !== 0) writer.tag(4, WireType.Varint).int32(message.variationType)
    /* repeated annonars.clinvar_data.clinvar_public.OtherName other_names = 5; */
    for (let i = 0; i < message.otherNames.length; i++)
      OtherName.internalBinaryWrite(
        message.otherNames[i],
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.HgvsExpression hgvs_expressions = 6; */
    for (let i = 0; i < message.hgvsExpressions.length; i++)
      HgvsExpression.internalBinaryWrite(
        message.hgvsExpressions[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.FunctionalConsequence functional_consequences = 7; */
    for (let i = 0; i < message.functionalConsequences.length; i++)
      FunctionalConsequence.internalBinaryWrite(
        message.functionalConsequences[i],
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.clinvar_data.clinvar_public.AggregateClassificationSet classifications = 8; */
    if (message.classifications)
      AggregateClassificationSet.internalBinaryWrite(
        message.classifications,
        writer.tag(8, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Xref xrefs = 9; */
    for (let i = 0; i < message.xrefs.length; i++)
      Xref.internalBinaryWrite(
        message.xrefs[i],
        writer.tag(9, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Citation citations = 10; */
    for (let i = 0; i < message.citations.length; i++)
      Citation.internalBinaryWrite(
        message.citations[i],
        writer.tag(10, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.Comment comments = 11; */
    for (let i = 0; i < message.comments.length; i++)
      Comment.internalBinaryWrite(
        message.comments[i],
        writer.tag(11, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.AttributeSetElement attributes = 12; */
    for (let i = 0; i < message.attributes.length; i++)
      AttributeSetElement.internalBinaryWrite(
        message.attributes[i],
        writer.tag(12, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional int64 variation_id = 13; */
    if (message.variationId !== undefined)
      writer.tag(13, WireType.Varint).int64(message.variationId)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.Genotype
 */
export const Genotype = new Genotype$Type()
// @generated message type with reflection information, may provide speed optimized methods
class RcvAccession$Type extends MessageType<RcvAccession> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.RcvAccession', [
      {
        no: 1,
        name: 'classified_condition_list',
        kind: 'message',
        T: () => RcvAccession_ClassifiedConditionList
      },
      {
        no: 2,
        name: 'rcv_classifications',
        kind: 'message',
        T: () => RcvAccession_RcvClassifications
      },
      {
        no: 3,
        name: 'replaceds',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => RecordHistory
      },
      { no: 4, name: 'title', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 5, name: 'accession', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 6, name: 'version', kind: 'scalar', T: 5 /*ScalarType.INT32*/ }
    ])
  }
  create(value?: PartialMessage<RcvAccession>): RcvAccession {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.replaceds = []
    message.accession = ''
    message.version = 0
    if (value !== undefined) reflectionMergePartial<RcvAccession>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RcvAccession
  ): RcvAccession {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional annonars.clinvar_data.clinvar_public.RcvAccession.ClassifiedConditionList classified_condition_list */ 1:
          message.classifiedConditionList = RcvAccession_ClassifiedConditionList.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.classifiedConditionList
          )
          break
        case /* annonars.clinvar_data.clinvar_public.RcvAccession.RcvClassifications rcv_classifications */ 2:
          message.rcvClassifications = RcvAccession_RcvClassifications.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.rcvClassifications
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.RecordHistory replaceds */ 3:
          message.replaceds.push(RecordHistory.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* optional string title */ 4:
          message.title = reader.string()
          break
        case /* string accession */ 5:
          message.accession = reader.string()
          break
        case /* int32 version */ 6:
          message.version = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: RcvAccession,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional annonars.clinvar_data.clinvar_public.RcvAccession.ClassifiedConditionList classified_condition_list = 1; */
    if (message.classifiedConditionList)
      RcvAccession_ClassifiedConditionList.internalBinaryWrite(
        message.classifiedConditionList,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.clinvar_data.clinvar_public.RcvAccession.RcvClassifications rcv_classifications = 2; */
    if (message.rcvClassifications)
      RcvAccession_RcvClassifications.internalBinaryWrite(
        message.rcvClassifications,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.RecordHistory replaceds = 3; */
    for (let i = 0; i < message.replaceds.length; i++)
      RecordHistory.internalBinaryWrite(
        message.replaceds[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional string title = 4; */
    if (message.title !== undefined) writer.tag(4, WireType.LengthDelimited).string(message.title)
    /* string accession = 5; */
    if (message.accession !== '') writer.tag(5, WireType.LengthDelimited).string(message.accession)
    /* int32 version = 6; */
    if (message.version !== 0) writer.tag(6, WireType.Varint).int32(message.version)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.RcvAccession
 */
export const RcvAccession = new RcvAccession$Type()
// @generated message type with reflection information, may provide speed optimized methods
class RcvAccession_ClassifiedConditionList$Type extends MessageType<RcvAccession_ClassifiedConditionList> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.RcvAccession.ClassifiedConditionList', [
      {
        no: 1,
        name: 'classified_conditions',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => ClassifiedCondition
      },
      { no: 2, name: 'trait_set_id', kind: 'scalar', opt: true, T: 3 /*ScalarType.INT64*/ }
    ])
  }
  create(
    value?: PartialMessage<RcvAccession_ClassifiedConditionList>
  ): RcvAccession_ClassifiedConditionList {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.classifiedConditions = []
    if (value !== undefined)
      reflectionMergePartial<RcvAccession_ClassifiedConditionList>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RcvAccession_ClassifiedConditionList
  ): RcvAccession_ClassifiedConditionList {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated annonars.clinvar_data.clinvar_public.ClassifiedCondition classified_conditions */ 1:
          message.classifiedConditions.push(
            ClassifiedCondition.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* optional int64 trait_set_id */ 2:
          message.traitSetId = reader.int64().toString()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: RcvAccession_ClassifiedConditionList,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated annonars.clinvar_data.clinvar_public.ClassifiedCondition classified_conditions = 1; */
    for (let i = 0; i < message.classifiedConditions.length; i++)
      ClassifiedCondition.internalBinaryWrite(
        message.classifiedConditions[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional int64 trait_set_id = 2; */
    if (message.traitSetId !== undefined) writer.tag(2, WireType.Varint).int64(message.traitSetId)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.RcvAccession.ClassifiedConditionList
 */
export const RcvAccession_ClassifiedConditionList = new RcvAccession_ClassifiedConditionList$Type()
// @generated message type with reflection information, may provide speed optimized methods
class RcvAccession_GermlineClassification$Type extends MessageType<RcvAccession_GermlineClassification> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.RcvAccession.GermlineClassification', [
      {
        no: 1,
        name: 'review_status',
        kind: 'enum',
        T: () => [
          'annonars.clinvar_data.clinvar_public.AggregateGermlineReviewStatus',
          AggregateGermlineReviewStatus
        ]
      },
      {
        no: 2,
        name: 'description',
        kind: 'message',
        T: () => RcvAccession_GermlineClassification_Description
      }
    ])
  }
  create(
    value?: PartialMessage<RcvAccession_GermlineClassification>
  ): RcvAccession_GermlineClassification {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.reviewStatus = 0
    if (value !== undefined)
      reflectionMergePartial<RcvAccession_GermlineClassification>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RcvAccession_GermlineClassification
  ): RcvAccession_GermlineClassification {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* annonars.clinvar_data.clinvar_public.AggregateGermlineReviewStatus review_status */ 1:
          message.reviewStatus = reader.int32()
          break
        case /* annonars.clinvar_data.clinvar_public.RcvAccession.GermlineClassification.Description description */ 2:
          message.description = RcvAccession_GermlineClassification_Description.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.description
          )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: RcvAccession_GermlineClassification,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* annonars.clinvar_data.clinvar_public.AggregateGermlineReviewStatus review_status = 1; */
    if (message.reviewStatus !== 0) writer.tag(1, WireType.Varint).int32(message.reviewStatus)
    /* annonars.clinvar_data.clinvar_public.RcvAccession.GermlineClassification.Description description = 2; */
    if (message.description)
      RcvAccession_GermlineClassification_Description.internalBinaryWrite(
        message.description,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.RcvAccession.GermlineClassification
 */
export const RcvAccession_GermlineClassification = new RcvAccession_GermlineClassification$Type()
// @generated message type with reflection information, may provide speed optimized methods
class RcvAccession_GermlineClassification_Description$Type extends MessageType<RcvAccession_GermlineClassification_Description> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.RcvAccession.GermlineClassification.Description', [
      { no: 1, name: 'value', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'date_last_evaluated', kind: 'message', T: () => Timestamp },
      { no: 3, name: 'submission_count', kind: 'scalar', opt: true, T: 13 /*ScalarType.UINT32*/ }
    ])
  }
  create(
    value?: PartialMessage<RcvAccession_GermlineClassification_Description>
  ): RcvAccession_GermlineClassification_Description {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.value = ''
    if (value !== undefined)
      reflectionMergePartial<RcvAccession_GermlineClassification_Description>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RcvAccession_GermlineClassification_Description
  ): RcvAccession_GermlineClassification_Description {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string value */ 1:
          message.value = reader.string()
          break
        case /* optional google.protobuf.Timestamp date_last_evaluated */ 2:
          message.dateLastEvaluated = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.dateLastEvaluated
          )
          break
        case /* optional uint32 submission_count */ 3:
          message.submissionCount = reader.uint32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: RcvAccession_GermlineClassification_Description,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string value = 1; */
    if (message.value !== '') writer.tag(1, WireType.LengthDelimited).string(message.value)
    /* optional google.protobuf.Timestamp date_last_evaluated = 2; */
    if (message.dateLastEvaluated)
      Timestamp.internalBinaryWrite(
        message.dateLastEvaluated,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional uint32 submission_count = 3; */
    if (message.submissionCount !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.submissionCount)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.RcvAccession.GermlineClassification.Description
 */
export const RcvAccession_GermlineClassification_Description =
  new RcvAccession_GermlineClassification_Description$Type()
// @generated message type with reflection information, may provide speed optimized methods
class RcvAccession_SomaticClinicalImpact$Type extends MessageType<RcvAccession_SomaticClinicalImpact> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.RcvAccession.SomaticClinicalImpact', [
      {
        no: 1,
        name: 'review_status',
        kind: 'enum',
        T: () => [
          'annonars.clinvar_data.clinvar_public.AggregateSomaticClinicalImpactReviewStatus',
          AggregateSomaticClinicalImpactReviewStatus
        ]
      },
      {
        no: 2,
        name: 'descriptions',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => RcvAccession_SomaticClinicalImpact_Description
      }
    ])
  }
  create(
    value?: PartialMessage<RcvAccession_SomaticClinicalImpact>
  ): RcvAccession_SomaticClinicalImpact {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.reviewStatus = 0
    message.descriptions = []
    if (value !== undefined)
      reflectionMergePartial<RcvAccession_SomaticClinicalImpact>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RcvAccession_SomaticClinicalImpact
  ): RcvAccession_SomaticClinicalImpact {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* annonars.clinvar_data.clinvar_public.AggregateSomaticClinicalImpactReviewStatus review_status */ 1:
          message.reviewStatus = reader.int32()
          break
        case /* repeated annonars.clinvar_data.clinvar_public.RcvAccession.SomaticClinicalImpact.Description descriptions */ 2:
          message.descriptions.push(
            RcvAccession_SomaticClinicalImpact_Description.internalBinaryRead(
              reader,
              reader.uint32(),
              options
            )
          )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: RcvAccession_SomaticClinicalImpact,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* annonars.clinvar_data.clinvar_public.AggregateSomaticClinicalImpactReviewStatus review_status = 1; */
    if (message.reviewStatus !== 0) writer.tag(1, WireType.Varint).int32(message.reviewStatus)
    /* repeated annonars.clinvar_data.clinvar_public.RcvAccession.SomaticClinicalImpact.Description descriptions = 2; */
    for (let i = 0; i < message.descriptions.length; i++)
      RcvAccession_SomaticClinicalImpact_Description.internalBinaryWrite(
        message.descriptions[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.RcvAccession.SomaticClinicalImpact
 */
export const RcvAccession_SomaticClinicalImpact = new RcvAccession_SomaticClinicalImpact$Type()
// @generated message type with reflection information, may provide speed optimized methods
class RcvAccession_SomaticClinicalImpact_Description$Type extends MessageType<RcvAccession_SomaticClinicalImpact_Description> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.RcvAccession.SomaticClinicalImpact.Description', [
      { no: 1, name: 'value', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: 'clinical_impact_assertion_type',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: 'clinical_impact_clinical_significance',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/
      },
      { no: 4, name: 'date_last_evaluated', kind: 'message', T: () => Timestamp },
      { no: 5, name: 'submission_count', kind: 'scalar', opt: true, T: 13 /*ScalarType.UINT32*/ }
    ])
  }
  create(
    value?: PartialMessage<RcvAccession_SomaticClinicalImpact_Description>
  ): RcvAccession_SomaticClinicalImpact_Description {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.value = ''
    if (value !== undefined)
      reflectionMergePartial<RcvAccession_SomaticClinicalImpact_Description>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RcvAccession_SomaticClinicalImpact_Description
  ): RcvAccession_SomaticClinicalImpact_Description {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string value */ 1:
          message.value = reader.string()
          break
        case /* optional string clinical_impact_assertion_type */ 2:
          message.clinicalImpactAssertionType = reader.string()
          break
        case /* optional string clinical_impact_clinical_significance */ 3:
          message.clinicalImpactClinicalSignificance = reader.string()
          break
        case /* optional google.protobuf.Timestamp date_last_evaluated */ 4:
          message.dateLastEvaluated = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.dateLastEvaluated
          )
          break
        case /* optional uint32 submission_count */ 5:
          message.submissionCount = reader.uint32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: RcvAccession_SomaticClinicalImpact_Description,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string value = 1; */
    if (message.value !== '') writer.tag(1, WireType.LengthDelimited).string(message.value)
    /* optional string clinical_impact_assertion_type = 2; */
    if (message.clinicalImpactAssertionType !== undefined)
      writer.tag(2, WireType.LengthDelimited).string(message.clinicalImpactAssertionType)
    /* optional string clinical_impact_clinical_significance = 3; */
    if (message.clinicalImpactClinicalSignificance !== undefined)
      writer.tag(3, WireType.LengthDelimited).string(message.clinicalImpactClinicalSignificance)
    /* optional google.protobuf.Timestamp date_last_evaluated = 4; */
    if (message.dateLastEvaluated)
      Timestamp.internalBinaryWrite(
        message.dateLastEvaluated,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional uint32 submission_count = 5; */
    if (message.submissionCount !== undefined)
      writer.tag(5, WireType.Varint).uint32(message.submissionCount)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.RcvAccession.SomaticClinicalImpact.Description
 */
export const RcvAccession_SomaticClinicalImpact_Description =
  new RcvAccession_SomaticClinicalImpact_Description$Type()
// @generated message type with reflection information, may provide speed optimized methods
class RcvAccession_OncogenicityClassification$Type extends MessageType<RcvAccession_OncogenicityClassification> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.RcvAccession.OncogenicityClassification', [
      {
        no: 1,
        name: 'review_status',
        kind: 'enum',
        T: () => [
          'annonars.clinvar_data.clinvar_public.AggregateOncogenicityReviewStatus',
          AggregateOncogenicityReviewStatus
        ]
      },
      {
        no: 2,
        name: 'description',
        kind: 'message',
        T: () => RcvAccession_OncogenicityClassification_Description
      }
    ])
  }
  create(
    value?: PartialMessage<RcvAccession_OncogenicityClassification>
  ): RcvAccession_OncogenicityClassification {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.reviewStatus = 0
    if (value !== undefined)
      reflectionMergePartial<RcvAccession_OncogenicityClassification>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RcvAccession_OncogenicityClassification
  ): RcvAccession_OncogenicityClassification {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* annonars.clinvar_data.clinvar_public.AggregateOncogenicityReviewStatus review_status */ 1:
          message.reviewStatus = reader.int32()
          break
        case /* annonars.clinvar_data.clinvar_public.RcvAccession.OncogenicityClassification.Description description */ 2:
          message.description =
            RcvAccession_OncogenicityClassification_Description.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.description
            )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: RcvAccession_OncogenicityClassification,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* annonars.clinvar_data.clinvar_public.AggregateOncogenicityReviewStatus review_status = 1; */
    if (message.reviewStatus !== 0) writer.tag(1, WireType.Varint).int32(message.reviewStatus)
    /* annonars.clinvar_data.clinvar_public.RcvAccession.OncogenicityClassification.Description description = 2; */
    if (message.description)
      RcvAccession_OncogenicityClassification_Description.internalBinaryWrite(
        message.description,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.RcvAccession.OncogenicityClassification
 */
export const RcvAccession_OncogenicityClassification =
  new RcvAccession_OncogenicityClassification$Type()
// @generated message type with reflection information, may provide speed optimized methods
class RcvAccession_OncogenicityClassification_Description$Type extends MessageType<RcvAccession_OncogenicityClassification_Description> {
  constructor() {
    super(
      'annonars.clinvar_data.clinvar_public.RcvAccession.OncogenicityClassification.Description',
      [
        { no: 1, name: 'value', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
        { no: 2, name: 'date_last_evaluated', kind: 'message', T: () => Timestamp },
        { no: 3, name: 'submission_count', kind: 'scalar', opt: true, T: 13 /*ScalarType.UINT32*/ }
      ]
    )
  }
  create(
    value?: PartialMessage<RcvAccession_OncogenicityClassification_Description>
  ): RcvAccession_OncogenicityClassification_Description {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.value = ''
    if (value !== undefined)
      reflectionMergePartial<RcvAccession_OncogenicityClassification_Description>(
        this,
        message,
        value
      )
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RcvAccession_OncogenicityClassification_Description
  ): RcvAccession_OncogenicityClassification_Description {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string value */ 1:
          message.value = reader.string()
          break
        case /* optional google.protobuf.Timestamp date_last_evaluated */ 2:
          message.dateLastEvaluated = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.dateLastEvaluated
          )
          break
        case /* optional uint32 submission_count */ 3:
          message.submissionCount = reader.uint32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: RcvAccession_OncogenicityClassification_Description,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string value = 1; */
    if (message.value !== '') writer.tag(1, WireType.LengthDelimited).string(message.value)
    /* optional google.protobuf.Timestamp date_last_evaluated = 2; */
    if (message.dateLastEvaluated)
      Timestamp.internalBinaryWrite(
        message.dateLastEvaluated,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional uint32 submission_count = 3; */
    if (message.submissionCount !== undefined)
      writer.tag(3, WireType.Varint).uint32(message.submissionCount)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.RcvAccession.OncogenicityClassification.Description
 */
export const RcvAccession_OncogenicityClassification_Description =
  new RcvAccession_OncogenicityClassification_Description$Type()
// @generated message type with reflection information, may provide speed optimized methods
class RcvAccession_RcvClassifications$Type extends MessageType<RcvAccession_RcvClassifications> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.RcvAccession.RcvClassifications', [
      {
        no: 1,
        name: 'germline_classification',
        kind: 'message',
        T: () => RcvAccession_GermlineClassification
      },
      {
        no: 2,
        name: 'somatic_clinical_impact',
        kind: 'message',
        T: () => RcvAccession_SomaticClinicalImpact
      },
      {
        no: 3,
        name: 'oncogenicity_classification',
        kind: 'message',
        T: () => RcvAccession_OncogenicityClassification
      }
    ])
  }
  create(value?: PartialMessage<RcvAccession_RcvClassifications>): RcvAccession_RcvClassifications {
    const message = globalThis.Object.create(this.messagePrototype!)
    if (value !== undefined)
      reflectionMergePartial<RcvAccession_RcvClassifications>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RcvAccession_RcvClassifications
  ): RcvAccession_RcvClassifications {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional annonars.clinvar_data.clinvar_public.RcvAccession.GermlineClassification germline_classification */ 1:
          message.germlineClassification = RcvAccession_GermlineClassification.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.germlineClassification
          )
          break
        case /* optional annonars.clinvar_data.clinvar_public.RcvAccession.SomaticClinicalImpact somatic_clinical_impact */ 2:
          message.somaticClinicalImpact = RcvAccession_SomaticClinicalImpact.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.somaticClinicalImpact
          )
          break
        case /* optional annonars.clinvar_data.clinvar_public.RcvAccession.OncogenicityClassification oncogenicity_classification */ 3:
          message.oncogenicityClassification =
            RcvAccession_OncogenicityClassification.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              message.oncogenicityClassification
            )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: RcvAccession_RcvClassifications,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional annonars.clinvar_data.clinvar_public.RcvAccession.GermlineClassification germline_classification = 1; */
    if (message.germlineClassification)
      RcvAccession_GermlineClassification.internalBinaryWrite(
        message.germlineClassification,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.clinvar_data.clinvar_public.RcvAccession.SomaticClinicalImpact somatic_clinical_impact = 2; */
    if (message.somaticClinicalImpact)
      RcvAccession_SomaticClinicalImpact.internalBinaryWrite(
        message.somaticClinicalImpact,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.clinvar_data.clinvar_public.RcvAccession.OncogenicityClassification oncogenicity_classification = 3; */
    if (message.oncogenicityClassification)
      RcvAccession_OncogenicityClassification.internalBinaryWrite(
        message.oncogenicityClassification,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.RcvAccession.RcvClassifications
 */
export const RcvAccession_RcvClassifications = new RcvAccession_RcvClassifications$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ClassifiedRecord$Type extends MessageType<ClassifiedRecord> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.ClassifiedRecord', [
      { no: 1, name: 'simple_allele', kind: 'message', T: () => Allele },
      { no: 2, name: 'haplotype', kind: 'message', T: () => Haplotype },
      { no: 3, name: 'genotype', kind: 'message', T: () => Genotype },
      { no: 4, name: 'rcv_list', kind: 'message', T: () => ClassifiedRecord_RcvList },
      { no: 5, name: 'classifications', kind: 'message', T: () => AggregateClassificationSet },
      {
        no: 6,
        name: 'clinical_assertions',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => ClinicalAssertion
      },
      {
        no: 7,
        name: 'trait_mappings',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => ClassifiedRecord_TraitMapping
      },
      {
        no: 8,
        name: 'deleted_scvs',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => DeletedScv
      },
      {
        no: 9,
        name: 'general_citations',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => GeneralCitations
      }
    ])
  }
  create(value?: PartialMessage<ClassifiedRecord>): ClassifiedRecord {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.clinicalAssertions = []
    message.traitMappings = []
    message.deletedScvs = []
    message.generalCitations = []
    if (value !== undefined) reflectionMergePartial<ClassifiedRecord>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ClassifiedRecord
  ): ClassifiedRecord {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional annonars.clinvar_data.clinvar_public.Allele simple_allele */ 1:
          message.simpleAllele = Allele.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.simpleAllele
          )
          break
        case /* optional annonars.clinvar_data.clinvar_public.Haplotype haplotype */ 2:
          message.haplotype = Haplotype.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.haplotype
          )
          break
        case /* optional annonars.clinvar_data.clinvar_public.Genotype genotype */ 3:
          message.genotype = Genotype.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.genotype
          )
          break
        case /* annonars.clinvar_data.clinvar_public.ClassifiedRecord.RcvList rcv_list */ 4:
          message.rcvList = ClassifiedRecord_RcvList.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.rcvList
          )
          break
        case /* annonars.clinvar_data.clinvar_public.AggregateClassificationSet classifications */ 5:
          message.classifications = AggregateClassificationSet.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.classifications
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.ClinicalAssertion clinical_assertions */ 6:
          message.clinicalAssertions.push(
            ClinicalAssertion.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.ClassifiedRecord.TraitMapping trait_mappings */ 7:
          message.traitMappings.push(
            ClassifiedRecord_TraitMapping.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.DeletedScv deleted_scvs */ 8:
          message.deletedScvs.push(DeletedScv.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.clinvar_data.clinvar_public.GeneralCitations general_citations */ 9:
          message.generalCitations.push(
            GeneralCitations.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ClassifiedRecord,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional annonars.clinvar_data.clinvar_public.Allele simple_allele = 1; */
    if (message.simpleAllele)
      Allele.internalBinaryWrite(
        message.simpleAllele,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.clinvar_data.clinvar_public.Haplotype haplotype = 2; */
    if (message.haplotype)
      Haplotype.internalBinaryWrite(
        message.haplotype,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.clinvar_data.clinvar_public.Genotype genotype = 3; */
    if (message.genotype)
      Genotype.internalBinaryWrite(
        message.genotype,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.clinvar_data.clinvar_public.ClassifiedRecord.RcvList rcv_list = 4; */
    if (message.rcvList)
      ClassifiedRecord_RcvList.internalBinaryWrite(
        message.rcvList,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.clinvar_data.clinvar_public.AggregateClassificationSet classifications = 5; */
    if (message.classifications)
      AggregateClassificationSet.internalBinaryWrite(
        message.classifications,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.ClinicalAssertion clinical_assertions = 6; */
    for (let i = 0; i < message.clinicalAssertions.length; i++)
      ClinicalAssertion.internalBinaryWrite(
        message.clinicalAssertions[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.ClassifiedRecord.TraitMapping trait_mappings = 7; */
    for (let i = 0; i < message.traitMappings.length; i++)
      ClassifiedRecord_TraitMapping.internalBinaryWrite(
        message.traitMappings[i],
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.DeletedScv deleted_scvs = 8; */
    for (let i = 0; i < message.deletedScvs.length; i++)
      DeletedScv.internalBinaryWrite(
        message.deletedScvs[i],
        writer.tag(8, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.GeneralCitations general_citations = 9; */
    for (let i = 0; i < message.generalCitations.length; i++)
      GeneralCitations.internalBinaryWrite(
        message.generalCitations[i],
        writer.tag(9, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.ClassifiedRecord
 */
export const ClassifiedRecord = new ClassifiedRecord$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ClassifiedRecord_RcvList$Type extends MessageType<ClassifiedRecord_RcvList> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.ClassifiedRecord.RcvList', [
      {
        no: 1,
        name: 'rcv_accessions',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => RcvAccession
      },
      { no: 2, name: 'submission_count', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      {
        no: 3,
        name: 'independent_observations',
        kind: 'scalar',
        opt: true,
        T: 5 /*ScalarType.INT32*/
      }
    ])
  }
  create(value?: PartialMessage<ClassifiedRecord_RcvList>): ClassifiedRecord_RcvList {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.rcvAccessions = []
    if (value !== undefined) reflectionMergePartial<ClassifiedRecord_RcvList>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ClassifiedRecord_RcvList
  ): ClassifiedRecord_RcvList {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated annonars.clinvar_data.clinvar_public.RcvAccession rcv_accessions */ 1:
          message.rcvAccessions.push(
            RcvAccession.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* optional int32 submission_count */ 2:
          message.submissionCount = reader.int32()
          break
        case /* optional int32 independent_observations */ 3:
          message.independentObservations = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ClassifiedRecord_RcvList,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated annonars.clinvar_data.clinvar_public.RcvAccession rcv_accessions = 1; */
    for (let i = 0; i < message.rcvAccessions.length; i++)
      RcvAccession.internalBinaryWrite(
        message.rcvAccessions[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional int32 submission_count = 2; */
    if (message.submissionCount !== undefined)
      writer.tag(2, WireType.Varint).int32(message.submissionCount)
    /* optional int32 independent_observations = 3; */
    if (message.independentObservations !== undefined)
      writer.tag(3, WireType.Varint).int32(message.independentObservations)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.ClassifiedRecord.RcvList
 */
export const ClassifiedRecord_RcvList = new ClassifiedRecord_RcvList$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ClassifiedRecord_TraitMapping$Type extends MessageType<ClassifiedRecord_TraitMapping> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.ClassifiedRecord.TraitMapping', [
      {
        no: 1,
        name: 'medgens',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => ClassifiedRecord_TraitMapping_Medgen
      },
      { no: 2, name: 'clinical_assertion_id', kind: 'scalar', T: 3 /*ScalarType.INT64*/ },
      { no: 3, name: 'trait_type', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 4,
        name: 'mapping_type',
        kind: 'enum',
        T: () => [
          'annonars.clinvar_data.clinvar_public.ClassifiedRecord.MappingType',
          ClassifiedRecord_MappingType
        ]
      },
      { no: 5, name: 'mapping_value', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 6, name: 'mapping_ref', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(value?: PartialMessage<ClassifiedRecord_TraitMapping>): ClassifiedRecord_TraitMapping {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.medgens = []
    message.clinicalAssertionId = '0'
    message.traitType = ''
    message.mappingType = 0
    message.mappingValue = ''
    message.mappingRef = ''
    if (value !== undefined)
      reflectionMergePartial<ClassifiedRecord_TraitMapping>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ClassifiedRecord_TraitMapping
  ): ClassifiedRecord_TraitMapping {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated annonars.clinvar_data.clinvar_public.ClassifiedRecord.TraitMapping.Medgen medgens */ 1:
          message.medgens.push(
            ClassifiedRecord_TraitMapping_Medgen.internalBinaryRead(
              reader,
              reader.uint32(),
              options
            )
          )
          break
        case /* int64 clinical_assertion_id */ 2:
          message.clinicalAssertionId = reader.int64().toString()
          break
        case /* string trait_type */ 3:
          message.traitType = reader.string()
          break
        case /* annonars.clinvar_data.clinvar_public.ClassifiedRecord.MappingType mapping_type */ 4:
          message.mappingType = reader.int32()
          break
        case /* string mapping_value */ 5:
          message.mappingValue = reader.string()
          break
        case /* string mapping_ref */ 6:
          message.mappingRef = reader.string()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ClassifiedRecord_TraitMapping,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated annonars.clinvar_data.clinvar_public.ClassifiedRecord.TraitMapping.Medgen medgens = 1; */
    for (let i = 0; i < message.medgens.length; i++)
      ClassifiedRecord_TraitMapping_Medgen.internalBinaryWrite(
        message.medgens[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* int64 clinical_assertion_id = 2; */
    if (message.clinicalAssertionId !== '0')
      writer.tag(2, WireType.Varint).int64(message.clinicalAssertionId)
    /* string trait_type = 3; */
    if (message.traitType !== '') writer.tag(3, WireType.LengthDelimited).string(message.traitType)
    /* annonars.clinvar_data.clinvar_public.ClassifiedRecord.MappingType mapping_type = 4; */
    if (message.mappingType !== 0) writer.tag(4, WireType.Varint).int32(message.mappingType)
    /* string mapping_value = 5; */
    if (message.mappingValue !== '')
      writer.tag(5, WireType.LengthDelimited).string(message.mappingValue)
    /* string mapping_ref = 6; */
    if (message.mappingRef !== '')
      writer.tag(6, WireType.LengthDelimited).string(message.mappingRef)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.ClassifiedRecord.TraitMapping
 */
export const ClassifiedRecord_TraitMapping = new ClassifiedRecord_TraitMapping$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ClassifiedRecord_TraitMapping_Medgen$Type extends MessageType<ClassifiedRecord_TraitMapping_Medgen> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.ClassifiedRecord.TraitMapping.Medgen', [
      { no: 1, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'cui', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(
    value?: PartialMessage<ClassifiedRecord_TraitMapping_Medgen>
  ): ClassifiedRecord_TraitMapping_Medgen {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.name = ''
    message.cui = ''
    if (value !== undefined)
      reflectionMergePartial<ClassifiedRecord_TraitMapping_Medgen>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ClassifiedRecord_TraitMapping_Medgen
  ): ClassifiedRecord_TraitMapping_Medgen {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string()
          break
        case /* string cui */ 2:
          message.cui = reader.string()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ClassifiedRecord_TraitMapping_Medgen,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== '') writer.tag(1, WireType.LengthDelimited).string(message.name)
    /* string cui = 2; */
    if (message.cui !== '') writer.tag(2, WireType.LengthDelimited).string(message.cui)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.ClassifiedRecord.TraitMapping.Medgen
 */
export const ClassifiedRecord_TraitMapping_Medgen = new ClassifiedRecord_TraitMapping_Medgen$Type()
// @generated message type with reflection information, may provide speed optimized methods
class VariationArchive$Type extends MessageType<VariationArchive> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.VariationArchive', [
      { no: 1, name: 'variation_id', kind: 'scalar', T: 3 /*ScalarType.INT64*/ },
      { no: 2, name: 'variation_name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'variation_type', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: 'date_created', kind: 'message', T: () => Timestamp },
      { no: 5, name: 'date_last_updated', kind: 'message', T: () => Timestamp },
      { no: 6, name: 'most_recent_submission', kind: 'message', T: () => Timestamp },
      { no: 7, name: 'accession', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 8, name: 'version', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 9, name: 'number_of_submitters', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 10, name: 'number_of_submissions', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      {
        no: 11,
        name: 'record_type',
        kind: 'enum',
        T: () => [
          'annonars.clinvar_data.clinvar_public.VariationArchive.RecordType',
          VariationArchive_RecordType
        ]
      },
      {
        no: 12,
        name: 'record_status',
        kind: 'enum',
        T: () => [
          'annonars.clinvar_data.clinvar_public.VariationArchive.RecordStatus',
          VariationArchive_RecordStatus
        ]
      },
      { no: 13, name: 'replaced_by', kind: 'message', T: () => RecordHistory },
      {
        no: 14,
        name: 'replaceds',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => RecordHistory
      },
      { no: 15, name: 'comment', kind: 'message', T: () => Comment },
      { no: 16, name: 'species', kind: 'message', T: () => Species },
      { no: 17, name: 'classified_record', kind: 'message', T: () => ClassifiedRecord },
      { no: 18, name: 'included_record', kind: 'message', T: () => IncludedRecord }
    ])
  }
  create(value?: PartialMessage<VariationArchive>): VariationArchive {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.variationId = '0'
    message.variationName = ''
    message.variationType = ''
    message.accession = ''
    message.version = 0
    message.numberOfSubmitters = 0
    message.numberOfSubmissions = 0
    message.recordType = 0
    message.recordStatus = 0
    message.replaceds = []
    if (value !== undefined) reflectionMergePartial<VariationArchive>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: VariationArchive
  ): VariationArchive {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* int64 variation_id */ 1:
          message.variationId = reader.int64().toString()
          break
        case /* string variation_name */ 2:
          message.variationName = reader.string()
          break
        case /* string variation_type */ 3:
          message.variationType = reader.string()
          break
        case /* google.protobuf.Timestamp date_created */ 4:
          message.dateCreated = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.dateCreated
          )
          break
        case /* google.protobuf.Timestamp date_last_updated */ 5:
          message.dateLastUpdated = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.dateLastUpdated
          )
          break
        case /* google.protobuf.Timestamp most_recent_submission */ 6:
          message.mostRecentSubmission = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.mostRecentSubmission
          )
          break
        case /* string accession */ 7:
          message.accession = reader.string()
          break
        case /* int32 version */ 8:
          message.version = reader.int32()
          break
        case /* int32 number_of_submitters */ 9:
          message.numberOfSubmitters = reader.int32()
          break
        case /* int32 number_of_submissions */ 10:
          message.numberOfSubmissions = reader.int32()
          break
        case /* annonars.clinvar_data.clinvar_public.VariationArchive.RecordType record_type */ 11:
          message.recordType = reader.int32()
          break
        case /* annonars.clinvar_data.clinvar_public.VariationArchive.RecordStatus record_status */ 12:
          message.recordStatus = reader.int32()
          break
        case /* annonars.clinvar_data.clinvar_public.RecordHistory replaced_by */ 13:
          message.replacedBy = RecordHistory.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.replacedBy
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.RecordHistory replaceds */ 14:
          message.replaceds.push(RecordHistory.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* annonars.clinvar_data.clinvar_public.Comment comment */ 15:
          message.comment = Comment.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.comment
          )
          break
        case /* annonars.clinvar_data.clinvar_public.Species species */ 16:
          message.species = Species.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.species
          )
          break
        case /* optional annonars.clinvar_data.clinvar_public.ClassifiedRecord classified_record */ 17:
          message.classifiedRecord = ClassifiedRecord.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.classifiedRecord
          )
          break
        case /* optional annonars.clinvar_data.clinvar_public.IncludedRecord included_record */ 18:
          message.includedRecord = IncludedRecord.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.includedRecord
          )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: VariationArchive,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* int64 variation_id = 1; */
    if (message.variationId !== '0') writer.tag(1, WireType.Varint).int64(message.variationId)
    /* string variation_name = 2; */
    if (message.variationName !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.variationName)
    /* string variation_type = 3; */
    if (message.variationType !== '')
      writer.tag(3, WireType.LengthDelimited).string(message.variationType)
    /* google.protobuf.Timestamp date_created = 4; */
    if (message.dateCreated)
      Timestamp.internalBinaryWrite(
        message.dateCreated,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* google.protobuf.Timestamp date_last_updated = 5; */
    if (message.dateLastUpdated)
      Timestamp.internalBinaryWrite(
        message.dateLastUpdated,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* google.protobuf.Timestamp most_recent_submission = 6; */
    if (message.mostRecentSubmission)
      Timestamp.internalBinaryWrite(
        message.mostRecentSubmission,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* string accession = 7; */
    if (message.accession !== '') writer.tag(7, WireType.LengthDelimited).string(message.accession)
    /* int32 version = 8; */
    if (message.version !== 0) writer.tag(8, WireType.Varint).int32(message.version)
    /* int32 number_of_submitters = 9; */
    if (message.numberOfSubmitters !== 0)
      writer.tag(9, WireType.Varint).int32(message.numberOfSubmitters)
    /* int32 number_of_submissions = 10; */
    if (message.numberOfSubmissions !== 0)
      writer.tag(10, WireType.Varint).int32(message.numberOfSubmissions)
    /* annonars.clinvar_data.clinvar_public.VariationArchive.RecordType record_type = 11; */
    if (message.recordType !== 0) writer.tag(11, WireType.Varint).int32(message.recordType)
    /* annonars.clinvar_data.clinvar_public.VariationArchive.RecordStatus record_status = 12; */
    if (message.recordStatus !== 0) writer.tag(12, WireType.Varint).int32(message.recordStatus)
    /* annonars.clinvar_data.clinvar_public.RecordHistory replaced_by = 13; */
    if (message.replacedBy)
      RecordHistory.internalBinaryWrite(
        message.replacedBy,
        writer.tag(13, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.RecordHistory replaceds = 14; */
    for (let i = 0; i < message.replaceds.length; i++)
      RecordHistory.internalBinaryWrite(
        message.replaceds[i],
        writer.tag(14, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.clinvar_data.clinvar_public.Comment comment = 15; */
    if (message.comment)
      Comment.internalBinaryWrite(
        message.comment,
        writer.tag(15, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.clinvar_data.clinvar_public.Species species = 16; */
    if (message.species)
      Species.internalBinaryWrite(
        message.species,
        writer.tag(16, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.clinvar_data.clinvar_public.ClassifiedRecord classified_record = 17; */
    if (message.classifiedRecord)
      ClassifiedRecord.internalBinaryWrite(
        message.classifiedRecord,
        writer.tag(17, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.clinvar_data.clinvar_public.IncludedRecord included_record = 18; */
    if (message.includedRecord)
      IncludedRecord.internalBinaryWrite(
        message.includedRecord,
        writer.tag(18, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.VariationArchive
 */
export const VariationArchive = new VariationArchive$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ClinvarVariationRelease$Type extends MessageType<ClinvarVariationRelease> {
  constructor() {
    super('annonars.clinvar_data.clinvar_public.ClinvarVariationRelease', [
      { no: 1, name: 'release_date', kind: 'message', T: () => Timestamp },
      {
        no: 2,
        name: 'variation_archives',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => VariationArchive
      }
    ])
  }
  create(value?: PartialMessage<ClinvarVariationRelease>): ClinvarVariationRelease {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.variationArchives = []
    if (value !== undefined) reflectionMergePartial<ClinvarVariationRelease>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ClinvarVariationRelease
  ): ClinvarVariationRelease {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* google.protobuf.Timestamp release_date */ 1:
          message.releaseDate = Timestamp.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.releaseDate
          )
          break
        case /* repeated annonars.clinvar_data.clinvar_public.VariationArchive variation_archives */ 2:
          message.variationArchives.push(
            VariationArchive.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ClinvarVariationRelease,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* google.protobuf.Timestamp release_date = 1; */
    if (message.releaseDate)
      Timestamp.internalBinaryWrite(
        message.releaseDate,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.clinvar_public.VariationArchive variation_archives = 2; */
    for (let i = 0; i < message.variationArchives.length; i++)
      VariationArchive.internalBinaryWrite(
        message.variationArchives[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.clinvar_public.ClinvarVariationRelease
 */
export const ClinvarVariationRelease = new ClinvarVariationRelease$Type()
