// @generated by protobuf-ts 2.9.3 with parameter keep_enum_prefix,long_type_string
// @generated from protobuf file "annonars/clinvar_data/extracted_vars.proto" (package "annonars.clinvar_data.extracted_vars", syntax proto3)
// tslint:disable
//
// Protocol buffers to store the extracted variants from ClinVar.
//
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'

import { Location_SequenceLocation } from './clinvar_public'
import { AggregateClassificationSet } from './clinvar_public'
import { RcvAccession_RcvClassifications } from './clinvar_public'

/**
 * Accession with version.
 *
 * @generated from protobuf message annonars.clinvar_data.extracted_vars.VersionedAccession
 */
export interface VersionedAccession {
  /**
   * The accession.
   *
   * @generated from protobuf field: string accession = 1;
   */
  accession: string
  /**
   * The version.
   *
   * @generated from protobuf field: int32 version = 2;
   */
  version: number
}
/**
 * Protocol buffer for storing essential information of one RCV.
 *
 * @generated from protobuf message annonars.clinvar_data.extracted_vars.ExtractedRcvRecord
 */
export interface ExtractedRcvRecord {
  /**
   * The accession.
   *
   * @generated from protobuf field: annonars.clinvar_data.extracted_vars.VersionedAccession accession = 1;
   */
  accession?: VersionedAccession
  /**
   * Title of RCV.
   *
   * @generated from protobuf field: string title = 2;
   */
  title: string
  /**
   * Classifications (thinned out).
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.RcvAccession.RcvClassifications classifications = 3;
   */
  classifications?: RcvAccession_RcvClassifications
}
/**
 * Protocol buffer for storing essential information of one VCV.
 *
 * @generated from protobuf message annonars.clinvar_data.extracted_vars.ExtractedVcvRecord
 */
export interface ExtractedVcvRecord {
  /**
   * The accession.
   *
   * @generated from protobuf field: annonars.clinvar_data.extracted_vars.VersionedAccession accession = 1;
   */
  accession?: VersionedAccession
  /**
   * List of aggregated RCVs.
   *
   * @generated from protobuf field: repeated annonars.clinvar_data.extracted_vars.ExtractedRcvRecord rcvs = 2;
   */
  rcvs: ExtractedRcvRecord[]
  /**
   * Name of VCV.
   *
   * @generated from protobuf field: string name = 3;
   */
  name: string
  /**
   * The type of the variant.
   *
   * @generated from protobuf field: annonars.clinvar_data.extracted_vars.VariationType variation_type = 4;
   */
  variationType: VariationType
  /**
   * Classifications (thinned out).
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.AggregateClassificationSet classifications = 5;
   */
  classifications?: AggregateClassificationSet
  /**
   * The sequence location on one reference.
   *
   * @generated from protobuf field: annonars.clinvar_data.clinvar_public.Location.SequenceLocation sequence_location = 6;
   */
  sequenceLocation?: Location_SequenceLocation
  /**
   * List of HGNC IDs.
   *
   * @generated from protobuf field: repeated string hgnc_ids = 7;
   */
  hgncIds: string[]
}
/**
 * Enumeration for the type of the variant.
 *
 * @generated from protobuf enum annonars.clinvar_data.extracted_vars.VariationType
 */
export enum VariationType {
  /**
   * unspecified variation type
   *
   * @generated from protobuf enum value: VARIATION_TYPE_UNSPECIFIED = 0;
   */
  VARIATION_TYPE_UNSPECIFIED = 0,
  /**
   * Corresponds to "insertion".
   *
   * @generated from protobuf enum value: VARIATION_TYPE_INSERTION = 1;
   */
  VARIATION_TYPE_INSERTION = 1,
  /**
   * Corresponds to "deletion".
   *
   * @generated from protobuf enum value: VARIATION_TYPE_DELETION = 2;
   */
  VARIATION_TYPE_DELETION = 2,
  /**
   * Corresponds to "single nucleotide variant".
   *
   * @generated from protobuf enum value: VARIATION_TYPE_SNV = 3;
   */
  VARIATION_TYPE_SNV = 3,
  /**
   * Corresponds to "indel".
   *
   * @generated from protobuf enum value: VARIATION_TYPE_INDEL = 4;
   */
  VARIATION_TYPE_INDEL = 4,
  /**
   * Corresponds to "duplication".
   *
   * @generated from protobuf enum value: VARIATION_TYPE_DUPLICATION = 5;
   */
  VARIATION_TYPE_DUPLICATION = 5,
  /**
   * Corresponds to "tandem duplication".
   *
   * @generated from protobuf enum value: VARIATION_TYPE_TANDEM_DUPLICATION = 6;
   */
  VARIATION_TYPE_TANDEM_DUPLICATION = 6,
  /**
   * Corresponds to "structural variant".
   *
   * @generated from protobuf enum value: VARIATION_TYPE_STRUCTURAL_VARIANT = 7;
   */
  VARIATION_TYPE_STRUCTURAL_VARIANT = 7,
  /**
   * Corresponds to "copy number gain".
   *
   * @generated from protobuf enum value: VARIATION_TYPE_COPY_NUMBER_GAIN = 8;
   */
  VARIATION_TYPE_COPY_NUMBER_GAIN = 8,
  /**
   * Corresponds to "copy number loss".
   *
   * @generated from protobuf enum value: VARIATION_TYPE_COPY_NUMBER_LOSS = 9;
   */
  VARIATION_TYPE_COPY_NUMBER_LOSS = 9,
  /**
   * Corresponds to "protein only".
   *
   * @generated from protobuf enum value: VARIATION_TYPE_PROTEIN_ONLY = 10;
   */
  VARIATION_TYPE_PROTEIN_ONLY = 10,
  /**
   * Corresponds to "microsatellite".
   *
   * @generated from protobuf enum value: VARIATION_TYPE_MICROSATELLITE = 11;
   */
  VARIATION_TYPE_MICROSATELLITE = 11,
  /**
   * Corresponds to "inversion".
   *
   * @generated from protobuf enum value: VARIATION_TYPE_INVERSION = 12;
   */
  VARIATION_TYPE_INVERSION = 12,
  /**
   * Corresponds to "other".
   *
   * @generated from protobuf enum value: VARIATION_TYPE_OTHER = 13;
   */
  VARIATION_TYPE_OTHER = 13
}
// @generated message type with reflection information, may provide speed optimized methods
class VersionedAccession$Type extends MessageType<VersionedAccession> {
  constructor() {
    super('annonars.clinvar_data.extracted_vars.VersionedAccession', [
      { no: 1, name: 'accession', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'version', kind: 'scalar', T: 5 /*ScalarType.INT32*/ }
    ])
  }
  create(value?: PartialMessage<VersionedAccession>): VersionedAccession {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.accession = ''
    message.version = 0
    if (value !== undefined) reflectionMergePartial<VersionedAccession>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: VersionedAccession
  ): VersionedAccession {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string accession */ 1:
          message.accession = reader.string()
          break
        case /* int32 version */ 2:
          message.version = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: VersionedAccession,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string accession = 1; */
    if (message.accession !== '') writer.tag(1, WireType.LengthDelimited).string(message.accession)
    /* int32 version = 2; */
    if (message.version !== 0) writer.tag(2, WireType.Varint).int32(message.version)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.extracted_vars.VersionedAccession
 */
export const VersionedAccession = new VersionedAccession$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ExtractedRcvRecord$Type extends MessageType<ExtractedRcvRecord> {
  constructor() {
    super('annonars.clinvar_data.extracted_vars.ExtractedRcvRecord', [
      { no: 1, name: 'accession', kind: 'message', T: () => VersionedAccession },
      { no: 2, name: 'title', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'classifications', kind: 'message', T: () => RcvAccession_RcvClassifications }
    ])
  }
  create(value?: PartialMessage<ExtractedRcvRecord>): ExtractedRcvRecord {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.title = ''
    if (value !== undefined) reflectionMergePartial<ExtractedRcvRecord>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ExtractedRcvRecord
  ): ExtractedRcvRecord {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* annonars.clinvar_data.extracted_vars.VersionedAccession accession */ 1:
          message.accession = VersionedAccession.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.accession
          )
          break
        case /* string title */ 2:
          message.title = reader.string()
          break
        case /* annonars.clinvar_data.clinvar_public.RcvAccession.RcvClassifications classifications */ 3:
          message.classifications = RcvAccession_RcvClassifications.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.classifications
          )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ExtractedRcvRecord,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* annonars.clinvar_data.extracted_vars.VersionedAccession accession = 1; */
    if (message.accession)
      VersionedAccession.internalBinaryWrite(
        message.accession,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* string title = 2; */
    if (message.title !== '') writer.tag(2, WireType.LengthDelimited).string(message.title)
    /* annonars.clinvar_data.clinvar_public.RcvAccession.RcvClassifications classifications = 3; */
    if (message.classifications)
      RcvAccession_RcvClassifications.internalBinaryWrite(
        message.classifications,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.extracted_vars.ExtractedRcvRecord
 */
export const ExtractedRcvRecord = new ExtractedRcvRecord$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ExtractedVcvRecord$Type extends MessageType<ExtractedVcvRecord> {
  constructor() {
    super('annonars.clinvar_data.extracted_vars.ExtractedVcvRecord', [
      { no: 1, name: 'accession', kind: 'message', T: () => VersionedAccession },
      {
        no: 2,
        name: 'rcvs',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => ExtractedRcvRecord
      },
      { no: 3, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 4,
        name: 'variation_type',
        kind: 'enum',
        T: () => ['annonars.clinvar_data.extracted_vars.VariationType', VariationType]
      },
      { no: 5, name: 'classifications', kind: 'message', T: () => AggregateClassificationSet },
      { no: 6, name: 'sequence_location', kind: 'message', T: () => Location_SequenceLocation },
      {
        no: 7,
        name: 'hgnc_ids',
        kind: 'scalar',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/
      }
    ])
  }
  create(value?: PartialMessage<ExtractedVcvRecord>): ExtractedVcvRecord {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.rcvs = []
    message.name = ''
    message.variationType = 0
    message.hgncIds = []
    if (value !== undefined) reflectionMergePartial<ExtractedVcvRecord>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ExtractedVcvRecord
  ): ExtractedVcvRecord {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* annonars.clinvar_data.extracted_vars.VersionedAccession accession */ 1:
          message.accession = VersionedAccession.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.accession
          )
          break
        case /* repeated annonars.clinvar_data.extracted_vars.ExtractedRcvRecord rcvs */ 2:
          message.rcvs.push(ExtractedRcvRecord.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* string name */ 3:
          message.name = reader.string()
          break
        case /* annonars.clinvar_data.extracted_vars.VariationType variation_type */ 4:
          message.variationType = reader.int32()
          break
        case /* annonars.clinvar_data.clinvar_public.AggregateClassificationSet classifications */ 5:
          message.classifications = AggregateClassificationSet.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.classifications
          )
          break
        case /* annonars.clinvar_data.clinvar_public.Location.SequenceLocation sequence_location */ 6:
          message.sequenceLocation = Location_SequenceLocation.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.sequenceLocation
          )
          break
        case /* repeated string hgnc_ids */ 7:
          message.hgncIds.push(reader.string())
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: ExtractedVcvRecord,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* annonars.clinvar_data.extracted_vars.VersionedAccession accession = 1; */
    if (message.accession)
      VersionedAccession.internalBinaryWrite(
        message.accession,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.clinvar_data.extracted_vars.ExtractedRcvRecord rcvs = 2; */
    for (let i = 0; i < message.rcvs.length; i++)
      ExtractedRcvRecord.internalBinaryWrite(
        message.rcvs[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* string name = 3; */
    if (message.name !== '') writer.tag(3, WireType.LengthDelimited).string(message.name)
    /* annonars.clinvar_data.extracted_vars.VariationType variation_type = 4; */
    if (message.variationType !== 0) writer.tag(4, WireType.Varint).int32(message.variationType)
    /* annonars.clinvar_data.clinvar_public.AggregateClassificationSet classifications = 5; */
    if (message.classifications)
      AggregateClassificationSet.internalBinaryWrite(
        message.classifications,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.clinvar_data.clinvar_public.Location.SequenceLocation sequence_location = 6; */
    if (message.sequenceLocation)
      Location_SequenceLocation.internalBinaryWrite(
        message.sequenceLocation,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated string hgnc_ids = 7; */
    for (let i = 0; i < message.hgncIds.length; i++)
      writer.tag(7, WireType.LengthDelimited).string(message.hgncIds[i])
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.clinvar_data.extracted_vars.ExtractedVcvRecord
 */
export const ExtractedVcvRecord = new ExtractedVcvRecord$Type()
