// @generated by protobuf-ts 2.9.3 with parameter keep_enum_prefix
// @generated from protobuf file "annonars/gnomad/mtdna.proto" (package "annonars.gnomad.mtdna", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'

import { Vep } from './vep_gnomad3'

/**
 * Encapsulate VCF INFO fields related to quality.
 *
 * @generated from protobuf message annonars.gnomad.mtdna.QualityInfo
 */
export interface QualityInfo {
  /**
   * Mean depth across all individuals for the site.
   *
   * @generated from protobuf field: optional float dp_mean = 1;
   */
  dpMean?: number
  /**
   * Mean MMQ (median mapping quality) across individuals with a variant for the site.
   *
   * @generated from protobuf field: optional float mq_mean = 2;
   */
  mqMean?: number
  /**
   * Mean TLOD (Log 10 likelihood ratio score of variant existing versus not existing) across
   * individuals with a variant for the site.
   *
   * @generated from protobuf field: optional float tlod_mean = 3;
   */
  tlodMean?: number
}
/**
 * Encapsulate VCF INFO fields related to heteroplasmy levels.
 *
 * @generated from protobuf message annonars.gnomad.mtdna.HeteroplasmyInfo
 */
export interface HeteroplasmyInfo {
  /**
   * Histogram of number of individuals with a heteroplasmy level below 0.1, bin edges are: [0.0,
   * 0.1, 0.2, 0.30000000000000004, 0.4, 0.5, 0.6000000000000001, 0.7000000000000001, 0.8, 0.9,
   * 1.0]
   *
   * @generated from protobuf field: repeated int32 heteroplasmy_below_min_het_threshold_hist = 1;
   */
  heteroplasmyBelowMinHetThresholdHist: number[]
  /**
   * Histogram of heteroplasmy levels; bin edges are: [0.0, 0.1, 0.2, 0.30000000000000004, 0.4,
   * 0.5, 0.6000000000000001, 0.7000000000000001, 0.8, 0.9, 1.0].
   *
   * @generated from protobuf field: repeated int32 hl_hist = 2;
   */
  hlHist: number[]
  /**
   * Present if variant is found at an overall frequency of .001 across all samples with a
   * heteroplasmy level > 0 and < 0.50 (includes variants <0.01 heteroplasmy which are
   * subsequently filtered)
   *
   * @generated from protobuf field: bool common_low_heteroplasmy = 3;
   */
  commonLowHeteroplasmy: boolean
  /**
   * Maximum heteroplasmy level observed among all samples for that variant.
   *
   * @generated from protobuf field: float max_hl = 4;
   */
  maxHl: number
}
/**
 * Encapsulate VCF INFO fields related to filter failure histograms.
 *
 * @generated from protobuf message annonars.gnomad.mtdna.FilterHistograms
 */
export interface FilterHistograms {
  /**
   * Histogram of number of individuals failing the base_qual filter (alternate allele median base
   * quality) across heteroplasmy levels, bin edges are: [0.0, 0.1, 0.2, 0.30000000000000004, 0.4,
   * 0.5, 0.6000000000000001, 0.7000000000000001, 0.8, 0.9, 1.0]
   *
   * @generated from protobuf field: repeated int32 base_qual_hist = 1;
   */
  baseQualHist: number[]
  /**
   * Histogram of number of individuals failing the position filter (median distance of alternate
   * variants from end of reads) across heteroplasmy levels, bin edges are: [0.0, 0.1, 0.2, 0.
   * 30000000000000004, 0.4, 0.5, 0.6000000000000001, 0.7000000000000001, 0.8, 0.9, 1.0]
   *
   * @generated from protobuf field: repeated int32 position_hist = 2;
   */
  positionHist: number[]
  /**
   * Histogram of number of individuals failing the strand_bias filter (evidence for alternate
   * allele comes from one read direction only) across heteroplasmy levels, bin edges are: [0.0,
   * 0.1, 0.2, 0.30000000000000004, 0.4, 0.5, 0.6000000000000001, 0.7000000000000001, 0.8, 0.9,
   * 1.0]
   *
   * @generated from protobuf field: repeated int32 strand_bias_hist = 3;
   */
  strandBiasHist: number[]
  /**
   * Histogram of number of individuals failing the weak_evidence filter (mutation does not meet
   * likelihood threshold) across heteroplasmy levels, bin edges are: [0.0, 0.1, 0.2,
   * 0.30000000000000004, 0.4, 0.5, 0.6000000000000001, 0.7000000000000001, 0.8, 0.9, 1.0]
   *
   * @generated from protobuf field: repeated int32 weak_evidence_hist = 4;
   */
  weakEvidenceHist: number[]
  /**
   * Histogram of number of individuals failing the contamination filter across heteroplasmy
   * levels, bin edges are: [0.0, 0.1, 0.2, 0.30000000000000004, 0.4, 0.5, 0.6000000000000001,
   * 0.7000000000000001, 0.8, 0.9, 1.0]
   *
   * @generated from protobuf field: repeated int32 contamination_hist = 5;
   */
  contaminationHist: number[]
}
/**
 * Encapsulate VCF INFO fields related to populations.
 *
 * @generated from protobuf message annonars.gnomad.mtdna.PopulationInfo
 */
export interface PopulationInfo {
  /**
   * List of overall allele number for each population, population order: ['afr', 'ami', 'amr',
   * 'asj', 'eas', 'fin', 'nfe', 'oth', 'sas', 'mid']
   *
   * @generated from protobuf field: repeated int32 pop_an = 1;
   */
  popAn: number[]
  /**
   * List of AC_het for each population, population order: ['afr', 'ami', 'amr', 'asj', 'eas',
   * 'fin', 'nfe', 'oth', 'sas', 'mid']
   *
   * @generated from protobuf field: repeated int32 pop_ac_het = 2;
   */
  popAcHet: number[]
  /**
   * List of AC_hom for each population, population order: ['afr', 'ami', 'amr', 'asj', 'eas',
   * 'fin', 'nfe', 'oth', 'sas', 'mid']
   *
   * @generated from protobuf field: repeated int32 pop_ac_hom = 3;
   */
  popAcHom: number[]
  /**
   * List of AF_hom for each population, population order: ['afr', 'ami', 'amr', 'asj', 'eas',
   * 'fin', 'nfe', 'oth', 'sas', 'mid']
   *
   * @generated from protobuf field: repeated float pop_af_hom = 4;
   */
  popAfHom: number[]
  /**
   * List of AF_het for each population, population order: ['afr', 'ami', 'amr', 'asj', 'eas',
   * 'fin', 'nfe', 'oth', 'sas', 'mid']
   *
   * @generated from protobuf field: repeated float pop_af_het = 5;
   */
  popAfHet: number[]
  /**
   * Histogram of heteroplasmy levels for each population; bin edges are: [0.0, 0.1, 0.2,
   * 0.30000000000000004, 0.4, 0.5, 0.6000000000000001, 0.7000000000000001, 0.8, 0.9, 1.0],
   * population order: ['afr', 'ami', 'amr', 'asj', 'eas', 'fin', 'nfe', 'oth', 'sas', 'mid']
   *
   * Note that we encode this by concatenating all lists here because of limitations in
   * protocolbuffers (no native nested repeated fields).
   *
   * @generated from protobuf field: repeated int32 pop_hl_hist = 6;
   */
  popHlHist: number[]
}
/**
 * Encapsulate VCF INFO fields related to haplogroups.
 *
 * @generated from protobuf message annonars.gnomad.mtdna.HaplogroupInfo
 */
export interface HaplogroupInfo {
  /**
   * Present if variant is present as a haplogroup defining variant in PhyloTree build 17.
   *
   * @generated from protobuf field: bool hap_defining_variant = 1;
   */
  hapDefiningVariant: boolean
  /**
   * List of overall allele number for each haplogroup, haplogroup order: ['A', 'B', 'C', 'D',
   * 'E', 'F', 'G', 'H', 'HV', 'I', 'J', 'K', 'L0', 'L1', 'L2', 'L3', 'L4', 'L5', 'M', 'N', 'P',
   * 'R', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']
   *
   * @generated from protobuf field: repeated int32 hap_an = 2;
   */
  hapAn: number[]
  /**
   * List of AC_het for each haplogroup, haplogroup order: ['A', 'B', 'C', 'D', 'E', 'F', 'G',
   * 'H', 'HV', 'I', 'J', 'K', 'L0', 'L1', 'L2', 'L3', 'L4', 'L5', 'M', 'N', 'P', 'R', 'T', 'U',
   * 'V', 'W', 'X', 'Y', 'Z']
   *
   * @generated from protobuf field: repeated int32 hap_ac_het = 3;
   */
  hapAcHet: number[]
  /**
   * List of AC_hom for each haplogroup, haplogroup order: ['A', 'B', 'C', 'D', 'E', 'F', 'G',
   * 'H', 'HV', 'I', 'J', 'K', 'L0', 'L1', 'L2', 'L3', 'L4', 'L5', 'M', 'N', 'P', 'R', 'T', 'U',
   * 'V', 'W', 'X', 'Y', 'Z']
   *
   * @generated from protobuf field: repeated int32 hap_ac_hom = 4;
   */
  hapAcHom: number[]
  /**
   * List of AF_het for each haplogroup, haplogroup order: ['A', 'B', 'C', 'D', 'E', 'F', 'G',
   * 'H', 'HV', 'I', 'J', 'K', 'L0', 'L1', 'L2', 'L3', 'L4', 'L5', 'M', 'N', 'P', 'R', 'T', 'U',
   * 'V', 'W', 'X', 'Y', 'Z']
   *
   * @generated from protobuf field: repeated float hap_af_het = 5;
   */
  hapAfHet: number[]
  /**
   * List of AF_hom for each haplogroup, haplogroup order: ['A', 'B', 'C', 'D', 'E', 'F', 'G',
   * 'H', 'HV', 'I', 'J', 'K', 'L0', 'L1', 'L2', 'L3', 'L4', 'L5', 'M', 'N', 'P', 'R', 'T', 'U',
   * 'V', 'W', 'X', 'Y', 'Z']
   *
   * @generated from protobuf field: repeated float hap_af_hom = 6;
   */
  hapAfHom: number[]
  /**
   * Histogram of heteroplasmy levels for each haplogroup; bin edges are: [0.0, 0.1, 0.2,
   * 0.30000000000000004, 0.4, 0.5, 0.6000000000000001, 0.7000000000000001, 0.8, 0.9, 1.0],
   * haplogroup order: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'HV', 'I', 'J', 'K', 'L0', 'L1',
   * 'L2', 'L3', 'L4', 'L5', 'M', 'N', 'P', 'R', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']
   *
   * Note that we encode this by concatenating all lists here because of limitations in
   * protocolbuffers (no native nested repeated fields).
   *
   * @generated from protobuf field: repeated int32 hap_hl_hist = 7;
   */
  hapHlHist: number[]
  /**
   * List of filtering allele frequency for each haplogroup restricted to homoplasmic variants,
   * haplogroup order: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'HV', 'I', 'J', 'K', 'L0', 'L1',
   * 'L2', 'L3', 'L4', 'L5', 'M', 'N', 'P', 'R', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']
   *
   * @generated from protobuf field: repeated float hap_faf_hom = 8;
   */
  hapFafHom: number[]
  /**
   * Haplogroup with maximum AF_hom.
   *
   * @generated from protobuf field: optional string hapmax_af_hom = 9;
   */
  hapmaxAfHom?: string
  /**
   * Haplogroup with maximum AF_het.
   *
   * @generated from protobuf field: optional string hapmax_af_het = 10;
   */
  hapmaxAfHet?: string
  /**
   * Maximum filtering allele frequency across haplogroups restricted to homoplasmic variants.
   *
   * @generated from protobuf field: optional float faf_hapmax_hom = 11;
   */
  fafHapmaxHom?: number
}
/**
 * Encapsulate VCF INFO fields related to age.
 *
 * @generated from protobuf message annonars.gnomad.mtdna.AgeInfo
 */
export interface AgeInfo {
  /**
   * Histogram of ages of individuals with a homoplasmic variant; bin edges are: [30.0, 35.0,
   * 40.0, 45.0, 50.0, 55.0, 60.0, 65.0, 70.0, 75.0, 80.0].
   *
   * @generated from protobuf field: repeated int32 age_hist_hom_bin_freq = 1;
   */
  ageHistHomBinFreq: number[]
  /**
   * Count of age values falling below lowest histogram bin edge for individuals with a
   * homoplasmic variant.
   *
   * @generated from protobuf field: optional int32 age_hist_hom_n_smaller = 2;
   */
  ageHistHomNSmaller?: number
  /**
   * Count of age values falling above highest histogram bin edge for individuals with a
   * homoplasmic variant.
   *
   * @generated from protobuf field: optional int32 age_hist_hom_n_larger = 3;
   */
  ageHistHomNLarger?: number
  /**
   * Histogram of ages of individuals with a heteroplasmic variant; bin edges are: [30.0, 35.0,
   * 40.0, 45.0, 50.0, 55.0, 60.0, 65.0, 70.0, 75.0, 80.0]
   *
   * @generated from protobuf field: repeated int32 age_hist_het_bin_freq = 4;
   */
  ageHistHetBinFreq: number[]
  /**
   * Count of age values falling below lowest histogram bin edge for individuals with a
   * heteroplasmic variant.
   *
   * @generated from protobuf field: optional int32 age_hist_het_n_smaller = 5;
   */
  ageHistHetNSmaller?: number
  /**
   * Count of age values falling above highest histogram bin edge for individuals with a
   * heteroplasmic variant.
   *
   * @generated from protobuf field: optional int32 age_hist_het_n_larger = 6;
   */
  ageHistHetNLarger?: number
}
/**
 * Encapsulate VCF INFO fields related to depth.
 *
 * @generated from protobuf message annonars.gnomad.mtdna.DepthInfo
 */
export interface DepthInfo {
  /**
   * Count of dp values falling above highest histogram bin edge for all individuals.
   *
   * @generated from protobuf field: optional int32 dp_hist_all_n_larger = 1;
   */
  dpHistAllNLarger?: number
  /**
   * Count of dp values falling above highest histogram bin edge for individuals with the
   * alternative allele
   *
   * @generated from protobuf field: optional int32 dp_hist_alt_n_larger = 2;
   */
  dpHistAltNLarger?: number
  /**
   * Histogram of dp values for all individuals; bin edges are: [0.0, 200.0, 400.0, 600.0, 800.0,
   * 1000.0, 1200.0, 1400.0, 1600.0, 1800.0, 2000.0]
   *
   * @generated from protobuf field: repeated int32 dp_hist_all_bin_freq = 3;
   */
  dpHistAllBinFreq: number[]
  /**
   * Histogram of dp values for individuals with the alternative allele; bin edges are: [0.0,
   * 200.0, 400.0, 600.0, 800.0, 1000.0, 1200.0, 1400.0, 1600.0, 1800.0, 2000.0]
   *
   * @generated from protobuf field: repeated int32 dp_hist_alt_bin_freq = 4;
   */
  dpHistAltBinFreq: number[]
}
/**
 * Protocol buffer for the gnomAD-mtDNA VCF record.
 *
 * The more specialized fields from the INFO column are stored in separate, optional fields such
 * that we don't end up with a humongous message.
 *
 * @generated from protobuf message annonars.gnomad.mtdna.Record
 */
export interface Record {
  /**
   * Chromosome name.
   *
   * @generated from protobuf field: string chrom = 1;
   */
  chrom: string
  /**
   * 1-based start position.
   *
   * @generated from protobuf field: int32 pos = 2;
   */
  pos: number
  /**
   * Reference allele.
   *
   * @generated from protobuf field: string ref_allele = 3;
   */
  refAllele: string
  /**
   * Alternate allele.
   *
   * @generated from protobuf field: string alt_allele = 4;
   */
  altAllele: string
  /**
   * Variant in format of RefPosAlt
   *
   * @generated from protobuf field: string variant_collapsed = 5;
   */
  variantCollapsed: string
  /**
   * Excluded allele count (number of individuals in which the variant was filtered out).
   *
   * @generated from protobuf field: int32 excluded_ac = 6;
   */
  excludedAc: number
  /**
   * Overall allele number (number of samples with non-missing genotype).
   *
   * @generated from protobuf field: int32 an = 7;
   */
  an: number
  /**
   * Allele count restricted to variants with a heteroplasmy level >= 0.95.
   *
   * @generated from protobuf field: int32 ac_hom = 8;
   */
  acHom: number
  /**
   * Allele count restricted to variants with a heteroplasmy level >= 0.10 and < 0.95.
   *
   * @generated from protobuf field: int32 ac_het = 9;
   */
  acHet: number
  /**
   * Allele frequency restricted to variants with a heteroplasmy level >= 0.95.
   *
   * @generated from protobuf field: float af_hom = 10;
   */
  afHom: number
  /**
   * Allele frequency restricted to variants with a heteroplasmy level >= 0.10 and < 0.95.
   *
   * @generated from protobuf field: float af_het = 11;
   */
  afHet: number
  /**
   * Site-level filters.
   *
   * @generated from protobuf field: repeated annonars.gnomad.mtdna.Filter filters = 12;
   */
  filters: Filter[]
  /**
   * MitoTip raw score
   *
   * @generated from protobuf field: optional float mitotip_score = 13;
   */
  mitotipScore?: number
  /**
   * MitoTip score interpretation
   *
   * @generated from protobuf field: optional string mitotip_trna_prediction = 14;
   */
  mitotipTrnaPrediction?: string
  /**
   * tRNA pathogenicity classification from PON-mt-tRNA
   *
   * @generated from protobuf field: optional string pon_mt_trna_prediction = 15;
   */
  ponMtTrnaPrediction?: string
  /**
   * tRNA ML_probability_of_pathogenicity from PON-mt-tRNA
   *
   * @generated from protobuf field: optional string pon_ml_probability_of_pathogenicity = 16;
   */
  ponMlProbabilityOfPathogenicity?: string
  /**
   * VEP v3 annotation records.
   *
   * @generated from protobuf field: repeated annonars.gnomad.vep_gnomad3.Vep vep = 17;
   */
  vep: Vep[]
  /**
   * Summary information for variant quality interpretation.
   *
   * @generated from protobuf field: optional annonars.gnomad.mtdna.QualityInfo quality_info = 18;
   */
  qualityInfo?: QualityInfo
  /**
   * Information related to heteroplasmy levels.
   *
   * @generated from protobuf field: optional annonars.gnomad.mtdna.HeteroplasmyInfo heteroplasmy_info = 19;
   */
  heteroplasmyInfo?: HeteroplasmyInfo
  /**
   * Histograms related to variant quality filters.
   *
   * @generated from protobuf field: optional annonars.gnomad.mtdna.FilterHistograms filter_histograms = 20;
   */
  filterHistograms?: FilterHistograms
  /**
   * Population-related information.
   *
   * @generated from protobuf field: optional annonars.gnomad.mtdna.PopulationInfo population_info = 21;
   */
  populationInfo?: PopulationInfo
  /**
   * Haplogroup-related information.
   *
   * @generated from protobuf field: optional annonars.gnomad.mtdna.HaplogroupInfo haplogroup_info = 22;
   */
  haplogroupInfo?: HaplogroupInfo
  /**
   * Age-related information.
   *
   * @generated from protobuf field: optional annonars.gnomad.mtdna.AgeInfo age_info = 23;
   */
  ageInfo?: AgeInfo
  /**
   * Depth of coverage-related information.
   *
   * @generated from protobuf field: optional annonars.gnomad.mtdna.DepthInfo depth_info = 24;
   */
  depthInfo?: DepthInfo
}
/**
 * Protocol buffer enum for site-level filters.
 *
 * @generated from protobuf enum annonars.gnomad.mtdna.Filter
 */
export enum Filter {
  /**
   * unknown
   *
   * @generated from protobuf enum value: FILTER_UNKNOWN = 0;
   */
  FILTER_UNKNOWN = 0,
  /**
   * Variant overlaps site that is commonly reported in literature to be artifact prone.
   *
   * @generated from protobuf enum value: FILTER_ARTIFACT_PRONE_SITE = 1;
   */
  FILTER_ARTIFACT_PRONE_SITE = 1,
  /**
   * Allele where all samples with the variant call had at least 2 different heteroplasmic indels
   * called at the position.
   *
   * @generated from protobuf enum value: FILTER_INDEL_STACK = 2;
   */
  FILTER_INDEL_STACK = 2,
  /**
   * No-pass-genotypes site (no individuals were PASS for the variant).
   *
   * @generated from protobuf enum value: FILTER_NO_PASS_GENOTYPE = 3;
   */
  FILTER_NO_PASS_GENOTYPE = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class QualityInfo$Type extends MessageType<QualityInfo> {
  constructor() {
    super('annonars.gnomad.mtdna.QualityInfo', [
      { no: 1, name: 'dp_mean', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 2, name: 'mq_mean', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 3, name: 'tlod_mean', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ }
    ])
  }
  create(value?: PartialMessage<QualityInfo>): QualityInfo {
    const message = globalThis.Object.create(this.messagePrototype!)
    if (value !== undefined) reflectionMergePartial<QualityInfo>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QualityInfo
  ): QualityInfo {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional float dp_mean */ 1:
          message.dpMean = reader.float()
          break
        case /* optional float mq_mean */ 2:
          message.mqMean = reader.float()
          break
        case /* optional float tlod_mean */ 3:
          message.tlodMean = reader.float()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QualityInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional float dp_mean = 1; */
    if (message.dpMean !== undefined) writer.tag(1, WireType.Bit32).float(message.dpMean)
    /* optional float mq_mean = 2; */
    if (message.mqMean !== undefined) writer.tag(2, WireType.Bit32).float(message.mqMean)
    /* optional float tlod_mean = 3; */
    if (message.tlodMean !== undefined) writer.tag(3, WireType.Bit32).float(message.tlodMean)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.mtdna.QualityInfo
 */
export const QualityInfo = new QualityInfo$Type()
// @generated message type with reflection information, may provide speed optimized methods
class HeteroplasmyInfo$Type extends MessageType<HeteroplasmyInfo> {
  constructor() {
    super('annonars.gnomad.mtdna.HeteroplasmyInfo', [
      {
        no: 1,
        name: 'heteroplasmy_below_min_het_threshold_hist',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 2,
        name: 'hl_hist',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      },
      { no: 3, name: 'common_low_heteroplasmy', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 4, name: 'max_hl', kind: 'scalar', T: 2 /*ScalarType.FLOAT*/ }
    ])
  }
  create(value?: PartialMessage<HeteroplasmyInfo>): HeteroplasmyInfo {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.heteroplasmyBelowMinHetThresholdHist = []
    message.hlHist = []
    message.commonLowHeteroplasmy = false
    message.maxHl = 0
    if (value !== undefined) reflectionMergePartial<HeteroplasmyInfo>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: HeteroplasmyInfo
  ): HeteroplasmyInfo {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated int32 heteroplasmy_below_min_het_threshold_hist */ 1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.heteroplasmyBelowMinHetThresholdHist.push(reader.int32())
          else message.heteroplasmyBelowMinHetThresholdHist.push(reader.int32())
          break
        case /* repeated int32 hl_hist */ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.hlHist.push(reader.int32())
          else message.hlHist.push(reader.int32())
          break
        case /* bool common_low_heteroplasmy */ 3:
          message.commonLowHeteroplasmy = reader.bool()
          break
        case /* float max_hl */ 4:
          message.maxHl = reader.float()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: HeteroplasmyInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated int32 heteroplasmy_below_min_het_threshold_hist = 1; */
    if (message.heteroplasmyBelowMinHetThresholdHist.length) {
      writer.tag(1, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.heteroplasmyBelowMinHetThresholdHist.length; i++)
        writer.int32(message.heteroplasmyBelowMinHetThresholdHist[i])
      writer.join()
    }
    /* repeated int32 hl_hist = 2; */
    if (message.hlHist.length) {
      writer.tag(2, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.hlHist.length; i++) writer.int32(message.hlHist[i])
      writer.join()
    }
    /* bool common_low_heteroplasmy = 3; */
    if (message.commonLowHeteroplasmy !== false)
      writer.tag(3, WireType.Varint).bool(message.commonLowHeteroplasmy)
    /* float max_hl = 4; */
    if (message.maxHl !== 0) writer.tag(4, WireType.Bit32).float(message.maxHl)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.mtdna.HeteroplasmyInfo
 */
export const HeteroplasmyInfo = new HeteroplasmyInfo$Type()
// @generated message type with reflection information, may provide speed optimized methods
class FilterHistograms$Type extends MessageType<FilterHistograms> {
  constructor() {
    super('annonars.gnomad.mtdna.FilterHistograms', [
      {
        no: 1,
        name: 'base_qual_hist',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 2,
        name: 'position_hist',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: 'strand_bias_hist',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: 'weak_evidence_hist',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 5,
        name: 'contamination_hist',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      }
    ])
  }
  create(value?: PartialMessage<FilterHistograms>): FilterHistograms {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.baseQualHist = []
    message.positionHist = []
    message.strandBiasHist = []
    message.weakEvidenceHist = []
    message.contaminationHist = []
    if (value !== undefined) reflectionMergePartial<FilterHistograms>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: FilterHistograms
  ): FilterHistograms {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated int32 base_qual_hist */ 1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.baseQualHist.push(reader.int32())
          else message.baseQualHist.push(reader.int32())
          break
        case /* repeated int32 position_hist */ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.positionHist.push(reader.int32())
          else message.positionHist.push(reader.int32())
          break
        case /* repeated int32 strand_bias_hist */ 3:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.strandBiasHist.push(reader.int32())
          else message.strandBiasHist.push(reader.int32())
          break
        case /* repeated int32 weak_evidence_hist */ 4:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.weakEvidenceHist.push(reader.int32())
          else message.weakEvidenceHist.push(reader.int32())
          break
        case /* repeated int32 contamination_hist */ 5:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.contaminationHist.push(reader.int32())
          else message.contaminationHist.push(reader.int32())
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: FilterHistograms,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated int32 base_qual_hist = 1; */
    if (message.baseQualHist.length) {
      writer.tag(1, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.baseQualHist.length; i++) writer.int32(message.baseQualHist[i])
      writer.join()
    }
    /* repeated int32 position_hist = 2; */
    if (message.positionHist.length) {
      writer.tag(2, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.positionHist.length; i++) writer.int32(message.positionHist[i])
      writer.join()
    }
    /* repeated int32 strand_bias_hist = 3; */
    if (message.strandBiasHist.length) {
      writer.tag(3, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.strandBiasHist.length; i++)
        writer.int32(message.strandBiasHist[i])
      writer.join()
    }
    /* repeated int32 weak_evidence_hist = 4; */
    if (message.weakEvidenceHist.length) {
      writer.tag(4, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.weakEvidenceHist.length; i++)
        writer.int32(message.weakEvidenceHist[i])
      writer.join()
    }
    /* repeated int32 contamination_hist = 5; */
    if (message.contaminationHist.length) {
      writer.tag(5, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.contaminationHist.length; i++)
        writer.int32(message.contaminationHist[i])
      writer.join()
    }
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.mtdna.FilterHistograms
 */
export const FilterHistograms = new FilterHistograms$Type()
// @generated message type with reflection information, may provide speed optimized methods
class PopulationInfo$Type extends MessageType<PopulationInfo> {
  constructor() {
    super('annonars.gnomad.mtdna.PopulationInfo', [
      {
        no: 1,
        name: 'pop_an',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 2,
        name: 'pop_ac_het',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: 'pop_ac_hom',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: 'pop_af_hom',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 2 /*ScalarType.FLOAT*/
      },
      {
        no: 5,
        name: 'pop_af_het',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 2 /*ScalarType.FLOAT*/
      },
      {
        no: 6,
        name: 'pop_hl_hist',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      }
    ])
  }
  create(value?: PartialMessage<PopulationInfo>): PopulationInfo {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.popAn = []
    message.popAcHet = []
    message.popAcHom = []
    message.popAfHom = []
    message.popAfHet = []
    message.popHlHist = []
    if (value !== undefined) reflectionMergePartial<PopulationInfo>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PopulationInfo
  ): PopulationInfo {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated int32 pop_an */ 1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.popAn.push(reader.int32())
          else message.popAn.push(reader.int32())
          break
        case /* repeated int32 pop_ac_het */ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.popAcHet.push(reader.int32())
          else message.popAcHet.push(reader.int32())
          break
        case /* repeated int32 pop_ac_hom */ 3:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.popAcHom.push(reader.int32())
          else message.popAcHom.push(reader.int32())
          break
        case /* repeated float pop_af_hom */ 4:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.popAfHom.push(reader.float())
          else message.popAfHom.push(reader.float())
          break
        case /* repeated float pop_af_het */ 5:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.popAfHet.push(reader.float())
          else message.popAfHet.push(reader.float())
          break
        case /* repeated int32 pop_hl_hist */ 6:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.popHlHist.push(reader.int32())
          else message.popHlHist.push(reader.int32())
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: PopulationInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated int32 pop_an = 1; */
    if (message.popAn.length) {
      writer.tag(1, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.popAn.length; i++) writer.int32(message.popAn[i])
      writer.join()
    }
    /* repeated int32 pop_ac_het = 2; */
    if (message.popAcHet.length) {
      writer.tag(2, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.popAcHet.length; i++) writer.int32(message.popAcHet[i])
      writer.join()
    }
    /* repeated int32 pop_ac_hom = 3; */
    if (message.popAcHom.length) {
      writer.tag(3, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.popAcHom.length; i++) writer.int32(message.popAcHom[i])
      writer.join()
    }
    /* repeated float pop_af_hom = 4; */
    if (message.popAfHom.length) {
      writer.tag(4, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.popAfHom.length; i++) writer.float(message.popAfHom[i])
      writer.join()
    }
    /* repeated float pop_af_het = 5; */
    if (message.popAfHet.length) {
      writer.tag(5, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.popAfHet.length; i++) writer.float(message.popAfHet[i])
      writer.join()
    }
    /* repeated int32 pop_hl_hist = 6; */
    if (message.popHlHist.length) {
      writer.tag(6, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.popHlHist.length; i++) writer.int32(message.popHlHist[i])
      writer.join()
    }
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.mtdna.PopulationInfo
 */
export const PopulationInfo = new PopulationInfo$Type()
// @generated message type with reflection information, may provide speed optimized methods
class HaplogroupInfo$Type extends MessageType<HaplogroupInfo> {
  constructor() {
    super('annonars.gnomad.mtdna.HaplogroupInfo', [
      { no: 1, name: 'hap_defining_variant', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      {
        no: 2,
        name: 'hap_an',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: 'hap_ac_het',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: 'hap_ac_hom',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 5,
        name: 'hap_af_het',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 2 /*ScalarType.FLOAT*/
      },
      {
        no: 6,
        name: 'hap_af_hom',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 2 /*ScalarType.FLOAT*/
      },
      {
        no: 7,
        name: 'hap_hl_hist',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 8,
        name: 'hap_faf_hom',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 2 /*ScalarType.FLOAT*/
      },
      { no: 9, name: 'hapmax_af_hom', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 10, name: 'hapmax_af_het', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 11, name: 'faf_hapmax_hom', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ }
    ])
  }
  create(value?: PartialMessage<HaplogroupInfo>): HaplogroupInfo {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.hapDefiningVariant = false
    message.hapAn = []
    message.hapAcHet = []
    message.hapAcHom = []
    message.hapAfHet = []
    message.hapAfHom = []
    message.hapHlHist = []
    message.hapFafHom = []
    if (value !== undefined) reflectionMergePartial<HaplogroupInfo>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: HaplogroupInfo
  ): HaplogroupInfo {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* bool hap_defining_variant */ 1:
          message.hapDefiningVariant = reader.bool()
          break
        case /* repeated int32 hap_an */ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.hapAn.push(reader.int32())
          else message.hapAn.push(reader.int32())
          break
        case /* repeated int32 hap_ac_het */ 3:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.hapAcHet.push(reader.int32())
          else message.hapAcHet.push(reader.int32())
          break
        case /* repeated int32 hap_ac_hom */ 4:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.hapAcHom.push(reader.int32())
          else message.hapAcHom.push(reader.int32())
          break
        case /* repeated float hap_af_het */ 5:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.hapAfHet.push(reader.float())
          else message.hapAfHet.push(reader.float())
          break
        case /* repeated float hap_af_hom */ 6:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.hapAfHom.push(reader.float())
          else message.hapAfHom.push(reader.float())
          break
        case /* repeated int32 hap_hl_hist */ 7:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.hapHlHist.push(reader.int32())
          else message.hapHlHist.push(reader.int32())
          break
        case /* repeated float hap_faf_hom */ 8:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.hapFafHom.push(reader.float())
          else message.hapFafHom.push(reader.float())
          break
        case /* optional string hapmax_af_hom */ 9:
          message.hapmaxAfHom = reader.string()
          break
        case /* optional string hapmax_af_het */ 10:
          message.hapmaxAfHet = reader.string()
          break
        case /* optional float faf_hapmax_hom */ 11:
          message.fafHapmaxHom = reader.float()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: HaplogroupInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* bool hap_defining_variant = 1; */
    if (message.hapDefiningVariant !== false)
      writer.tag(1, WireType.Varint).bool(message.hapDefiningVariant)
    /* repeated int32 hap_an = 2; */
    if (message.hapAn.length) {
      writer.tag(2, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.hapAn.length; i++) writer.int32(message.hapAn[i])
      writer.join()
    }
    /* repeated int32 hap_ac_het = 3; */
    if (message.hapAcHet.length) {
      writer.tag(3, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.hapAcHet.length; i++) writer.int32(message.hapAcHet[i])
      writer.join()
    }
    /* repeated int32 hap_ac_hom = 4; */
    if (message.hapAcHom.length) {
      writer.tag(4, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.hapAcHom.length; i++) writer.int32(message.hapAcHom[i])
      writer.join()
    }
    /* repeated float hap_af_het = 5; */
    if (message.hapAfHet.length) {
      writer.tag(5, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.hapAfHet.length; i++) writer.float(message.hapAfHet[i])
      writer.join()
    }
    /* repeated float hap_af_hom = 6; */
    if (message.hapAfHom.length) {
      writer.tag(6, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.hapAfHom.length; i++) writer.float(message.hapAfHom[i])
      writer.join()
    }
    /* repeated int32 hap_hl_hist = 7; */
    if (message.hapHlHist.length) {
      writer.tag(7, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.hapHlHist.length; i++) writer.int32(message.hapHlHist[i])
      writer.join()
    }
    /* repeated float hap_faf_hom = 8; */
    if (message.hapFafHom.length) {
      writer.tag(8, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.hapFafHom.length; i++) writer.float(message.hapFafHom[i])
      writer.join()
    }
    /* optional string hapmax_af_hom = 9; */
    if (message.hapmaxAfHom !== undefined)
      writer.tag(9, WireType.LengthDelimited).string(message.hapmaxAfHom)
    /* optional string hapmax_af_het = 10; */
    if (message.hapmaxAfHet !== undefined)
      writer.tag(10, WireType.LengthDelimited).string(message.hapmaxAfHet)
    /* optional float faf_hapmax_hom = 11; */
    if (message.fafHapmaxHom !== undefined)
      writer.tag(11, WireType.Bit32).float(message.fafHapmaxHom)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.mtdna.HaplogroupInfo
 */
export const HaplogroupInfo = new HaplogroupInfo$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AgeInfo$Type extends MessageType<AgeInfo> {
  constructor() {
    super('annonars.gnomad.mtdna.AgeInfo', [
      {
        no: 1,
        name: 'age_hist_hom_bin_freq',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 2,
        name: 'age_hist_hom_n_smaller',
        kind: 'scalar',
        opt: true,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: 'age_hist_hom_n_larger',
        kind: 'scalar',
        opt: true,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: 'age_hist_het_bin_freq',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 5,
        name: 'age_hist_het_n_smaller',
        kind: 'scalar',
        opt: true,
        T: 5 /*ScalarType.INT32*/
      },
      { no: 6, name: 'age_hist_het_n_larger', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ }
    ])
  }
  create(value?: PartialMessage<AgeInfo>): AgeInfo {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.ageHistHomBinFreq = []
    message.ageHistHetBinFreq = []
    if (value !== undefined) reflectionMergePartial<AgeInfo>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AgeInfo
  ): AgeInfo {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated int32 age_hist_hom_bin_freq */ 1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.ageHistHomBinFreq.push(reader.int32())
          else message.ageHistHomBinFreq.push(reader.int32())
          break
        case /* optional int32 age_hist_hom_n_smaller */ 2:
          message.ageHistHomNSmaller = reader.int32()
          break
        case /* optional int32 age_hist_hom_n_larger */ 3:
          message.ageHistHomNLarger = reader.int32()
          break
        case /* repeated int32 age_hist_het_bin_freq */ 4:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.ageHistHetBinFreq.push(reader.int32())
          else message.ageHistHetBinFreq.push(reader.int32())
          break
        case /* optional int32 age_hist_het_n_smaller */ 5:
          message.ageHistHetNSmaller = reader.int32()
          break
        case /* optional int32 age_hist_het_n_larger */ 6:
          message.ageHistHetNLarger = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: AgeInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated int32 age_hist_hom_bin_freq = 1; */
    if (message.ageHistHomBinFreq.length) {
      writer.tag(1, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.ageHistHomBinFreq.length; i++)
        writer.int32(message.ageHistHomBinFreq[i])
      writer.join()
    }
    /* optional int32 age_hist_hom_n_smaller = 2; */
    if (message.ageHistHomNSmaller !== undefined)
      writer.tag(2, WireType.Varint).int32(message.ageHistHomNSmaller)
    /* optional int32 age_hist_hom_n_larger = 3; */
    if (message.ageHistHomNLarger !== undefined)
      writer.tag(3, WireType.Varint).int32(message.ageHistHomNLarger)
    /* repeated int32 age_hist_het_bin_freq = 4; */
    if (message.ageHistHetBinFreq.length) {
      writer.tag(4, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.ageHistHetBinFreq.length; i++)
        writer.int32(message.ageHistHetBinFreq[i])
      writer.join()
    }
    /* optional int32 age_hist_het_n_smaller = 5; */
    if (message.ageHistHetNSmaller !== undefined)
      writer.tag(5, WireType.Varint).int32(message.ageHistHetNSmaller)
    /* optional int32 age_hist_het_n_larger = 6; */
    if (message.ageHistHetNLarger !== undefined)
      writer.tag(6, WireType.Varint).int32(message.ageHistHetNLarger)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.mtdna.AgeInfo
 */
export const AgeInfo = new AgeInfo$Type()
// @generated message type with reflection information, may provide speed optimized methods
class DepthInfo$Type extends MessageType<DepthInfo> {
  constructor() {
    super('annonars.gnomad.mtdna.DepthInfo', [
      { no: 1, name: 'dp_hist_all_n_larger', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      { no: 2, name: 'dp_hist_alt_n_larger', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      {
        no: 3,
        name: 'dp_hist_all_bin_freq',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: 'dp_hist_alt_bin_freq',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      }
    ])
  }
  create(value?: PartialMessage<DepthInfo>): DepthInfo {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.dpHistAllBinFreq = []
    message.dpHistAltBinFreq = []
    if (value !== undefined) reflectionMergePartial<DepthInfo>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DepthInfo
  ): DepthInfo {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional int32 dp_hist_all_n_larger */ 1:
          message.dpHistAllNLarger = reader.int32()
          break
        case /* optional int32 dp_hist_alt_n_larger */ 2:
          message.dpHistAltNLarger = reader.int32()
          break
        case /* repeated int32 dp_hist_all_bin_freq */ 3:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.dpHistAllBinFreq.push(reader.int32())
          else message.dpHistAllBinFreq.push(reader.int32())
          break
        case /* repeated int32 dp_hist_alt_bin_freq */ 4:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.dpHistAltBinFreq.push(reader.int32())
          else message.dpHistAltBinFreq.push(reader.int32())
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: DepthInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional int32 dp_hist_all_n_larger = 1; */
    if (message.dpHistAllNLarger !== undefined)
      writer.tag(1, WireType.Varint).int32(message.dpHistAllNLarger)
    /* optional int32 dp_hist_alt_n_larger = 2; */
    if (message.dpHistAltNLarger !== undefined)
      writer.tag(2, WireType.Varint).int32(message.dpHistAltNLarger)
    /* repeated int32 dp_hist_all_bin_freq = 3; */
    if (message.dpHistAllBinFreq.length) {
      writer.tag(3, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.dpHistAllBinFreq.length; i++)
        writer.int32(message.dpHistAllBinFreq[i])
      writer.join()
    }
    /* repeated int32 dp_hist_alt_bin_freq = 4; */
    if (message.dpHistAltBinFreq.length) {
      writer.tag(4, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.dpHistAltBinFreq.length; i++)
        writer.int32(message.dpHistAltBinFreq[i])
      writer.join()
    }
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.mtdna.DepthInfo
 */
export const DepthInfo = new DepthInfo$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Record$Type extends MessageType<Record> {
  constructor() {
    super('annonars.gnomad.mtdna.Record', [
      { no: 1, name: 'chrom', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'pos', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 3, name: 'ref_allele', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: 'alt_allele', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 5, name: 'variant_collapsed', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 6, name: 'excluded_ac', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 7, name: 'an', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 8, name: 'ac_hom', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 9, name: 'ac_het', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 10, name: 'af_hom', kind: 'scalar', T: 2 /*ScalarType.FLOAT*/ },
      { no: 11, name: 'af_het', kind: 'scalar', T: 2 /*ScalarType.FLOAT*/ },
      {
        no: 12,
        name: 'filters',
        kind: 'enum',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => ['annonars.gnomad.mtdna.Filter', Filter]
      },
      { no: 13, name: 'mitotip_score', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      {
        no: 14,
        name: 'mitotip_trna_prediction',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/
      },
      {
        no: 15,
        name: 'pon_mt_trna_prediction',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/
      },
      {
        no: 16,
        name: 'pon_ml_probability_of_pathogenicity',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/
      },
      { no: 17, name: 'vep', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Vep },
      { no: 18, name: 'quality_info', kind: 'message', T: () => QualityInfo },
      { no: 19, name: 'heteroplasmy_info', kind: 'message', T: () => HeteroplasmyInfo },
      { no: 20, name: 'filter_histograms', kind: 'message', T: () => FilterHistograms },
      { no: 21, name: 'population_info', kind: 'message', T: () => PopulationInfo },
      { no: 22, name: 'haplogroup_info', kind: 'message', T: () => HaplogroupInfo },
      { no: 23, name: 'age_info', kind: 'message', T: () => AgeInfo },
      { no: 24, name: 'depth_info', kind: 'message', T: () => DepthInfo }
    ])
  }
  create(value?: PartialMessage<Record>): Record {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.chrom = ''
    message.pos = 0
    message.refAllele = ''
    message.altAllele = ''
    message.variantCollapsed = ''
    message.excludedAc = 0
    message.an = 0
    message.acHom = 0
    message.acHet = 0
    message.afHom = 0
    message.afHet = 0
    message.filters = []
    message.vep = []
    if (value !== undefined) reflectionMergePartial<Record>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Record
  ): Record {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string chrom */ 1:
          message.chrom = reader.string()
          break
        case /* int32 pos */ 2:
          message.pos = reader.int32()
          break
        case /* string ref_allele */ 3:
          message.refAllele = reader.string()
          break
        case /* string alt_allele */ 4:
          message.altAllele = reader.string()
          break
        case /* string variant_collapsed */ 5:
          message.variantCollapsed = reader.string()
          break
        case /* int32 excluded_ac */ 6:
          message.excludedAc = reader.int32()
          break
        case /* int32 an */ 7:
          message.an = reader.int32()
          break
        case /* int32 ac_hom */ 8:
          message.acHom = reader.int32()
          break
        case /* int32 ac_het */ 9:
          message.acHet = reader.int32()
          break
        case /* float af_hom */ 10:
          message.afHom = reader.float()
          break
        case /* float af_het */ 11:
          message.afHet = reader.float()
          break
        case /* repeated annonars.gnomad.mtdna.Filter filters */ 12:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.filters.push(reader.int32())
          else message.filters.push(reader.int32())
          break
        case /* optional float mitotip_score */ 13:
          message.mitotipScore = reader.float()
          break
        case /* optional string mitotip_trna_prediction */ 14:
          message.mitotipTrnaPrediction = reader.string()
          break
        case /* optional string pon_mt_trna_prediction */ 15:
          message.ponMtTrnaPrediction = reader.string()
          break
        case /* optional string pon_ml_probability_of_pathogenicity */ 16:
          message.ponMlProbabilityOfPathogenicity = reader.string()
          break
        case /* repeated annonars.gnomad.vep_gnomad3.Vep vep */ 17:
          message.vep.push(Vep.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* optional annonars.gnomad.mtdna.QualityInfo quality_info */ 18:
          message.qualityInfo = QualityInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.qualityInfo
          )
          break
        case /* optional annonars.gnomad.mtdna.HeteroplasmyInfo heteroplasmy_info */ 19:
          message.heteroplasmyInfo = HeteroplasmyInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.heteroplasmyInfo
          )
          break
        case /* optional annonars.gnomad.mtdna.FilterHistograms filter_histograms */ 20:
          message.filterHistograms = FilterHistograms.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.filterHistograms
          )
          break
        case /* optional annonars.gnomad.mtdna.PopulationInfo population_info */ 21:
          message.populationInfo = PopulationInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.populationInfo
          )
          break
        case /* optional annonars.gnomad.mtdna.HaplogroupInfo haplogroup_info */ 22:
          message.haplogroupInfo = HaplogroupInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.haplogroupInfo
          )
          break
        case /* optional annonars.gnomad.mtdna.AgeInfo age_info */ 23:
          message.ageInfo = AgeInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.ageInfo
          )
          break
        case /* optional annonars.gnomad.mtdna.DepthInfo depth_info */ 24:
          message.depthInfo = DepthInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.depthInfo
          )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Record,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string chrom = 1; */
    if (message.chrom !== '') writer.tag(1, WireType.LengthDelimited).string(message.chrom)
    /* int32 pos = 2; */
    if (message.pos !== 0) writer.tag(2, WireType.Varint).int32(message.pos)
    /* string ref_allele = 3; */
    if (message.refAllele !== '') writer.tag(3, WireType.LengthDelimited).string(message.refAllele)
    /* string alt_allele = 4; */
    if (message.altAllele !== '') writer.tag(4, WireType.LengthDelimited).string(message.altAllele)
    /* string variant_collapsed = 5; */
    if (message.variantCollapsed !== '')
      writer.tag(5, WireType.LengthDelimited).string(message.variantCollapsed)
    /* int32 excluded_ac = 6; */
    if (message.excludedAc !== 0) writer.tag(6, WireType.Varint).int32(message.excludedAc)
    /* int32 an = 7; */
    if (message.an !== 0) writer.tag(7, WireType.Varint).int32(message.an)
    /* int32 ac_hom = 8; */
    if (message.acHom !== 0) writer.tag(8, WireType.Varint).int32(message.acHom)
    /* int32 ac_het = 9; */
    if (message.acHet !== 0) writer.tag(9, WireType.Varint).int32(message.acHet)
    /* float af_hom = 10; */
    if (message.afHom !== 0) writer.tag(10, WireType.Bit32).float(message.afHom)
    /* float af_het = 11; */
    if (message.afHet !== 0) writer.tag(11, WireType.Bit32).float(message.afHet)
    /* repeated annonars.gnomad.mtdna.Filter filters = 12; */
    if (message.filters.length) {
      writer.tag(12, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.filters.length; i++) writer.int32(message.filters[i])
      writer.join()
    }
    /* optional float mitotip_score = 13; */
    if (message.mitotipScore !== undefined)
      writer.tag(13, WireType.Bit32).float(message.mitotipScore)
    /* optional string mitotip_trna_prediction = 14; */
    if (message.mitotipTrnaPrediction !== undefined)
      writer.tag(14, WireType.LengthDelimited).string(message.mitotipTrnaPrediction)
    /* optional string pon_mt_trna_prediction = 15; */
    if (message.ponMtTrnaPrediction !== undefined)
      writer.tag(15, WireType.LengthDelimited).string(message.ponMtTrnaPrediction)
    /* optional string pon_ml_probability_of_pathogenicity = 16; */
    if (message.ponMlProbabilityOfPathogenicity !== undefined)
      writer.tag(16, WireType.LengthDelimited).string(message.ponMlProbabilityOfPathogenicity)
    /* repeated annonars.gnomad.vep_gnomad3.Vep vep = 17; */
    for (let i = 0; i < message.vep.length; i++)
      Vep.internalBinaryWrite(
        message.vep[i],
        writer.tag(17, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.gnomad.mtdna.QualityInfo quality_info = 18; */
    if (message.qualityInfo)
      QualityInfo.internalBinaryWrite(
        message.qualityInfo,
        writer.tag(18, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.gnomad.mtdna.HeteroplasmyInfo heteroplasmy_info = 19; */
    if (message.heteroplasmyInfo)
      HeteroplasmyInfo.internalBinaryWrite(
        message.heteroplasmyInfo,
        writer.tag(19, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.gnomad.mtdna.FilterHistograms filter_histograms = 20; */
    if (message.filterHistograms)
      FilterHistograms.internalBinaryWrite(
        message.filterHistograms,
        writer.tag(20, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.gnomad.mtdna.PopulationInfo population_info = 21; */
    if (message.populationInfo)
      PopulationInfo.internalBinaryWrite(
        message.populationInfo,
        writer.tag(21, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.gnomad.mtdna.HaplogroupInfo haplogroup_info = 22; */
    if (message.haplogroupInfo)
      HaplogroupInfo.internalBinaryWrite(
        message.haplogroupInfo,
        writer.tag(22, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.gnomad.mtdna.AgeInfo age_info = 23; */
    if (message.ageInfo)
      AgeInfo.internalBinaryWrite(
        message.ageInfo,
        writer.tag(23, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.gnomad.mtdna.DepthInfo depth_info = 24; */
    if (message.depthInfo)
      DepthInfo.internalBinaryWrite(
        message.depthInfo,
        writer.tag(24, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.mtdna.Record
 */
export const Record = new Record$Type()
