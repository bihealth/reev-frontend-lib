// @generated by protobuf-ts 2.9.3 with parameter keep_enum_prefix,long_type_string
// @generated from protobuf file "annonars/gnomad/gnomad_sv4.proto" (package "annonars.gnomad.gnomad_sv4", syntax proto3)
// tslint:disable
//
// Protocol buffers for representing gnomAD-SV v4 data.
//
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'

import { CpxType } from './gnomad_sv2'

/**
 * Store the relevant allele counts and frequencies in a given sub cohort.
 *
 * @generated from protobuf message annonars.gnomad.gnomad_sv4.AlleleCounts
 */
export interface AlleleCounts {
  /**
   * Total number of alleles genotyped (for biallelic sites) or individuals
   * with copy-state estimates (for multiallelic sites).
   *
   * @generated from protobuf field: int32 ac = 1;
   */
  ac: number
  /**
   * Allele frequency (for biallelic sites) or copy-state frequency (for
   * multiallelic sites).
   *
   * @generated from protobuf field: float af = 2;
   */
  af: number
  /**
   * Number of non-reference alleles observed (for biallelic sites) or
   * individuals at each copy state (for multiallelic sites).
   *
   * @generated from protobuf field: int32 an = 3;
   */
  an: number
  /**
   * Hemizygous alternate genotype frequency (biallelic sites only).
   *
   * @generated from protobuf field: float freq_hemialt = 4;
   */
  freqHemialt: number
  /**
   * Hemizygous reference genotype frequency (biallelic sites only).
   *
   * @generated from protobuf field: float freq_hemiref = 5;
   */
  freqHemiref: number
  /**
   * Heterozygous genotype frequency (biallelic sites only).
   *
   * @generated from protobuf field: float freq_het = 6;
   */
  freqHet: number
  /**
   * Homozygous alternate genotype frequency (biallelic sites only).
   *
   * @generated from protobuf field: float freq_homalt = 7;
   */
  freqHomalt: number
  /**
   * Homozygous reference genotype frequency (biallelic sites only).
   *
   * @generated from protobuf field: float freq_homref = 8;
   */
  freqHomref: number
  /**
   * Total number of individuals with complete genotypes (biallelic sites
   * only).
   *
   * @generated from protobuf field: int32 n_bi_genos = 9;
   */
  nBiGenos: number
  /**
   * Number of individuals with hemizygous alternate genotypes (biallelic
   * sites only).
   *
   * @generated from protobuf field: int32 n_hemialt = 10;
   */
  nHemialt: number
  /**
   * Number of individuals with hemizygous reference genotypes (biallelic
   * sites only).
   *
   * @generated from protobuf field: int32 n_hemiref = 11;
   */
  nHemiref: number
  /**
   * Number of individuals with heterozygous genotypes (biallelic sites
   * only).
   *
   * @generated from protobuf field: int32 n_het = 12;
   */
  nHet: number
  /**
   * Number of individuals with homozygous alternate genotypes (biallelic
   * sites only).
   *
   * @generated from protobuf field: int32 n_homalt = 13;
   */
  nHomalt: number
  /**
   * Number of individuals with homozygous reference genotypes (biallelic
   * sites only).
   *
   * @generated from protobuf field: int32 n_homref = 14;
   */
  nHomref: number
}
/**
 * Store the allele counts for the given sub cohort and sub cohort factored by sex.
 *
 * @generated from protobuf message annonars.gnomad.gnomad_sv4.AlleleCountsBySex
 */
export interface AlleleCountsBySex {
  /**
   * Overall allele counts in the sub cohort.
   *
   * @generated from protobuf field: annonars.gnomad.gnomad_sv4.AlleleCounts overall = 1;
   */
  overall?: AlleleCounts
  /**
   * Allele counts in female/XX karyotype individuals of sub cohort.
   *
   * @generated from protobuf field: annonars.gnomad.gnomad_sv4.AlleleCounts xx = 2;
   */
  xx?: AlleleCounts
  /**
   * Allele counts in male/XY karyotype individuals of sub cohort.
   *
   * @generated from protobuf field: annonars.gnomad.gnomad_sv4.AlleleCounts xy = 3;
   */
  xy?: AlleleCounts
}
/**
 * Store the allele counts for the given sub cohort in the given population.
 *
 * @generated from protobuf message annonars.gnomad.gnomad_sv4.PopulationAlleleCounts
 */
export interface PopulationAlleleCounts {
  /**
   * Name of the population.
   *
   * @generated from protobuf field: annonars.gnomad.gnomad_sv4.Population population = 1;
   */
  population: Population
  /**
   * The overall allele counts and the one by sex.
   *
   * @generated from protobuf field: annonars.gnomad.gnomad_sv4.AlleleCountsBySex counts = 2;
   */
  counts?: AlleleCountsBySex
}
/**
 * Store the allele counts for the given cohort.
 *
 * @generated from protobuf message annonars.gnomad.gnomad_sv4.CohortAlleleCounts
 */
export interface CohortAlleleCounts {
  /**
   * Name of the cohort, empty for global.
   *
   * @generated from protobuf field: optional string cohort = 1;
   */
  cohort?: string
  /**
   * The overall allele counts and the one by sex.
   *
   * @generated from protobuf field: annonars.gnomad.gnomad_sv4.AlleleCountsBySex by_sex = 2;
   */
  bySex?: AlleleCountsBySex
  /**
   * Allele counts for each population.
   *
   * @generated from protobuf field: repeated annonars.gnomad.gnomad_sv4.PopulationAlleleCounts by_population = 3;
   */
  byPopulation: PopulationAlleleCounts[]
}
/**
 * Protocol buffer for the gnomAD-SV v4 VCF record.
 *
 * @generated from protobuf message annonars.gnomad.gnomad_sv4.Record
 */
export interface Record {
  /**
   * Chromosome name.
   *
   * @generated from protobuf field: string chrom = 1;
   */
  chrom: string
  /**
   * 1-based start position.
   *
   * @generated from protobuf field: int32 pos = 2;
   */
  pos: number
  /**
   * End position of the structural variant
   *
   * @generated from protobuf field: optional int32 end = 3;
   */
  end?: number
  /**
   * Chromosome of second breakpoint position.
   *
   * @generated from protobuf field: optional string chrom2 = 4;
   */
  chrom2?: string
  /**
   * End coordinate of second breakpoint position.
   *
   * @generated from protobuf field: optional int32 end2 = 5;
   */
  end2?: number
  /**
   * Identifier of the record.
   *
   * @generated from protobuf field: string id = 6;
   */
  id: string
  /**
   * Site-level filters.
   *
   * @generated from protobuf field: repeated annonars.gnomad.gnomad_sv4.Filter filters = 7;
   */
  filters: Filter[]
  /**
   * SV Type.
   *
   * @generated from protobuf field: annonars.gnomad.gnomad_sv4.SvType sv_type = 8;
   */
  svType: SvType
  /**
   * Refined complex type.
   *
   * @generated from protobuf field: optional annonars.gnomad.gnomad_sv2.CpxType cpx_type = 9;
   */
  cpxType?: CpxType
  /**
   * Variant allele counts in the different cohorts and population.
   *
   * @generated from protobuf field: repeated annonars.gnomad.gnomad_sv4.CohortAlleleCounts allele_counts = 10;
   */
  alleleCounts: CohortAlleleCounts[]
}
/**
 * Enumeration for filters.
 *
 * @generated from protobuf enum annonars.gnomad.gnomad_sv4.Filter
 */
export enum Filter {
  /**
   * unknown
   *
   * @generated from protobuf enum value: FILTER_UNKNOWN = 0;
   */
  FILTER_UNKNOWN = 0,
  /**
   * All filters passed.
   *
   * @generated from protobuf enum value: FILTER_PASS = 1;
   */
  FILTER_PASS = 1,
  /**
   * Low-quality variant that did not pass manual review of supporting
   * evidence.
   *
   * @generated from protobuf enum value: FILTER_FAIL_MANUAL_REVIEW = 2;
   */
  FILTER_FAIL_MANUAL_REVIEW = 2,
  /**
   * Unacceptably high rate of no-call GTs
   *
   * @generated from protobuf enum value: FILTER_HIGH_NCR = 3;
   */
  FILTER_HIGH_NCR = 3,
  /**
   * SVs that are overlapped by over 50% by IGH or MHC regions, these
   * variants are of low confidence.
   *
   * @generated from protobuf enum value: FILTER_IGH_MHC_OVERLAP = 4;
   */
  FILTER_IGH_MHC_OVERLAP = 4,
  /**
   * Deletions under 1 kbp that are uniquely from wham and have SR-only
   * support.
   *
   * @generated from protobuf enum value: FILTER_LOWQUAL_WHAM_SR_DEL = 5;
   */
  FILTER_LOWQUAL_WHAM_SR_DEL = 5,
  /**
   * Multiallelic site
   *
   * @generated from protobuf enum value: FILTER_MULTIALLELIC = 6;
   */
  FILTER_MULTIALLELIC = 6,
  /**
   * SVs that are enriched for non-reference genotypes in outlier samples,
   * likely indicating noisy or unreliable genotypes.
   *
   * @generated from protobuf enum value: FILTER_OUTLIER_SAMPLE_ENRICHED = 7;
   */
  FILTER_OUTLIER_SAMPLE_ENRICHED = 7,
  /**
   * Multiple large CNVs called at the same locus likely indicates unreliable
   * clustering and/or low-quality multiallelic locus.
   *
   * @generated from protobuf enum value: FILTER_REDUNDANT_LG_CNV = 8;
   */
  FILTER_REDUNDANT_LG_CNV = 8,
  /**
   * Likely reference artifact sites that are homozygous alternative in over
   * 99% of the samples.
   *
   * @generated from protobuf enum value: FILTER_REFERENCE_ARTIFACT = 9;
   */
  FILTER_REFERENCE_ARTIFACT = 9,
  /**
   * Variant is unresolved
   *
   * @generated from protobuf enum value: FILTER_UNRESOLVED = 10;
   */
  FILTER_UNRESOLVED = 10,
  /**
   * Generic failure.
   *
   * @generated from protobuf enum value: FILTER_FAIL = 11;
   */
  FILTER_FAIL = 11
}
/**
 * The types of SV in gnomad-SV v2.
 *
 * @generated from protobuf enum annonars.gnomad.gnomad_sv4.SvType
 */
export enum SvType {
  /**
   * unknown
   *
   * @generated from protobuf enum value: SV_TYPE_UNKNOWN = 0;
   */
  SV_TYPE_UNKNOWN = 0,
  /**
   * Breakend.
   *
   * @generated from protobuf enum value: SV_TYPE_BND = 1;
   */
  SV_TYPE_BND = 1,
  /**
   * Copy number variable region.
   *
   * @generated from protobuf enum value: SV_TYPE_CNV = 2;
   */
  SV_TYPE_CNV = 2,
  /**
   * Complex variant.
   *
   * @generated from protobuf enum value: SV_TYPE_CPX = 3;
   */
  SV_TYPE_CPX = 3,
  /**
   * Translocation.
   *
   * @generated from protobuf enum value: SV_TYPE_CTX = 4;
   */
  SV_TYPE_CTX = 4,
  /**
   * Deletion.
   *
   * @generated from protobuf enum value: SV_TYPE_DEL = 5;
   */
  SV_TYPE_DEL = 5,
  /**
   * Duplication.
   *
   * @generated from protobuf enum value: SV_TYPE_DUP = 6;
   */
  SV_TYPE_DUP = 6,
  /**
   * Insertion.
   *
   * @generated from protobuf enum value: SV_TYPE_INS = 7;
   */
  SV_TYPE_INS = 7,
  /**
   * Inversion.
   *
   * @generated from protobuf enum value: SV_TYPE_INV = 8;
   */
  SV_TYPE_INV = 8
}
/**
 * gnomAD SV population.
 *
 * @generated from protobuf enum annonars.gnomad.gnomad_sv4.Population
 */
export enum Population {
  /**
   * unknown
   *
   * @generated from protobuf enum value: POPULATION_UNKNOWN = 0;
   */
  POPULATION_UNKNOWN = 0,
  /**
   * African
   *
   * @generated from protobuf enum value: POPULATION_AFR = 1;
   */
  POPULATION_AFR = 1,
  /**
   * Amish
   *
   * @generated from protobuf enum value: POPULATION_AMI = 2;
   */
  POPULATION_AMI = 2,
  /**
   * Admixed American
   *
   * @generated from protobuf enum value: POPULATION_AMR = 3;
   */
  POPULATION_AMR = 3,
  /**
   * Ashkenazi Jewish
   *
   * @generated from protobuf enum value: POPULATION_ASJ = 4;
   */
  POPULATION_ASJ = 4,
  /**
   * East Asian
   *
   * @generated from protobuf enum value: POPULATION_EAS = 5;
   */
  POPULATION_EAS = 5,
  /**
   * Finnish
   *
   * @generated from protobuf enum value: POPULATION_FIN = 6;
   */
  POPULATION_FIN = 6,
  /**
   * Middle Eastern
   *
   * @generated from protobuf enum value: POPULATION_MID = 7;
   */
  POPULATION_MID = 7,
  /**
   * Non-Finnish European
   *
   * @generated from protobuf enum value: POPULATION_NFE = 8;
   */
  POPULATION_NFE = 8,
  /**
   * South Asian
   *
   * @generated from protobuf enum value: POPULATION_SAS = 9;
   */
  POPULATION_SAS = 9,
  /**
   * Other
   *
   * @generated from protobuf enum value: POPULATION_OTHER = 10;
   */
  POPULATION_OTHER = 10
}
// @generated message type with reflection information, may provide speed optimized methods
class AlleleCounts$Type extends MessageType<AlleleCounts> {
  constructor() {
    super('annonars.gnomad.gnomad_sv4.AlleleCounts', [
      { no: 1, name: 'ac', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 2, name: 'af', kind: 'scalar', T: 2 /*ScalarType.FLOAT*/ },
      { no: 3, name: 'an', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 4, name: 'freq_hemialt', kind: 'scalar', T: 2 /*ScalarType.FLOAT*/ },
      { no: 5, name: 'freq_hemiref', kind: 'scalar', T: 2 /*ScalarType.FLOAT*/ },
      { no: 6, name: 'freq_het', kind: 'scalar', T: 2 /*ScalarType.FLOAT*/ },
      { no: 7, name: 'freq_homalt', kind: 'scalar', T: 2 /*ScalarType.FLOAT*/ },
      { no: 8, name: 'freq_homref', kind: 'scalar', T: 2 /*ScalarType.FLOAT*/ },
      { no: 9, name: 'n_bi_genos', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 10, name: 'n_hemialt', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 11, name: 'n_hemiref', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 12, name: 'n_het', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 13, name: 'n_homalt', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 14, name: 'n_homref', kind: 'scalar', T: 5 /*ScalarType.INT32*/ }
    ])
  }
  create(value?: PartialMessage<AlleleCounts>): AlleleCounts {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.ac = 0
    message.af = 0
    message.an = 0
    message.freqHemialt = 0
    message.freqHemiref = 0
    message.freqHet = 0
    message.freqHomalt = 0
    message.freqHomref = 0
    message.nBiGenos = 0
    message.nHemialt = 0
    message.nHemiref = 0
    message.nHet = 0
    message.nHomalt = 0
    message.nHomref = 0
    if (value !== undefined) reflectionMergePartial<AlleleCounts>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AlleleCounts
  ): AlleleCounts {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* int32 ac */ 1:
          message.ac = reader.int32()
          break
        case /* float af */ 2:
          message.af = reader.float()
          break
        case /* int32 an */ 3:
          message.an = reader.int32()
          break
        case /* float freq_hemialt */ 4:
          message.freqHemialt = reader.float()
          break
        case /* float freq_hemiref */ 5:
          message.freqHemiref = reader.float()
          break
        case /* float freq_het */ 6:
          message.freqHet = reader.float()
          break
        case /* float freq_homalt */ 7:
          message.freqHomalt = reader.float()
          break
        case /* float freq_homref */ 8:
          message.freqHomref = reader.float()
          break
        case /* int32 n_bi_genos */ 9:
          message.nBiGenos = reader.int32()
          break
        case /* int32 n_hemialt */ 10:
          message.nHemialt = reader.int32()
          break
        case /* int32 n_hemiref */ 11:
          message.nHemiref = reader.int32()
          break
        case /* int32 n_het */ 12:
          message.nHet = reader.int32()
          break
        case /* int32 n_homalt */ 13:
          message.nHomalt = reader.int32()
          break
        case /* int32 n_homref */ 14:
          message.nHomref = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: AlleleCounts,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* int32 ac = 1; */
    if (message.ac !== 0) writer.tag(1, WireType.Varint).int32(message.ac)
    /* float af = 2; */
    if (message.af !== 0) writer.tag(2, WireType.Bit32).float(message.af)
    /* int32 an = 3; */
    if (message.an !== 0) writer.tag(3, WireType.Varint).int32(message.an)
    /* float freq_hemialt = 4; */
    if (message.freqHemialt !== 0) writer.tag(4, WireType.Bit32).float(message.freqHemialt)
    /* float freq_hemiref = 5; */
    if (message.freqHemiref !== 0) writer.tag(5, WireType.Bit32).float(message.freqHemiref)
    /* float freq_het = 6; */
    if (message.freqHet !== 0) writer.tag(6, WireType.Bit32).float(message.freqHet)
    /* float freq_homalt = 7; */
    if (message.freqHomalt !== 0) writer.tag(7, WireType.Bit32).float(message.freqHomalt)
    /* float freq_homref = 8; */
    if (message.freqHomref !== 0) writer.tag(8, WireType.Bit32).float(message.freqHomref)
    /* int32 n_bi_genos = 9; */
    if (message.nBiGenos !== 0) writer.tag(9, WireType.Varint).int32(message.nBiGenos)
    /* int32 n_hemialt = 10; */
    if (message.nHemialt !== 0) writer.tag(10, WireType.Varint).int32(message.nHemialt)
    /* int32 n_hemiref = 11; */
    if (message.nHemiref !== 0) writer.tag(11, WireType.Varint).int32(message.nHemiref)
    /* int32 n_het = 12; */
    if (message.nHet !== 0) writer.tag(12, WireType.Varint).int32(message.nHet)
    /* int32 n_homalt = 13; */
    if (message.nHomalt !== 0) writer.tag(13, WireType.Varint).int32(message.nHomalt)
    /* int32 n_homref = 14; */
    if (message.nHomref !== 0) writer.tag(14, WireType.Varint).int32(message.nHomref)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad_sv4.AlleleCounts
 */
export const AlleleCounts = new AlleleCounts$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AlleleCountsBySex$Type extends MessageType<AlleleCountsBySex> {
  constructor() {
    super('annonars.gnomad.gnomad_sv4.AlleleCountsBySex', [
      { no: 1, name: 'overall', kind: 'message', T: () => AlleleCounts },
      { no: 2, name: 'xx', kind: 'message', T: () => AlleleCounts },
      { no: 3, name: 'xy', kind: 'message', T: () => AlleleCounts }
    ])
  }
  create(value?: PartialMessage<AlleleCountsBySex>): AlleleCountsBySex {
    const message = globalThis.Object.create(this.messagePrototype!)
    if (value !== undefined) reflectionMergePartial<AlleleCountsBySex>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AlleleCountsBySex
  ): AlleleCountsBySex {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* annonars.gnomad.gnomad_sv4.AlleleCounts overall */ 1:
          message.overall = AlleleCounts.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.overall
          )
          break
        case /* annonars.gnomad.gnomad_sv4.AlleleCounts xx */ 2:
          message.xx = AlleleCounts.internalBinaryRead(reader, reader.uint32(), options, message.xx)
          break
        case /* annonars.gnomad.gnomad_sv4.AlleleCounts xy */ 3:
          message.xy = AlleleCounts.internalBinaryRead(reader, reader.uint32(), options, message.xy)
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: AlleleCountsBySex,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* annonars.gnomad.gnomad_sv4.AlleleCounts overall = 1; */
    if (message.overall)
      AlleleCounts.internalBinaryWrite(
        message.overall,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.gnomad.gnomad_sv4.AlleleCounts xx = 2; */
    if (message.xx)
      AlleleCounts.internalBinaryWrite(
        message.xx,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.gnomad.gnomad_sv4.AlleleCounts xy = 3; */
    if (message.xy)
      AlleleCounts.internalBinaryWrite(
        message.xy,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad_sv4.AlleleCountsBySex
 */
export const AlleleCountsBySex = new AlleleCountsBySex$Type()
// @generated message type with reflection information, may provide speed optimized methods
class PopulationAlleleCounts$Type extends MessageType<PopulationAlleleCounts> {
  constructor() {
    super('annonars.gnomad.gnomad_sv4.PopulationAlleleCounts', [
      {
        no: 1,
        name: 'population',
        kind: 'enum',
        T: () => ['annonars.gnomad.gnomad_sv4.Population', Population]
      },
      { no: 2, name: 'counts', kind: 'message', T: () => AlleleCountsBySex }
    ])
  }
  create(value?: PartialMessage<PopulationAlleleCounts>): PopulationAlleleCounts {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.population = 0
    if (value !== undefined) reflectionMergePartial<PopulationAlleleCounts>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PopulationAlleleCounts
  ): PopulationAlleleCounts {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* annonars.gnomad.gnomad_sv4.Population population */ 1:
          message.population = reader.int32()
          break
        case /* annonars.gnomad.gnomad_sv4.AlleleCountsBySex counts */ 2:
          message.counts = AlleleCountsBySex.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.counts
          )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: PopulationAlleleCounts,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* annonars.gnomad.gnomad_sv4.Population population = 1; */
    if (message.population !== 0) writer.tag(1, WireType.Varint).int32(message.population)
    /* annonars.gnomad.gnomad_sv4.AlleleCountsBySex counts = 2; */
    if (message.counts)
      AlleleCountsBySex.internalBinaryWrite(
        message.counts,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad_sv4.PopulationAlleleCounts
 */
export const PopulationAlleleCounts = new PopulationAlleleCounts$Type()
// @generated message type with reflection information, may provide speed optimized methods
class CohortAlleleCounts$Type extends MessageType<CohortAlleleCounts> {
  constructor() {
    super('annonars.gnomad.gnomad_sv4.CohortAlleleCounts', [
      { no: 1, name: 'cohort', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'by_sex', kind: 'message', T: () => AlleleCountsBySex },
      {
        no: 3,
        name: 'by_population',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => PopulationAlleleCounts
      }
    ])
  }
  create(value?: PartialMessage<CohortAlleleCounts>): CohortAlleleCounts {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.byPopulation = []
    if (value !== undefined) reflectionMergePartial<CohortAlleleCounts>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CohortAlleleCounts
  ): CohortAlleleCounts {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional string cohort */ 1:
          message.cohort = reader.string()
          break
        case /* annonars.gnomad.gnomad_sv4.AlleleCountsBySex by_sex */ 2:
          message.bySex = AlleleCountsBySex.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.bySex
          )
          break
        case /* repeated annonars.gnomad.gnomad_sv4.PopulationAlleleCounts by_population */ 3:
          message.byPopulation.push(
            PopulationAlleleCounts.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: CohortAlleleCounts,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional string cohort = 1; */
    if (message.cohort !== undefined) writer.tag(1, WireType.LengthDelimited).string(message.cohort)
    /* annonars.gnomad.gnomad_sv4.AlleleCountsBySex by_sex = 2; */
    if (message.bySex)
      AlleleCountsBySex.internalBinaryWrite(
        message.bySex,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.gnomad.gnomad_sv4.PopulationAlleleCounts by_population = 3; */
    for (let i = 0; i < message.byPopulation.length; i++)
      PopulationAlleleCounts.internalBinaryWrite(
        message.byPopulation[i],
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad_sv4.CohortAlleleCounts
 */
export const CohortAlleleCounts = new CohortAlleleCounts$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Record$Type extends MessageType<Record> {
  constructor() {
    super('annonars.gnomad.gnomad_sv4.Record', [
      { no: 1, name: 'chrom', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'pos', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 3, name: 'end', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      { no: 4, name: 'chrom2', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 5, name: 'end2', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      { no: 6, name: 'id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 7,
        name: 'filters',
        kind: 'enum',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => ['annonars.gnomad.gnomad_sv4.Filter', Filter]
      },
      {
        no: 8,
        name: 'sv_type',
        kind: 'enum',
        T: () => ['annonars.gnomad.gnomad_sv4.SvType', SvType]
      },
      {
        no: 9,
        name: 'cpx_type',
        kind: 'enum',
        opt: true,
        T: () => ['annonars.gnomad.gnomad_sv2.CpxType', CpxType]
      },
      {
        no: 10,
        name: 'allele_counts',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => CohortAlleleCounts
      }
    ])
  }
  create(value?: PartialMessage<Record>): Record {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.chrom = ''
    message.pos = 0
    message.id = ''
    message.filters = []
    message.svType = 0
    message.alleleCounts = []
    if (value !== undefined) reflectionMergePartial<Record>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Record
  ): Record {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string chrom */ 1:
          message.chrom = reader.string()
          break
        case /* int32 pos */ 2:
          message.pos = reader.int32()
          break
        case /* optional int32 end */ 3:
          message.end = reader.int32()
          break
        case /* optional string chrom2 */ 4:
          message.chrom2 = reader.string()
          break
        case /* optional int32 end2 */ 5:
          message.end2 = reader.int32()
          break
        case /* string id */ 6:
          message.id = reader.string()
          break
        case /* repeated annonars.gnomad.gnomad_sv4.Filter filters */ 7:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.filters.push(reader.int32())
          else message.filters.push(reader.int32())
          break
        case /* annonars.gnomad.gnomad_sv4.SvType sv_type */ 8:
          message.svType = reader.int32()
          break
        case /* optional annonars.gnomad.gnomad_sv2.CpxType cpx_type */ 9:
          message.cpxType = reader.int32()
          break
        case /* repeated annonars.gnomad.gnomad_sv4.CohortAlleleCounts allele_counts */ 10:
          message.alleleCounts.push(
            CohortAlleleCounts.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Record,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string chrom = 1; */
    if (message.chrom !== '') writer.tag(1, WireType.LengthDelimited).string(message.chrom)
    /* int32 pos = 2; */
    if (message.pos !== 0) writer.tag(2, WireType.Varint).int32(message.pos)
    /* optional int32 end = 3; */
    if (message.end !== undefined) writer.tag(3, WireType.Varint).int32(message.end)
    /* optional string chrom2 = 4; */
    if (message.chrom2 !== undefined) writer.tag(4, WireType.LengthDelimited).string(message.chrom2)
    /* optional int32 end2 = 5; */
    if (message.end2 !== undefined) writer.tag(5, WireType.Varint).int32(message.end2)
    /* string id = 6; */
    if (message.id !== '') writer.tag(6, WireType.LengthDelimited).string(message.id)
    /* repeated annonars.gnomad.gnomad_sv4.Filter filters = 7; */
    if (message.filters.length) {
      writer.tag(7, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.filters.length; i++) writer.int32(message.filters[i])
      writer.join()
    }
    /* annonars.gnomad.gnomad_sv4.SvType sv_type = 8; */
    if (message.svType !== 0) writer.tag(8, WireType.Varint).int32(message.svType)
    /* optional annonars.gnomad.gnomad_sv2.CpxType cpx_type = 9; */
    if (message.cpxType !== undefined) writer.tag(9, WireType.Varint).int32(message.cpxType)
    /* repeated annonars.gnomad.gnomad_sv4.CohortAlleleCounts allele_counts = 10; */
    for (let i = 0; i < message.alleleCounts.length; i++)
      CohortAlleleCounts.internalBinaryWrite(
        message.alleleCounts[i],
        writer.tag(10, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad_sv4.Record
 */
export const Record = new Record$Type()
