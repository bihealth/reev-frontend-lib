// @generated by protobuf-ts 2.9.3 with parameter keep_enum_prefix
// @generated from protobuf file "annonars/gnomad/gnomad4.proto" (package "annonars.gnomad.gnomad4", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'

import { DepthInfo } from './gnomad3'
import { AgeInfo } from './gnomad3'
import { QualityInfo } from './gnomad3'
import { VariantInfo } from './gnomad3'
import { Filter } from './gnomad3'
import { AlleleCounts } from './gnomad3'
import { AlleleCountsBySex } from './gnomad3'
import { Vep } from './vep_gnomad4'

/**
 * Store details on variant effect predictions.
 *
 * @generated from protobuf message annonars.gnomad.gnomad4.EffectInfo
 */
export interface EffectInfo {
  /**
   * Pangolin's largest delta score across 2 splicing consequences, which reflects the probability of the variant being splice-altering">
   *
   * @generated from protobuf field: optional float pangolin_largest_ds = 1;
   */
  pangolinLargestDs?: number
  /**
   * Base-wise conservation score across the 241 placental mammals in the Zoonomia project. Score ranges from -20 to 9.28, and reflects acceleration (faster evolution than expected under neutral drift, assigned negative scores) as well as conservation (slower than expected evolution, assigned positive scores).">
   *
   * @generated from protobuf field: optional float phylop = 2;
   */
  phylop?: number
  /**
   * Score that predicts the possible impact of an amino acid substitution on the structure and function of a human protein, ranging from 0.0 (tolerated) to 1.0 (deleterious).  We prioritize max scores for MANE Select transcripts where possible and otherwise report a score for the canonical transcript.">
   *
   * @generated from protobuf field: optional float polyphen_max = 3;
   */
  polyphenMax?: number
  /**
   * The maximum REVEL score at a site's MANE Select or canonical transcript. It's an ensemble score for predicting the pathogenicity of missense variants (based on 13 other variant predictors). Scores ranges from 0 to 1. Variants with higher scores are predicted to be more likely to be deleterious.">
   *
   * @generated from protobuf field: optional float revel_max = 4;
   */
  revelMax?: number
  /**
   * Score reflecting the scaled probability of the amino acid substitution being tolerated, ranging from 0 to 1. Scores below 0.05 are predicted to impact protein function. We prioritize max scores for MANE Select transcripts where possible and otherwise report a score for the canonical transcript.">
   *
   * @generated from protobuf field: optional float sift_max = 5;
   */
  siftMax?: number
  /**
   * Illumina's SpliceAI max delta score; interpreted as the probability of the variant being splice-altering.">
   *
   * @generated from protobuf field: optional float spliceai_ds_max = 6;
   */
  spliceaiDsMax?: number
  /**
   * Raw CADD scores are interpretable as the extent to which the annotation profile for a given variant suggests that the variant is likely to be 'observed' (negative values) vs 'simulated' (positive values). Larger values are more deleterious.
   *
   * @generated from protobuf field: optional float cadd_raw = 7;
   */
  caddRaw?: number
  /**
   * Cadd Phred-like scores ('scaled C-scores') ranging from 1 to 99, based on the rank of each variant relative to all possible 8.6 billion substitutions in the human reference genome. Larger values are more deleterious.
   *
   * @generated from protobuf field: optional float cadd_phred = 8;
   */
  caddPhred?: number
}
/**
 * Store the allele counts for the given sub cohort in the given ancestry group.
 *
 * @generated from protobuf message annonars.gnomad.gnomad4.AncestryGroupAlleleCounts
 */
export interface AncestryGroupAlleleCounts {
  /**
   * Name of the ancestry group.
   *
   * @generated from protobuf field: string ancestry_group = 1;
   */
  ancestryGroup: string
  /**
   * The overall allele counts and the one by sex.
   *
   * @generated from protobuf field: annonars.gnomad.gnomad3.AlleleCountsBySex counts = 2;
   */
  counts?: AlleleCountsBySex
  /**
   * The filtering allele frequency (using Poisson 95% CI).
   *
   * @generated from protobuf field: optional float faf95 = 3;
   */
  faf95?: number
  /**
   * The filtering allele frequency (using Poisson 99% CI).
   *
   * @generated from protobuf field: optional float faf99 = 4;
   */
  faf99?: number
  /**
   * The filtering allele frequency for XX samples (using Poisson 95% CI).
   *
   * @generated from protobuf field: optional float faf95_xx = 5;
   */
  faf95Xx?: number
  /**
   * The filtering allele frequency for XX samples (using Poisson 99% CI).
   *
   * @generated from protobuf field: optional float faf99_xx = 6;
   */
  faf99Xx?: number
  /**
   * The filtering allele frequency for XY samples (using Poisson 95% CI).
   *
   * @generated from protobuf field: optional float faf95_xy = 7;
   */
  faf95Xy?: number
  /**
   * The filtering allele frequency for XY samples (using Poisson 99% CI).
   *
   * @generated from protobuf field: optional float faf99_xy = 8;
   */
  faf99Xy?: number
}
/**
 * Store the allele counts for the given cohort.
 *
 * @generated from protobuf message annonars.gnomad.gnomad4.CohortAlleleCounts
 */
export interface CohortAlleleCounts {
  /**
   * Name of the cohort.
   *
   * @generated from protobuf field: optional string cohort = 1;
   */
  cohort?: string
  /**
   * Allele counts for each population.
   *
   * @generated from protobuf field: repeated annonars.gnomad.gnomad4.AncestryGroupAlleleCounts by_ancestry_group = 2;
   */
  byAncestryGroup: AncestryGroupAlleleCounts[]
  /**
   * Allele counts by sex.
   *
   * @generated from protobuf field: annonars.gnomad.gnomad3.AlleleCountsBySex by_sex = 3;
   */
  bySex?: AlleleCountsBySex
  /**
   * Raw allele counts.
   *
   * @generated from protobuf field: annonars.gnomad.gnomad3.AlleleCounts raw = 4;
   */
  raw?: AlleleCounts
  /**
   * The ancestry group with maximum AF.
   *
   * @generated from protobuf field: optional string grpmax = 5;
   */
  grpmax?: string
  /**
   * Maximum allele frequency across ancestry groups.
   *
   * @generated from protobuf field: optional float af_grpmax = 6;
   */
  afGrpmax?: number
  /**
   * Allele count in ancestry group with maximum AF.
   *
   * @generated from protobuf field: optional int32 ac_grpmax = 7;
   */
  acGrpmax?: number
  /**
   * Total number of alleles in ancestry group with maximum AF.
   *
   * @generated from protobuf field: optional int32 an_grpmax = 8;
   */
  anGrpmax?: number
  /**
   * Total number of homozygous individuals in ancestry group with maximum AF.
   *
   * @generated from protobuf field: optional int32 nhomalt_grpmax = 9;
   */
  nhomaltGrpmax?: number
}
/**
 * VRS information
 *
 * @generated from protobuf message annonars.gnomad.gnomad4.VrsInfo
 */
export interface VrsInfo {
  /**
   * The computed identifiers for the GA4GH VRS Alleles corresponding to the values in the REF and ALT fields
   *
   * @generated from protobuf field: repeated string allele_ids = 1;
   */
  alleleIds: string[]
  /**
   * Interresidue coordinates used as the location ends for the GA4GH VRS Alleles corresponding to the values in the REF and ALT fields
   *
   * @generated from protobuf field: repeated int32 ends = 2;
   */
  ends: number[]
  /**
   * Interresidue coordinates used as the location starts for the GA4GH VRS Alleles corresponding to the values in the REF and ALT fields
   *
   * @generated from protobuf field: repeated int32 starts = 3;
   */
  starts: number[]
  /**
   * The literal sequence states used for the GA4GH VRS Alleles corresponding to the values in the REF and ALT fields
   *
   * @generated from protobuf field: repeated string states = 4;
   */
  states: string[]
}
/**
 * Protocol buffer for the gnomAD-nuclear VCF record.
 *
 * The more specialized fields from the INFO column are stored in separate, optional fields such
 * that we don't end up with a humongous message.
 *
 * @generated from protobuf message annonars.gnomad.gnomad4.Record
 */
export interface Record {
  /**
   * Chromosome name.
   *
   * @generated from protobuf field: string chrom = 1;
   */
  chrom: string
  /**
   * 1-based start position.
   *
   * @generated from protobuf field: int32 pos = 2;
   */
  pos: number
  /**
   * Reference allele.
   *
   * @generated from protobuf field: string ref_allele = 3;
   */
  refAllele: string
  /**
   * Alternate allele.
   *
   * @generated from protobuf field: string alt_allele = 4;
   */
  altAllele: string
  /**
   * Site-level filters.
   *
   * @generated from protobuf field: repeated annonars.gnomad.gnomad3.Filter filters = 5;
   */
  filters: Filter[]
  /**
   * VEP annotation records.
   *
   * @generated from protobuf field: repeated annonars.gnomad.vep_gnomad4.Vep vep = 6;
   */
  vep: Vep[]
  /**
   * Variant allele counts in the different cohorts and population.
   *
   * The populations in gnomAD v4 are: empty for global, "joint" for exome+genomes.
   *
   * @generated from protobuf field: repeated annonars.gnomad.gnomad4.CohortAlleleCounts allele_counts = 7;
   */
  alleleCounts: CohortAlleleCounts[]
  /**
   * Variant (on sex chromosome) falls outside a pseudoautosomal region
   *
   * @generated from protobuf field: bool nonpar = 8;
   */
  nonpar: boolean
  /**
   * All samples are heterozygous for the variant
   *
   * @generated from protobuf field: bool only_het = 9;
   */
  onlyHet: boolean
  /**
   * Variant falls outside of Broad exome capture regions (exomes only).
   *
   * @generated from protobuf field: bool outside_broad_capture_region = 10;
   */
  outsideBroadCaptureRegion: boolean
  /**
   * Variant falls outside of UK Biobank exome capture regions(exomes only).
   *
   * @generated from protobuf field: bool outside_ukb_capture_region = 11;
   */
  outsideUkbCaptureRegion: boolean
  /**
   * Variant was a callset-wide doubleton that was present only in two siblings (i.e., a singleton amongst unrelated samples in cohort) (exomes only).
   *
   * @generated from protobuf field: bool sibling_singleton = 12;
   */
  siblingSingleton: boolean
  /**
   * Information on variant scores.
   *
   * @generated from protobuf field: optional annonars.gnomad.gnomad4.EffectInfo effect_info = 13;
   */
  effectInfo?: EffectInfo
  /**
   * Variant-related information details.
   *
   * @generated from protobuf field: optional annonars.gnomad.gnomad3.VariantInfo variant_info = 14;
   */
  variantInfo?: VariantInfo
  /**
   * Summary information for variant quality interpretation.
   *
   * @generated from protobuf field: optional annonars.gnomad.gnomad3.QualityInfo quality_info = 15;
   */
  qualityInfo?: QualityInfo
  /**
   * Age-related information.
   *
   * @generated from protobuf field: optional annonars.gnomad.gnomad3.AgeInfo age_info = 16;
   */
  ageInfo?: AgeInfo
  /**
   * Depth of coverage-related information.
   *
   * @generated from protobuf field: optional annonars.gnomad.gnomad3.DepthInfo depth_info = 17;
   */
  depthInfo?: DepthInfo
  /**
   * VRS infos.
   *
   * @generated from protobuf field: optional annonars.gnomad.gnomad4.VrsInfo vrs_info = 18;
   */
  vrsInfo?: VrsInfo
}
// @generated message type with reflection information, may provide speed optimized methods
class EffectInfo$Type extends MessageType<EffectInfo> {
  constructor() {
    super('annonars.gnomad.gnomad4.EffectInfo', [
      { no: 1, name: 'pangolin_largest_ds', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 2, name: 'phylop', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 3, name: 'polyphen_max', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 4, name: 'revel_max', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 5, name: 'sift_max', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 6, name: 'spliceai_ds_max', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 7, name: 'cadd_raw', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 8, name: 'cadd_phred', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ }
    ])
  }
  create(value?: PartialMessage<EffectInfo>): EffectInfo {
    const message = globalThis.Object.create(this.messagePrototype!)
    if (value !== undefined) reflectionMergePartial<EffectInfo>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: EffectInfo
  ): EffectInfo {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional float pangolin_largest_ds */ 1:
          message.pangolinLargestDs = reader.float()
          break
        case /* optional float phylop */ 2:
          message.phylop = reader.float()
          break
        case /* optional float polyphen_max */ 3:
          message.polyphenMax = reader.float()
          break
        case /* optional float revel_max */ 4:
          message.revelMax = reader.float()
          break
        case /* optional float sift_max */ 5:
          message.siftMax = reader.float()
          break
        case /* optional float spliceai_ds_max */ 6:
          message.spliceaiDsMax = reader.float()
          break
        case /* optional float cadd_raw */ 7:
          message.caddRaw = reader.float()
          break
        case /* optional float cadd_phred */ 8:
          message.caddPhred = reader.float()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: EffectInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional float pangolin_largest_ds = 1; */
    if (message.pangolinLargestDs !== undefined)
      writer.tag(1, WireType.Bit32).float(message.pangolinLargestDs)
    /* optional float phylop = 2; */
    if (message.phylop !== undefined) writer.tag(2, WireType.Bit32).float(message.phylop)
    /* optional float polyphen_max = 3; */
    if (message.polyphenMax !== undefined) writer.tag(3, WireType.Bit32).float(message.polyphenMax)
    /* optional float revel_max = 4; */
    if (message.revelMax !== undefined) writer.tag(4, WireType.Bit32).float(message.revelMax)
    /* optional float sift_max = 5; */
    if (message.siftMax !== undefined) writer.tag(5, WireType.Bit32).float(message.siftMax)
    /* optional float spliceai_ds_max = 6; */
    if (message.spliceaiDsMax !== undefined)
      writer.tag(6, WireType.Bit32).float(message.spliceaiDsMax)
    /* optional float cadd_raw = 7; */
    if (message.caddRaw !== undefined) writer.tag(7, WireType.Bit32).float(message.caddRaw)
    /* optional float cadd_phred = 8; */
    if (message.caddPhred !== undefined) writer.tag(8, WireType.Bit32).float(message.caddPhred)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad4.EffectInfo
 */
export const EffectInfo = new EffectInfo$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AncestryGroupAlleleCounts$Type extends MessageType<AncestryGroupAlleleCounts> {
  constructor() {
    super('annonars.gnomad.gnomad4.AncestryGroupAlleleCounts', [
      { no: 1, name: 'ancestry_group', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'counts', kind: 'message', T: () => AlleleCountsBySex },
      { no: 3, name: 'faf95', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 4, name: 'faf99', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 5, name: 'faf95_xx', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 6, name: 'faf99_xx', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 7, name: 'faf95_xy', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 8, name: 'faf99_xy', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ }
    ])
  }
  create(value?: PartialMessage<AncestryGroupAlleleCounts>): AncestryGroupAlleleCounts {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.ancestryGroup = ''
    if (value !== undefined) reflectionMergePartial<AncestryGroupAlleleCounts>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AncestryGroupAlleleCounts
  ): AncestryGroupAlleleCounts {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string ancestry_group */ 1:
          message.ancestryGroup = reader.string()
          break
        case /* annonars.gnomad.gnomad3.AlleleCountsBySex counts */ 2:
          message.counts = AlleleCountsBySex.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.counts
          )
          break
        case /* optional float faf95 */ 3:
          message.faf95 = reader.float()
          break
        case /* optional float faf99 */ 4:
          message.faf99 = reader.float()
          break
        case /* optional float faf95_xx */ 5:
          message.faf95Xx = reader.float()
          break
        case /* optional float faf99_xx */ 6:
          message.faf99Xx = reader.float()
          break
        case /* optional float faf95_xy */ 7:
          message.faf95Xy = reader.float()
          break
        case /* optional float faf99_xy */ 8:
          message.faf99Xy = reader.float()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: AncestryGroupAlleleCounts,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string ancestry_group = 1; */
    if (message.ancestryGroup !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.ancestryGroup)
    /* annonars.gnomad.gnomad3.AlleleCountsBySex counts = 2; */
    if (message.counts)
      AlleleCountsBySex.internalBinaryWrite(
        message.counts,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional float faf95 = 3; */
    if (message.faf95 !== undefined) writer.tag(3, WireType.Bit32).float(message.faf95)
    /* optional float faf99 = 4; */
    if (message.faf99 !== undefined) writer.tag(4, WireType.Bit32).float(message.faf99)
    /* optional float faf95_xx = 5; */
    if (message.faf95Xx !== undefined) writer.tag(5, WireType.Bit32).float(message.faf95Xx)
    /* optional float faf99_xx = 6; */
    if (message.faf99Xx !== undefined) writer.tag(6, WireType.Bit32).float(message.faf99Xx)
    /* optional float faf95_xy = 7; */
    if (message.faf95Xy !== undefined) writer.tag(7, WireType.Bit32).float(message.faf95Xy)
    /* optional float faf99_xy = 8; */
    if (message.faf99Xy !== undefined) writer.tag(8, WireType.Bit32).float(message.faf99Xy)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad4.AncestryGroupAlleleCounts
 */
export const AncestryGroupAlleleCounts = new AncestryGroupAlleleCounts$Type()
// @generated message type with reflection information, may provide speed optimized methods
class CohortAlleleCounts$Type extends MessageType<CohortAlleleCounts> {
  constructor() {
    super('annonars.gnomad.gnomad4.CohortAlleleCounts', [
      { no: 1, name: 'cohort', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: 'by_ancestry_group',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => AncestryGroupAlleleCounts
      },
      { no: 3, name: 'by_sex', kind: 'message', T: () => AlleleCountsBySex },
      { no: 4, name: 'raw', kind: 'message', T: () => AlleleCounts },
      { no: 5, name: 'grpmax', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 6, name: 'af_grpmax', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 7, name: 'ac_grpmax', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      { no: 8, name: 'an_grpmax', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      { no: 9, name: 'nhomalt_grpmax', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ }
    ])
  }
  create(value?: PartialMessage<CohortAlleleCounts>): CohortAlleleCounts {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.byAncestryGroup = []
    if (value !== undefined) reflectionMergePartial<CohortAlleleCounts>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CohortAlleleCounts
  ): CohortAlleleCounts {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional string cohort */ 1:
          message.cohort = reader.string()
          break
        case /* repeated annonars.gnomad.gnomad4.AncestryGroupAlleleCounts by_ancestry_group */ 2:
          message.byAncestryGroup.push(
            AncestryGroupAlleleCounts.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* annonars.gnomad.gnomad3.AlleleCountsBySex by_sex */ 3:
          message.bySex = AlleleCountsBySex.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.bySex
          )
          break
        case /* annonars.gnomad.gnomad3.AlleleCounts raw */ 4:
          message.raw = AlleleCounts.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.raw
          )
          break
        case /* optional string grpmax */ 5:
          message.grpmax = reader.string()
          break
        case /* optional float af_grpmax */ 6:
          message.afGrpmax = reader.float()
          break
        case /* optional int32 ac_grpmax */ 7:
          message.acGrpmax = reader.int32()
          break
        case /* optional int32 an_grpmax */ 8:
          message.anGrpmax = reader.int32()
          break
        case /* optional int32 nhomalt_grpmax */ 9:
          message.nhomaltGrpmax = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: CohortAlleleCounts,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional string cohort = 1; */
    if (message.cohort !== undefined) writer.tag(1, WireType.LengthDelimited).string(message.cohort)
    /* repeated annonars.gnomad.gnomad4.AncestryGroupAlleleCounts by_ancestry_group = 2; */
    for (let i = 0; i < message.byAncestryGroup.length; i++)
      AncestryGroupAlleleCounts.internalBinaryWrite(
        message.byAncestryGroup[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.gnomad.gnomad3.AlleleCountsBySex by_sex = 3; */
    if (message.bySex)
      AlleleCountsBySex.internalBinaryWrite(
        message.bySex,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.gnomad.gnomad3.AlleleCounts raw = 4; */
    if (message.raw)
      AlleleCounts.internalBinaryWrite(
        message.raw,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional string grpmax = 5; */
    if (message.grpmax !== undefined) writer.tag(5, WireType.LengthDelimited).string(message.grpmax)
    /* optional float af_grpmax = 6; */
    if (message.afGrpmax !== undefined) writer.tag(6, WireType.Bit32).float(message.afGrpmax)
    /* optional int32 ac_grpmax = 7; */
    if (message.acGrpmax !== undefined) writer.tag(7, WireType.Varint).int32(message.acGrpmax)
    /* optional int32 an_grpmax = 8; */
    if (message.anGrpmax !== undefined) writer.tag(8, WireType.Varint).int32(message.anGrpmax)
    /* optional int32 nhomalt_grpmax = 9; */
    if (message.nhomaltGrpmax !== undefined)
      writer.tag(9, WireType.Varint).int32(message.nhomaltGrpmax)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad4.CohortAlleleCounts
 */
export const CohortAlleleCounts = new CohortAlleleCounts$Type()
// @generated message type with reflection information, may provide speed optimized methods
class VrsInfo$Type extends MessageType<VrsInfo> {
  constructor() {
    super('annonars.gnomad.gnomad4.VrsInfo', [
      {
        no: 1,
        name: 'allele_ids',
        kind: 'scalar',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: 'ends',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: 'starts',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: 'states',
        kind: 'scalar',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/
      }
    ])
  }
  create(value?: PartialMessage<VrsInfo>): VrsInfo {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.alleleIds = []
    message.ends = []
    message.starts = []
    message.states = []
    if (value !== undefined) reflectionMergePartial<VrsInfo>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: VrsInfo
  ): VrsInfo {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated string allele_ids */ 1:
          message.alleleIds.push(reader.string())
          break
        case /* repeated int32 ends */ 2:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.ends.push(reader.int32())
          else message.ends.push(reader.int32())
          break
        case /* repeated int32 starts */ 3:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.starts.push(reader.int32())
          else message.starts.push(reader.int32())
          break
        case /* repeated string states */ 4:
          message.states.push(reader.string())
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: VrsInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated string allele_ids = 1; */
    for (let i = 0; i < message.alleleIds.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.alleleIds[i])
    /* repeated int32 ends = 2; */
    if (message.ends.length) {
      writer.tag(2, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.ends.length; i++) writer.int32(message.ends[i])
      writer.join()
    }
    /* repeated int32 starts = 3; */
    if (message.starts.length) {
      writer.tag(3, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.starts.length; i++) writer.int32(message.starts[i])
      writer.join()
    }
    /* repeated string states = 4; */
    for (let i = 0; i < message.states.length; i++)
      writer.tag(4, WireType.LengthDelimited).string(message.states[i])
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad4.VrsInfo
 */
export const VrsInfo = new VrsInfo$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Record$Type extends MessageType<Record> {
  constructor() {
    super('annonars.gnomad.gnomad4.Record', [
      { no: 1, name: 'chrom', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'pos', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 3, name: 'ref_allele', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: 'alt_allele', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 5,
        name: 'filters',
        kind: 'enum',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => ['annonars.gnomad.gnomad3.Filter', Filter]
      },
      { no: 6, name: 'vep', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Vep },
      {
        no: 7,
        name: 'allele_counts',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => CohortAlleleCounts
      },
      { no: 8, name: 'nonpar', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 9, name: 'only_het', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 10, name: 'outside_broad_capture_region', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 11, name: 'outside_ukb_capture_region', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 12, name: 'sibling_singleton', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 13, name: 'effect_info', kind: 'message', T: () => EffectInfo },
      { no: 14, name: 'variant_info', kind: 'message', T: () => VariantInfo },
      { no: 15, name: 'quality_info', kind: 'message', T: () => QualityInfo },
      { no: 16, name: 'age_info', kind: 'message', T: () => AgeInfo },
      { no: 17, name: 'depth_info', kind: 'message', T: () => DepthInfo },
      { no: 18, name: 'vrs_info', kind: 'message', T: () => VrsInfo }
    ])
  }
  create(value?: PartialMessage<Record>): Record {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.chrom = ''
    message.pos = 0
    message.refAllele = ''
    message.altAllele = ''
    message.filters = []
    message.vep = []
    message.alleleCounts = []
    message.nonpar = false
    message.onlyHet = false
    message.outsideBroadCaptureRegion = false
    message.outsideUkbCaptureRegion = false
    message.siblingSingleton = false
    if (value !== undefined) reflectionMergePartial<Record>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Record
  ): Record {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string chrom */ 1:
          message.chrom = reader.string()
          break
        case /* int32 pos */ 2:
          message.pos = reader.int32()
          break
        case /* string ref_allele */ 3:
          message.refAllele = reader.string()
          break
        case /* string alt_allele */ 4:
          message.altAllele = reader.string()
          break
        case /* repeated annonars.gnomad.gnomad3.Filter filters */ 5:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.filters.push(reader.int32())
          else message.filters.push(reader.int32())
          break
        case /* repeated annonars.gnomad.vep_gnomad4.Vep vep */ 6:
          message.vep.push(Vep.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.gnomad.gnomad4.CohortAlleleCounts allele_counts */ 7:
          message.alleleCounts.push(
            CohortAlleleCounts.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* bool nonpar */ 8:
          message.nonpar = reader.bool()
          break
        case /* bool only_het */ 9:
          message.onlyHet = reader.bool()
          break
        case /* bool outside_broad_capture_region */ 10:
          message.outsideBroadCaptureRegion = reader.bool()
          break
        case /* bool outside_ukb_capture_region */ 11:
          message.outsideUkbCaptureRegion = reader.bool()
          break
        case /* bool sibling_singleton */ 12:
          message.siblingSingleton = reader.bool()
          break
        case /* optional annonars.gnomad.gnomad4.EffectInfo effect_info */ 13:
          message.effectInfo = EffectInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.effectInfo
          )
          break
        case /* optional annonars.gnomad.gnomad3.VariantInfo variant_info */ 14:
          message.variantInfo = VariantInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.variantInfo
          )
          break
        case /* optional annonars.gnomad.gnomad3.QualityInfo quality_info */ 15:
          message.qualityInfo = QualityInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.qualityInfo
          )
          break
        case /* optional annonars.gnomad.gnomad3.AgeInfo age_info */ 16:
          message.ageInfo = AgeInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.ageInfo
          )
          break
        case /* optional annonars.gnomad.gnomad3.DepthInfo depth_info */ 17:
          message.depthInfo = DepthInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.depthInfo
          )
          break
        case /* optional annonars.gnomad.gnomad4.VrsInfo vrs_info */ 18:
          message.vrsInfo = VrsInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.vrsInfo
          )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Record,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string chrom = 1; */
    if (message.chrom !== '') writer.tag(1, WireType.LengthDelimited).string(message.chrom)
    /* int32 pos = 2; */
    if (message.pos !== 0) writer.tag(2, WireType.Varint).int32(message.pos)
    /* string ref_allele = 3; */
    if (message.refAllele !== '') writer.tag(3, WireType.LengthDelimited).string(message.refAllele)
    /* string alt_allele = 4; */
    if (message.altAllele !== '') writer.tag(4, WireType.LengthDelimited).string(message.altAllele)
    /* repeated annonars.gnomad.gnomad3.Filter filters = 5; */
    if (message.filters.length) {
      writer.tag(5, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.filters.length; i++) writer.int32(message.filters[i])
      writer.join()
    }
    /* repeated annonars.gnomad.vep_gnomad4.Vep vep = 6; */
    for (let i = 0; i < message.vep.length; i++)
      Vep.internalBinaryWrite(
        message.vep[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.gnomad.gnomad4.CohortAlleleCounts allele_counts = 7; */
    for (let i = 0; i < message.alleleCounts.length; i++)
      CohortAlleleCounts.internalBinaryWrite(
        message.alleleCounts[i],
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* bool nonpar = 8; */
    if (message.nonpar !== false) writer.tag(8, WireType.Varint).bool(message.nonpar)
    /* bool only_het = 9; */
    if (message.onlyHet !== false) writer.tag(9, WireType.Varint).bool(message.onlyHet)
    /* bool outside_broad_capture_region = 10; */
    if (message.outsideBroadCaptureRegion !== false)
      writer.tag(10, WireType.Varint).bool(message.outsideBroadCaptureRegion)
    /* bool outside_ukb_capture_region = 11; */
    if (message.outsideUkbCaptureRegion !== false)
      writer.tag(11, WireType.Varint).bool(message.outsideUkbCaptureRegion)
    /* bool sibling_singleton = 12; */
    if (message.siblingSingleton !== false)
      writer.tag(12, WireType.Varint).bool(message.siblingSingleton)
    /* optional annonars.gnomad.gnomad4.EffectInfo effect_info = 13; */
    if (message.effectInfo)
      EffectInfo.internalBinaryWrite(
        message.effectInfo,
        writer.tag(13, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.gnomad.gnomad3.VariantInfo variant_info = 14; */
    if (message.variantInfo)
      VariantInfo.internalBinaryWrite(
        message.variantInfo,
        writer.tag(14, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.gnomad.gnomad3.QualityInfo quality_info = 15; */
    if (message.qualityInfo)
      QualityInfo.internalBinaryWrite(
        message.qualityInfo,
        writer.tag(15, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.gnomad.gnomad3.AgeInfo age_info = 16; */
    if (message.ageInfo)
      AgeInfo.internalBinaryWrite(
        message.ageInfo,
        writer.tag(16, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.gnomad.gnomad3.DepthInfo depth_info = 17; */
    if (message.depthInfo)
      DepthInfo.internalBinaryWrite(
        message.depthInfo,
        writer.tag(17, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.gnomad.gnomad4.VrsInfo vrs_info = 18; */
    if (message.vrsInfo)
      VrsInfo.internalBinaryWrite(
        message.vrsInfo,
        writer.tag(18, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad4.Record
 */
export const Record = new Record$Type()
