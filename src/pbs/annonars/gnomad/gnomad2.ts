// @generated by protobuf-ts 2.9.3 with parameter keep_enum_prefix,long_type_string
// @generated from protobuf file "annonars/gnomad/gnomad2.proto" (package "annonars.gnomad.gnomad2", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'

import { Vep } from './vep_gnomad2'

/**
 * Store the relevant allele counts and frequencies in a given sub cohort.
 *
 * @generated from protobuf message annonars.gnomad.gnomad2.AlleleCounts
 */
export interface AlleleCounts {
  /**
   * Number of alternate alleles in sub cohort.
   *
   * @generated from protobuf field: int32 ac = 1;
   */
  ac: number
  /**
   * Total number of alleles in the sub cohort.
   *
   * @generated from protobuf field: int32 an = 2;
   */
  an: number
  /**
   * Number of homozygous alternate alleles in the sub cohort.
   *
   * @generated from protobuf field: int32 nhomalt = 3;
   */
  nhomalt: number
  /**
   * Alternate allele frequency in the sub cohort.
   *
   * @generated from protobuf field: float af = 4;
   */
  af: number
}
/**
 * Store the allele counts for the given sub cohort and sub cohort factored by sex.
 *
 * @generated from protobuf message annonars.gnomad.gnomad2.AlleleCountsBySex
 */
export interface AlleleCountsBySex {
  /**
   * Overall allele counts in the sub cohort.
   *
   * @generated from protobuf field: annonars.gnomad.gnomad2.AlleleCounts overall = 1;
   */
  overall?: AlleleCounts
  /**
   * Allele counts in female/XX karyotype individuals of sub cohort.
   *
   * @generated from protobuf field: optional annonars.gnomad.gnomad2.AlleleCounts xx = 2;
   */
  xx?: AlleleCounts
  /**
   * Allele counts in male/XY karyotype individuals of sub cohort.
   *
   * @generated from protobuf field: optional annonars.gnomad.gnomad2.AlleleCounts xy = 3;
   */
  xy?: AlleleCounts
}
/**
 * Store the allele counts for the given population.
 *
 * @generated from protobuf message annonars.gnomad.gnomad2.PopulationAlleleCounts
 */
export interface PopulationAlleleCounts {
  /**
   * Name of the population.
   *
   * @generated from protobuf field: string population = 1;
   */
  population: string
  /**
   * The overall allele counts and the one by sex.
   *
   * @generated from protobuf field: annonars.gnomad.gnomad2.AlleleCountsBySex counts = 2;
   */
  counts?: AlleleCountsBySex
  /**
   * The filtering allele frequency (using Poisson 95% CI).
   *
   * @generated from protobuf field: optional float faf95 = 3;
   */
  faf95?: number
  /**
   * The filtering allele frequency (using Poisson 99% CI).
   *
   * @generated from protobuf field: optional float faf99 = 4;
   */
  faf99?: number
}
/**
 * Store the allele counts for the given cohort.
 *
 * @generated from protobuf message annonars.gnomad.gnomad2.CohortAlleleCounts
 */
export interface CohortAlleleCounts {
  /**
   * Name of the cohort.
   *
   * @generated from protobuf field: optional string cohort = 1;
   */
  cohort?: string
  /**
   * Allele counts for each population.
   *
   * @generated from protobuf field: repeated annonars.gnomad.gnomad2.PopulationAlleleCounts by_population = 2;
   */
  byPopulation: PopulationAlleleCounts[]
  /**
   * Allele counts by sex.
   *
   * @generated from protobuf field: annonars.gnomad.gnomad2.AlleleCountsBySex by_sex = 3;
   */
  bySex?: AlleleCountsBySex
  /**
   * Raw allele counts.
   *
   * @generated from protobuf field: annonars.gnomad.gnomad2.AlleleCounts raw = 4;
   */
  raw?: AlleleCounts
  /**
   * The population with maximum AF.
   *
   * @generated from protobuf field: optional string popmax = 5;
   */
  popmax?: string
  /**
   * Maximum allele frequency across populations (excluding samples of Ashkenazi, Finnish, and
   * indeterminate ancestry).
   *
   * @generated from protobuf field: optional float af_popmax = 6;
   */
  afPopmax?: number
  /**
   * Allele count in population with maximum AF.
   *
   * @generated from protobuf field: optional int32 ac_popmax = 7;
   */
  acPopmax?: number
  /**
   * Total number of alleles in population with maximum AF.
   *
   * @generated from protobuf field: optional int32 an_popmax = 8;
   */
  anPopmax?: number
  /**
   * Total number of homozygous individuals in population with maximum AF.
   *
   * @generated from protobuf field: optional int32 nhomalt_popmax = 9;
   */
  nhomaltPopmax?: number
}
/**
 * Encapsulate VCF INFO fields related to age.
 *
 * @generated from protobuf message annonars.gnomad.gnomad2.AgeInfo
 */
export interface AgeInfo {
  /**
   * Histogram of ages of individuals with a homoplasmic variant; bin edges are: [30.0, 35.0,
   * 40.0, 45.0, 50.0, 55.0, 60.0, 65.0, 70.0, 75.0, 80.0].
   *
   * @generated from protobuf field: repeated int32 age_hist_hom_bin_freq = 1;
   */
  ageHistHomBinFreq: number[]
  /**
   * Count of age values falling below lowest histogram bin edge for individuals with a
   * homoplasmic variant.
   *
   * @generated from protobuf field: optional int32 age_hist_hom_n_smaller = 2;
   */
  ageHistHomNSmaller?: number
  /**
   * Count of age values falling above highest histogram bin edge for individuals with a
   * homoplasmic variant.
   *
   * @generated from protobuf field: optional int32 age_hist_hom_n_larger = 3;
   */
  ageHistHomNLarger?: number
  /**
   * Histogram of ages of individuals with a heteroplasmic variant; bin edges are: [30.0, 35.0,
   * 40.0, 45.0, 50.0, 55.0, 60.0, 65.0, 70.0, 75.0, 80.0]
   *
   * @generated from protobuf field: repeated int32 age_hist_het_bin_freq = 4;
   */
  ageHistHetBinFreq: number[]
  /**
   * Count of age values falling below lowest histogram bin edge for individuals with a
   * heteroplasmic variant.
   *
   * @generated from protobuf field: optional int32 age_hist_het_n_smaller = 5;
   */
  ageHistHetNSmaller?: number
  /**
   * Count of age values falling above highest histogram bin edge for individuals with a
   * heteroplasmic variant.
   *
   * @generated from protobuf field: optional int32 age_hist_het_n_larger = 6;
   */
  ageHistHetNLarger?: number
}
/**
 * Encapsulate VCF INFO fields related to depth.
 *
 * @generated from protobuf message annonars.gnomad.gnomad2.DepthInfo
 */
export interface DepthInfo {
  /**
   * Count of dp values falling above highest histogram bin edge for all individuals.
   *
   * @generated from protobuf field: optional int32 dp_hist_all_n_larger = 1;
   */
  dpHistAllNLarger?: number
  /**
   * Count of dp values falling above highest histogram bin edge for individuals with the
   * alternative allele
   *
   * @generated from protobuf field: optional int32 dp_hist_alt_n_larger = 2;
   */
  dpHistAltNLarger?: number
  /**
   * Histogram of dp values for all individuals; bin edges are: [0.0, 200.0, 400.0, 600.0, 800.0,
   * 1000.0, 1200.0, 1400.0, 1600.0, 1800.0, 2000.0]
   *
   * @generated from protobuf field: repeated int32 dp_hist_all_bin_freq = 3;
   */
  dpHistAllBinFreq: number[]
  /**
   * Histogram of dp values for individuals with the alternative allele; bin edges are: [0.0,
   * 200.0, 400.0, 600.0, 800.0, 1000.0, 1200.0, 1400.0, 1600.0, 1800.0, 2000.0]
   *
   * @generated from protobuf field: repeated int32 dp_hist_alt_bin_freq = 4;
   */
  dpHistAltBinFreq: number[]
}
/**
 * Encapsulate quality-related information.
 *
 * @generated from protobuf message annonars.gnomad.gnomad2.QualityInfo
 */
export interface QualityInfo {
  /**
   * Phred-scaled p-value of Fisher's exact test for strand bias.
   *
   * @generated from protobuf field: optional float fs = 1;
   */
  fs?: number
  /**
   * Inbreeding coefficient as estimated from the genotype likelihoods per-sample when compared
   * against the Hardy-Weinberg expectation.
   *
   * @generated from protobuf field: optional float inbreeding_coeff = 2;
   */
  inbreedingCoeff?: number
  /**
   * Root mean square of the mapping quality of reads across all samples.
   *
   * @generated from protobuf field: optional float mq = 3;
   */
  mq?: number
  /**
   * Z-score from Wilcoxon rank sum test of alternate vs. reference read mapping qualities.
   *
   * @generated from protobuf field: optional float mq_rank_sum = 4;
   */
  mqRankSum?: number
  /**
   * Variant call confidence normalized by depth of sample reads supporting a variant.
   *
   * @generated from protobuf field: optional float qd = 5;
   */
  qd?: number
  /**
   * Z-score from Wilcoxon rank sum test of alternate vs. reference read position bias.
   *
   * @generated from protobuf field: optional float read_pos_rank_sum = 6;
   */
  readPosRankSum?: number
  /**
   * Variant was used to build the positive training set of high-quality variants for VQSR.
   *
   * @generated from protobuf field: bool vqsr_positive_train_site = 7;
   */
  vqsrPositiveTrainSite: boolean
  /**
   * Variant was used to build the negative training set of low-quality variants for VQSR.
   *
   * @generated from protobuf field: bool vqsr_negative_train_site = 8;
   */
  vqsrNegativeTrainSite: boolean
  /**
   * Z-score from Wilcoxon rank sum test of alternate vs. reference base qualities.
   *
   * @generated from protobuf field: optional float base_q_rank_sum = 9;
   */
  baseQRankSum?: number
  /**
   * Z-score from Wilcoxon rank sum test of alternate vs. reference number of hard clipped bases.
   *
   * @generated from protobuf field: optional float clipping_rank_sum = 10;
   */
  clippingRankSum?: number
  /**
   * Strand bias estimated by the symmetric odds ratio test
   *
   * @generated from protobuf field: optional float sor = 11;
   */
  sor?: number
  /**
   * Depth of informative coverage for each sample; reads with MQ=255 or with bad mates are
   * filtered.
   *
   * @generated from protobuf field: optional int32 dp = 12;
   */
  dp?: number
  /**
   * Log-odds ratio of being a true variant versus being a false positive under the trained VQSR
   * Gaussian mixture model.
   *
   * @generated from protobuf field: optional float vqslod = 13;
   */
  vqslod?: number
  /**
   * Allele-specific worst-performing annotation in the VQSR Gaussian mixture model
   *
   * @generated from protobuf field: optional string vqsr_culprit = 14;
   */
  vqsrCulprit?: string
  /**
   * Variant falls within a segmental duplication region
   *
   * @generated from protobuf field: bool segdup = 15;
   */
  segdup: boolean
  /**
   * Variant falls within a low complexity region.
   *
   * @generated from protobuf field: bool lcr = 16;
   */
  lcr: boolean
  /**
   * Variant falls within a reference decoy region.
   *
   * @generated from protobuf field: bool decoy = 17;
   */
  decoy: boolean
  /**
   * Variant was a callset-wide doubleton that was transmitted within a family (i.e., a singleton
   * amongst unrelated sampes in cohort).
   *
   * @generated from protobuf field: bool transmitted_singleton = 18;
   */
  transmittedSingleton: boolean
  /**
   * Maximum p-value over callset for binomial test of observed allele balance for a heterozygous
   * genotype, given expectation of AB=0.5.
   *
   * @generated from protobuf field: optional float pab_max = 19;
   */
  pabMax?: number
}
/**
 * Random forest related information.
 *
 * @generated from protobuf message annonars.gnomad.gnomad2.RandomForestInfo
 */
export interface RandomForestInfo {
  /**
   * Random forest prediction probability for a site being a true variant.
   *
   * @generated from protobuf field: float rf_tp_probability = 1;
   */
  rfTpProbability: number
  /**
   * Variant was labelled as a positive example for training of random forest model.
   *
   * @generated from protobuf field: bool rf_positive_label = 2;
   */
  rfPositiveLabel: boolean
  /**
   * Variant was labelled as a negative example for training of random forest model.
   *
   * @generated from protobuf field: bool rf_negative_label = 3;
   */
  rfNegativeLabel: boolean
  /**
   * Random forest training label.
   *
   * @generated from protobuf field: optional string rf_label = 4;
   */
  rfLabel?: string
  /**
   * Variant was used in training random forest model.
   *
   * @generated from protobuf field: bool rf_train = 5;
   */
  rfTrain: boolean
}
/**
 * Liftover related information.
 *
 * @generated from protobuf message annonars.gnomad.gnomad2.LiftoverInfo
 */
export interface LiftoverInfo {
  /**
   * The REF and the ALT alleles have been reverse complemented in liftover since the mapping from
   * the previous reference to the current one was on the negative strand.
   *
   * @generated from protobuf field: bool reverse_complemented_alleles = 1;
   */
  reverseComplementedAlleles: boolean
  /**
   * The REF and the ALT alleles have been swapped in liftover due to changes in the reference. It
   * is possible that not all INFO annotations reflect this swap, and in the genotypes, only the
   * GT, PL, and AD fields have been modified. You should check the TAGS_TO_REVERSE parameter that
   * was used during the LiftOver to be sure.
   *
   * @generated from protobuf field: bool swapped_alleles = 2;
   */
  swappedAlleles: boolean
  /**
   * A list of the original alleles (including REF) of the variant prior to liftover.  If the
   * alleles were not changed during liftover, this attribute will be omitted.
   *
   * @generated from protobuf field: repeated string original_alleles = 3;
   */
  originalAlleles: string[]
  /**
   * The name of the source contig/chromosome prior to liftover.
   *
   * @generated from protobuf field: optional string original_contig = 4;
   */
  originalContig?: string
  /**
   * The position of the variant on the source contig prior to liftover.
   *
   * @generated from protobuf field: optional string original_start = 5;
   */
  originalStart?: string
}
/**
 * Variant type related information.
 *
 * @generated from protobuf message annonars.gnomad.gnomad2.VariantInfo
 */
export interface VariantInfo {
  /**
   * Variant type (snv, indel, multi-snv, multi-indel, or mixed).
   *
   * @generated from protobuf field: string variant_type = 1;
   */
  variantType: string
  /**
   * Allele type (snv, ins, del, or mixed).
   *
   * @generated from protobuf field: string allele_type = 2;
   */
  alleleType: string
  /**
   * Total number of alternate alleles observed at variant locus.
   *
   * @generated from protobuf field: int32 n_alt_alleles = 3;
   */
  nAltAlleles: number
  /**
   * Variant type was mixed.
   *
   * @generated from protobuf field: bool was_mixed = 4;
   */
  wasMixed: boolean
  /**
   * Variant locus coincides with a spanning deletion (represented by a star) observed elsewhere
   * in the callset.
   *
   * @generated from protobuf field: bool has_star = 5;
   */
  hasStar: boolean
}
/**
 * Protocol buffer for the gnomAD v2 VCF record.
 *
 * The more specialized fields from the INFO column are stored in separate, optional fields such
 * that we don't end up with a humongous message.
 *
 * @generated from protobuf message annonars.gnomad.gnomad2.Record
 */
export interface Record {
  /**
   * Chromosome name.
   *
   * @generated from protobuf field: string chrom = 1;
   */
  chrom: string
  /**
   * 1-based start position.
   *
   * @generated from protobuf field: int32 pos = 2;
   */
  pos: number
  /**
   * Reference allele.
   *
   * @generated from protobuf field: string ref_allele = 3;
   */
  refAllele: string
  /**
   * Alternate allele.
   *
   * @generated from protobuf field: string alt_allele = 4;
   */
  altAllele: string
  /**
   * Site-level filters.
   *
   * @generated from protobuf field: repeated annonars.gnomad.gnomad2.Filter filters = 5;
   */
  filters: Filter[]
  /**
   * VEP annotation records.
   *
   * @generated from protobuf field: repeated annonars.gnomad.vep_gnomad2.Vep vep = 6;
   */
  vep: Vep[]
  /**
   * Variant allele counts in the different cohorts and population.
   *
   * The populations in gnomAD v2/3 are: empty for global, "controls", "non_cancer", "non_neuro",
   * and "non_topmed".
   *
   * @generated from protobuf field: repeated annonars.gnomad.gnomad2.CohortAlleleCounts allele_counts = 7;
   */
  alleleCounts: CohortAlleleCounts[]
  /**
   * Variant (on sex chromosome) falls outside a pseudoautosomal region
   *
   * @generated from protobuf field: bool nonpar = 8;
   */
  nonpar: boolean
  /**
   * Information on lift-over from GRCh37 to GRCh38.
   *
   * @generated from protobuf field: optional annonars.gnomad.gnomad2.LiftoverInfo liftover_info = 9;
   */
  liftoverInfo?: LiftoverInfo
  /**
   * Random forest related information.
   *
   * @generated from protobuf field: optional annonars.gnomad.gnomad2.RandomForestInfo rf_info = 10;
   */
  rfInfo?: RandomForestInfo
  /**
   * Variant-related information details.
   *
   * @generated from protobuf field: optional annonars.gnomad.gnomad2.VariantInfo variant_info = 11;
   */
  variantInfo?: VariantInfo
  /**
   * Summary information for variant quality interpretation.
   *
   * @generated from protobuf field: optional annonars.gnomad.gnomad2.QualityInfo quality_info = 12;
   */
  qualityInfo?: QualityInfo
  /**
   * Age-related information.
   *
   * @generated from protobuf field: optional annonars.gnomad.gnomad2.AgeInfo age_info = 13;
   */
  ageInfo?: AgeInfo
  /**
   * Depth of coverage-related information.
   *
   * @generated from protobuf field: optional annonars.gnomad.gnomad2.DepthInfo depth_info = 14;
   */
  depthInfo?: DepthInfo
}
/**
 * Protocol buffer enum for site-level filters.
 *
 * @generated from protobuf enum annonars.gnomad.gnomad2.Filter
 */
export enum Filter {
  /**
   * unknown
   *
   * @generated from protobuf enum value: FILTER_UNKNOWN = 0;
   */
  FILTER_UNKNOWN = 0,
  /**
   * Allele count is zero after filtering out low-confidence genotypes (GQ < 20; DP < 10; and AB <
   * 0.2 for het calls).
   *
   * @generated from protobuf enum value: FILTER_ALLELE_COUNT_IS_ZERO = 1;
   */
  FILTER_ALLELE_COUNT_IS_ZERO = 1,
  /**
   * InbreedingCoeff < -0.3.
   *
   * @generated from protobuf enum value: FILTER_INBREEDING_COEFF = 2;
   */
  FILTER_INBREEDING_COEFF = 2,
  /**
   * Passed all variant filters
   *
   * @generated from protobuf enum value: FILTER_PASS = 3;
   */
  FILTER_PASS = 3,
  /**
   * Failed random forest filtering thresholds of 0.055272738028512555, 0.20641025579497013
   * (probabilities of being a true positive variant) for SNPs, indels
   *
   * @generated from protobuf enum value: FILTER_RANDOM_FOREST = 4;
   */
  FILTER_RANDOM_FOREST = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class AlleleCounts$Type extends MessageType<AlleleCounts> {
  constructor() {
    super('annonars.gnomad.gnomad2.AlleleCounts', [
      { no: 1, name: 'ac', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 2, name: 'an', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 3, name: 'nhomalt', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 4, name: 'af', kind: 'scalar', T: 2 /*ScalarType.FLOAT*/ }
    ])
  }
  create(value?: PartialMessage<AlleleCounts>): AlleleCounts {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.ac = 0
    message.an = 0
    message.nhomalt = 0
    message.af = 0
    if (value !== undefined) reflectionMergePartial<AlleleCounts>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AlleleCounts
  ): AlleleCounts {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* int32 ac */ 1:
          message.ac = reader.int32()
          break
        case /* int32 an */ 2:
          message.an = reader.int32()
          break
        case /* int32 nhomalt */ 3:
          message.nhomalt = reader.int32()
          break
        case /* float af */ 4:
          message.af = reader.float()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: AlleleCounts,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* int32 ac = 1; */
    if (message.ac !== 0) writer.tag(1, WireType.Varint).int32(message.ac)
    /* int32 an = 2; */
    if (message.an !== 0) writer.tag(2, WireType.Varint).int32(message.an)
    /* int32 nhomalt = 3; */
    if (message.nhomalt !== 0) writer.tag(3, WireType.Varint).int32(message.nhomalt)
    /* float af = 4; */
    if (message.af !== 0) writer.tag(4, WireType.Bit32).float(message.af)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad2.AlleleCounts
 */
export const AlleleCounts = new AlleleCounts$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AlleleCountsBySex$Type extends MessageType<AlleleCountsBySex> {
  constructor() {
    super('annonars.gnomad.gnomad2.AlleleCountsBySex', [
      { no: 1, name: 'overall', kind: 'message', T: () => AlleleCounts },
      { no: 2, name: 'xx', kind: 'message', T: () => AlleleCounts },
      { no: 3, name: 'xy', kind: 'message', T: () => AlleleCounts }
    ])
  }
  create(value?: PartialMessage<AlleleCountsBySex>): AlleleCountsBySex {
    const message = globalThis.Object.create(this.messagePrototype!)
    if (value !== undefined) reflectionMergePartial<AlleleCountsBySex>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AlleleCountsBySex
  ): AlleleCountsBySex {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* annonars.gnomad.gnomad2.AlleleCounts overall */ 1:
          message.overall = AlleleCounts.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.overall
          )
          break
        case /* optional annonars.gnomad.gnomad2.AlleleCounts xx */ 2:
          message.xx = AlleleCounts.internalBinaryRead(reader, reader.uint32(), options, message.xx)
          break
        case /* optional annonars.gnomad.gnomad2.AlleleCounts xy */ 3:
          message.xy = AlleleCounts.internalBinaryRead(reader, reader.uint32(), options, message.xy)
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: AlleleCountsBySex,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* annonars.gnomad.gnomad2.AlleleCounts overall = 1; */
    if (message.overall)
      AlleleCounts.internalBinaryWrite(
        message.overall,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.gnomad.gnomad2.AlleleCounts xx = 2; */
    if (message.xx)
      AlleleCounts.internalBinaryWrite(
        message.xx,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.gnomad.gnomad2.AlleleCounts xy = 3; */
    if (message.xy)
      AlleleCounts.internalBinaryWrite(
        message.xy,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad2.AlleleCountsBySex
 */
export const AlleleCountsBySex = new AlleleCountsBySex$Type()
// @generated message type with reflection information, may provide speed optimized methods
class PopulationAlleleCounts$Type extends MessageType<PopulationAlleleCounts> {
  constructor() {
    super('annonars.gnomad.gnomad2.PopulationAlleleCounts', [
      { no: 1, name: 'population', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'counts', kind: 'message', T: () => AlleleCountsBySex },
      { no: 3, name: 'faf95', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 4, name: 'faf99', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ }
    ])
  }
  create(value?: PartialMessage<PopulationAlleleCounts>): PopulationAlleleCounts {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.population = ''
    if (value !== undefined) reflectionMergePartial<PopulationAlleleCounts>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PopulationAlleleCounts
  ): PopulationAlleleCounts {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string population */ 1:
          message.population = reader.string()
          break
        case /* annonars.gnomad.gnomad2.AlleleCountsBySex counts */ 2:
          message.counts = AlleleCountsBySex.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.counts
          )
          break
        case /* optional float faf95 */ 3:
          message.faf95 = reader.float()
          break
        case /* optional float faf99 */ 4:
          message.faf99 = reader.float()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: PopulationAlleleCounts,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string population = 1; */
    if (message.population !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.population)
    /* annonars.gnomad.gnomad2.AlleleCountsBySex counts = 2; */
    if (message.counts)
      AlleleCountsBySex.internalBinaryWrite(
        message.counts,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional float faf95 = 3; */
    if (message.faf95 !== undefined) writer.tag(3, WireType.Bit32).float(message.faf95)
    /* optional float faf99 = 4; */
    if (message.faf99 !== undefined) writer.tag(4, WireType.Bit32).float(message.faf99)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad2.PopulationAlleleCounts
 */
export const PopulationAlleleCounts = new PopulationAlleleCounts$Type()
// @generated message type with reflection information, may provide speed optimized methods
class CohortAlleleCounts$Type extends MessageType<CohortAlleleCounts> {
  constructor() {
    super('annonars.gnomad.gnomad2.CohortAlleleCounts', [
      { no: 1, name: 'cohort', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: 'by_population',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => PopulationAlleleCounts
      },
      { no: 3, name: 'by_sex', kind: 'message', T: () => AlleleCountsBySex },
      { no: 4, name: 'raw', kind: 'message', T: () => AlleleCounts },
      { no: 5, name: 'popmax', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 6, name: 'af_popmax', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 7, name: 'ac_popmax', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      { no: 8, name: 'an_popmax', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      { no: 9, name: 'nhomalt_popmax', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ }
    ])
  }
  create(value?: PartialMessage<CohortAlleleCounts>): CohortAlleleCounts {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.byPopulation = []
    if (value !== undefined) reflectionMergePartial<CohortAlleleCounts>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CohortAlleleCounts
  ): CohortAlleleCounts {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional string cohort */ 1:
          message.cohort = reader.string()
          break
        case /* repeated annonars.gnomad.gnomad2.PopulationAlleleCounts by_population */ 2:
          message.byPopulation.push(
            PopulationAlleleCounts.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* annonars.gnomad.gnomad2.AlleleCountsBySex by_sex */ 3:
          message.bySex = AlleleCountsBySex.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.bySex
          )
          break
        case /* annonars.gnomad.gnomad2.AlleleCounts raw */ 4:
          message.raw = AlleleCounts.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.raw
          )
          break
        case /* optional string popmax */ 5:
          message.popmax = reader.string()
          break
        case /* optional float af_popmax */ 6:
          message.afPopmax = reader.float()
          break
        case /* optional int32 ac_popmax */ 7:
          message.acPopmax = reader.int32()
          break
        case /* optional int32 an_popmax */ 8:
          message.anPopmax = reader.int32()
          break
        case /* optional int32 nhomalt_popmax */ 9:
          message.nhomaltPopmax = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: CohortAlleleCounts,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional string cohort = 1; */
    if (message.cohort !== undefined) writer.tag(1, WireType.LengthDelimited).string(message.cohort)
    /* repeated annonars.gnomad.gnomad2.PopulationAlleleCounts by_population = 2; */
    for (let i = 0; i < message.byPopulation.length; i++)
      PopulationAlleleCounts.internalBinaryWrite(
        message.byPopulation[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.gnomad.gnomad2.AlleleCountsBySex by_sex = 3; */
    if (message.bySex)
      AlleleCountsBySex.internalBinaryWrite(
        message.bySex,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.gnomad.gnomad2.AlleleCounts raw = 4; */
    if (message.raw)
      AlleleCounts.internalBinaryWrite(
        message.raw,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional string popmax = 5; */
    if (message.popmax !== undefined) writer.tag(5, WireType.LengthDelimited).string(message.popmax)
    /* optional float af_popmax = 6; */
    if (message.afPopmax !== undefined) writer.tag(6, WireType.Bit32).float(message.afPopmax)
    /* optional int32 ac_popmax = 7; */
    if (message.acPopmax !== undefined) writer.tag(7, WireType.Varint).int32(message.acPopmax)
    /* optional int32 an_popmax = 8; */
    if (message.anPopmax !== undefined) writer.tag(8, WireType.Varint).int32(message.anPopmax)
    /* optional int32 nhomalt_popmax = 9; */
    if (message.nhomaltPopmax !== undefined)
      writer.tag(9, WireType.Varint).int32(message.nhomaltPopmax)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad2.CohortAlleleCounts
 */
export const CohortAlleleCounts = new CohortAlleleCounts$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AgeInfo$Type extends MessageType<AgeInfo> {
  constructor() {
    super('annonars.gnomad.gnomad2.AgeInfo', [
      {
        no: 1,
        name: 'age_hist_hom_bin_freq',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 2,
        name: 'age_hist_hom_n_smaller',
        kind: 'scalar',
        opt: true,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: 'age_hist_hom_n_larger',
        kind: 'scalar',
        opt: true,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: 'age_hist_het_bin_freq',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 5,
        name: 'age_hist_het_n_smaller',
        kind: 'scalar',
        opt: true,
        T: 5 /*ScalarType.INT32*/
      },
      { no: 6, name: 'age_hist_het_n_larger', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ }
    ])
  }
  create(value?: PartialMessage<AgeInfo>): AgeInfo {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.ageHistHomBinFreq = []
    message.ageHistHetBinFreq = []
    if (value !== undefined) reflectionMergePartial<AgeInfo>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AgeInfo
  ): AgeInfo {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated int32 age_hist_hom_bin_freq */ 1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.ageHistHomBinFreq.push(reader.int32())
          else message.ageHistHomBinFreq.push(reader.int32())
          break
        case /* optional int32 age_hist_hom_n_smaller */ 2:
          message.ageHistHomNSmaller = reader.int32()
          break
        case /* optional int32 age_hist_hom_n_larger */ 3:
          message.ageHistHomNLarger = reader.int32()
          break
        case /* repeated int32 age_hist_het_bin_freq */ 4:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.ageHistHetBinFreq.push(reader.int32())
          else message.ageHistHetBinFreq.push(reader.int32())
          break
        case /* optional int32 age_hist_het_n_smaller */ 5:
          message.ageHistHetNSmaller = reader.int32()
          break
        case /* optional int32 age_hist_het_n_larger */ 6:
          message.ageHistHetNLarger = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: AgeInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated int32 age_hist_hom_bin_freq = 1; */
    if (message.ageHistHomBinFreq.length) {
      writer.tag(1, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.ageHistHomBinFreq.length; i++)
        writer.int32(message.ageHistHomBinFreq[i])
      writer.join()
    }
    /* optional int32 age_hist_hom_n_smaller = 2; */
    if (message.ageHistHomNSmaller !== undefined)
      writer.tag(2, WireType.Varint).int32(message.ageHistHomNSmaller)
    /* optional int32 age_hist_hom_n_larger = 3; */
    if (message.ageHistHomNLarger !== undefined)
      writer.tag(3, WireType.Varint).int32(message.ageHistHomNLarger)
    /* repeated int32 age_hist_het_bin_freq = 4; */
    if (message.ageHistHetBinFreq.length) {
      writer.tag(4, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.ageHistHetBinFreq.length; i++)
        writer.int32(message.ageHistHetBinFreq[i])
      writer.join()
    }
    /* optional int32 age_hist_het_n_smaller = 5; */
    if (message.ageHistHetNSmaller !== undefined)
      writer.tag(5, WireType.Varint).int32(message.ageHistHetNSmaller)
    /* optional int32 age_hist_het_n_larger = 6; */
    if (message.ageHistHetNLarger !== undefined)
      writer.tag(6, WireType.Varint).int32(message.ageHistHetNLarger)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad2.AgeInfo
 */
export const AgeInfo = new AgeInfo$Type()
// @generated message type with reflection information, may provide speed optimized methods
class DepthInfo$Type extends MessageType<DepthInfo> {
  constructor() {
    super('annonars.gnomad.gnomad2.DepthInfo', [
      { no: 1, name: 'dp_hist_all_n_larger', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      { no: 2, name: 'dp_hist_alt_n_larger', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      {
        no: 3,
        name: 'dp_hist_all_bin_freq',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: 'dp_hist_alt_bin_freq',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      }
    ])
  }
  create(value?: PartialMessage<DepthInfo>): DepthInfo {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.dpHistAllBinFreq = []
    message.dpHistAltBinFreq = []
    if (value !== undefined) reflectionMergePartial<DepthInfo>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DepthInfo
  ): DepthInfo {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional int32 dp_hist_all_n_larger */ 1:
          message.dpHistAllNLarger = reader.int32()
          break
        case /* optional int32 dp_hist_alt_n_larger */ 2:
          message.dpHistAltNLarger = reader.int32()
          break
        case /* repeated int32 dp_hist_all_bin_freq */ 3:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.dpHistAllBinFreq.push(reader.int32())
          else message.dpHistAllBinFreq.push(reader.int32())
          break
        case /* repeated int32 dp_hist_alt_bin_freq */ 4:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.dpHistAltBinFreq.push(reader.int32())
          else message.dpHistAltBinFreq.push(reader.int32())
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: DepthInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional int32 dp_hist_all_n_larger = 1; */
    if (message.dpHistAllNLarger !== undefined)
      writer.tag(1, WireType.Varint).int32(message.dpHistAllNLarger)
    /* optional int32 dp_hist_alt_n_larger = 2; */
    if (message.dpHistAltNLarger !== undefined)
      writer.tag(2, WireType.Varint).int32(message.dpHistAltNLarger)
    /* repeated int32 dp_hist_all_bin_freq = 3; */
    if (message.dpHistAllBinFreq.length) {
      writer.tag(3, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.dpHistAllBinFreq.length; i++)
        writer.int32(message.dpHistAllBinFreq[i])
      writer.join()
    }
    /* repeated int32 dp_hist_alt_bin_freq = 4; */
    if (message.dpHistAltBinFreq.length) {
      writer.tag(4, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.dpHistAltBinFreq.length; i++)
        writer.int32(message.dpHistAltBinFreq[i])
      writer.join()
    }
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad2.DepthInfo
 */
export const DepthInfo = new DepthInfo$Type()
// @generated message type with reflection information, may provide speed optimized methods
class QualityInfo$Type extends MessageType<QualityInfo> {
  constructor() {
    super('annonars.gnomad.gnomad2.QualityInfo', [
      { no: 1, name: 'fs', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 2, name: 'inbreeding_coeff', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 3, name: 'mq', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 4, name: 'mq_rank_sum', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 5, name: 'qd', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 6, name: 'read_pos_rank_sum', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 7, name: 'vqsr_positive_train_site', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 8, name: 'vqsr_negative_train_site', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 9, name: 'base_q_rank_sum', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 10, name: 'clipping_rank_sum', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 11, name: 'sor', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 12, name: 'dp', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      { no: 13, name: 'vqslod', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 14, name: 'vqsr_culprit', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 15, name: 'segdup', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 16, name: 'lcr', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 17, name: 'decoy', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 18, name: 'transmitted_singleton', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 19, name: 'pab_max', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ }
    ])
  }
  create(value?: PartialMessage<QualityInfo>): QualityInfo {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.vqsrPositiveTrainSite = false
    message.vqsrNegativeTrainSite = false
    message.segdup = false
    message.lcr = false
    message.decoy = false
    message.transmittedSingleton = false
    if (value !== undefined) reflectionMergePartial<QualityInfo>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QualityInfo
  ): QualityInfo {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional float fs */ 1:
          message.fs = reader.float()
          break
        case /* optional float inbreeding_coeff */ 2:
          message.inbreedingCoeff = reader.float()
          break
        case /* optional float mq */ 3:
          message.mq = reader.float()
          break
        case /* optional float mq_rank_sum */ 4:
          message.mqRankSum = reader.float()
          break
        case /* optional float qd */ 5:
          message.qd = reader.float()
          break
        case /* optional float read_pos_rank_sum */ 6:
          message.readPosRankSum = reader.float()
          break
        case /* bool vqsr_positive_train_site */ 7:
          message.vqsrPositiveTrainSite = reader.bool()
          break
        case /* bool vqsr_negative_train_site */ 8:
          message.vqsrNegativeTrainSite = reader.bool()
          break
        case /* optional float base_q_rank_sum */ 9:
          message.baseQRankSum = reader.float()
          break
        case /* optional float clipping_rank_sum */ 10:
          message.clippingRankSum = reader.float()
          break
        case /* optional float sor */ 11:
          message.sor = reader.float()
          break
        case /* optional int32 dp */ 12:
          message.dp = reader.int32()
          break
        case /* optional float vqslod */ 13:
          message.vqslod = reader.float()
          break
        case /* optional string vqsr_culprit */ 14:
          message.vqsrCulprit = reader.string()
          break
        case /* bool segdup */ 15:
          message.segdup = reader.bool()
          break
        case /* bool lcr */ 16:
          message.lcr = reader.bool()
          break
        case /* bool decoy */ 17:
          message.decoy = reader.bool()
          break
        case /* bool transmitted_singleton */ 18:
          message.transmittedSingleton = reader.bool()
          break
        case /* optional float pab_max */ 19:
          message.pabMax = reader.float()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QualityInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional float fs = 1; */
    if (message.fs !== undefined) writer.tag(1, WireType.Bit32).float(message.fs)
    /* optional float inbreeding_coeff = 2; */
    if (message.inbreedingCoeff !== undefined)
      writer.tag(2, WireType.Bit32).float(message.inbreedingCoeff)
    /* optional float mq = 3; */
    if (message.mq !== undefined) writer.tag(3, WireType.Bit32).float(message.mq)
    /* optional float mq_rank_sum = 4; */
    if (message.mqRankSum !== undefined) writer.tag(4, WireType.Bit32).float(message.mqRankSum)
    /* optional float qd = 5; */
    if (message.qd !== undefined) writer.tag(5, WireType.Bit32).float(message.qd)
    /* optional float read_pos_rank_sum = 6; */
    if (message.readPosRankSum !== undefined)
      writer.tag(6, WireType.Bit32).float(message.readPosRankSum)
    /* bool vqsr_positive_train_site = 7; */
    if (message.vqsrPositiveTrainSite !== false)
      writer.tag(7, WireType.Varint).bool(message.vqsrPositiveTrainSite)
    /* bool vqsr_negative_train_site = 8; */
    if (message.vqsrNegativeTrainSite !== false)
      writer.tag(8, WireType.Varint).bool(message.vqsrNegativeTrainSite)
    /* optional float base_q_rank_sum = 9; */
    if (message.baseQRankSum !== undefined)
      writer.tag(9, WireType.Bit32).float(message.baseQRankSum)
    /* optional float clipping_rank_sum = 10; */
    if (message.clippingRankSum !== undefined)
      writer.tag(10, WireType.Bit32).float(message.clippingRankSum)
    /* optional float sor = 11; */
    if (message.sor !== undefined) writer.tag(11, WireType.Bit32).float(message.sor)
    /* optional int32 dp = 12; */
    if (message.dp !== undefined) writer.tag(12, WireType.Varint).int32(message.dp)
    /* optional float vqslod = 13; */
    if (message.vqslod !== undefined) writer.tag(13, WireType.Bit32).float(message.vqslod)
    /* optional string vqsr_culprit = 14; */
    if (message.vqsrCulprit !== undefined)
      writer.tag(14, WireType.LengthDelimited).string(message.vqsrCulprit)
    /* bool segdup = 15; */
    if (message.segdup !== false) writer.tag(15, WireType.Varint).bool(message.segdup)
    /* bool lcr = 16; */
    if (message.lcr !== false) writer.tag(16, WireType.Varint).bool(message.lcr)
    /* bool decoy = 17; */
    if (message.decoy !== false) writer.tag(17, WireType.Varint).bool(message.decoy)
    /* bool transmitted_singleton = 18; */
    if (message.transmittedSingleton !== false)
      writer.tag(18, WireType.Varint).bool(message.transmittedSingleton)
    /* optional float pab_max = 19; */
    if (message.pabMax !== undefined) writer.tag(19, WireType.Bit32).float(message.pabMax)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad2.QualityInfo
 */
export const QualityInfo = new QualityInfo$Type()
// @generated message type with reflection information, may provide speed optimized methods
class RandomForestInfo$Type extends MessageType<RandomForestInfo> {
  constructor() {
    super('annonars.gnomad.gnomad2.RandomForestInfo', [
      { no: 1, name: 'rf_tp_probability', kind: 'scalar', T: 2 /*ScalarType.FLOAT*/ },
      { no: 2, name: 'rf_positive_label', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 3, name: 'rf_negative_label', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 4, name: 'rf_label', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 5, name: 'rf_train', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ }
    ])
  }
  create(value?: PartialMessage<RandomForestInfo>): RandomForestInfo {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.rfTpProbability = 0
    message.rfPositiveLabel = false
    message.rfNegativeLabel = false
    message.rfTrain = false
    if (value !== undefined) reflectionMergePartial<RandomForestInfo>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RandomForestInfo
  ): RandomForestInfo {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* float rf_tp_probability */ 1:
          message.rfTpProbability = reader.float()
          break
        case /* bool rf_positive_label */ 2:
          message.rfPositiveLabel = reader.bool()
          break
        case /* bool rf_negative_label */ 3:
          message.rfNegativeLabel = reader.bool()
          break
        case /* optional string rf_label */ 4:
          message.rfLabel = reader.string()
          break
        case /* bool rf_train */ 5:
          message.rfTrain = reader.bool()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: RandomForestInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* float rf_tp_probability = 1; */
    if (message.rfTpProbability !== 0) writer.tag(1, WireType.Bit32).float(message.rfTpProbability)
    /* bool rf_positive_label = 2; */
    if (message.rfPositiveLabel !== false)
      writer.tag(2, WireType.Varint).bool(message.rfPositiveLabel)
    /* bool rf_negative_label = 3; */
    if (message.rfNegativeLabel !== false)
      writer.tag(3, WireType.Varint).bool(message.rfNegativeLabel)
    /* optional string rf_label = 4; */
    if (message.rfLabel !== undefined)
      writer.tag(4, WireType.LengthDelimited).string(message.rfLabel)
    /* bool rf_train = 5; */
    if (message.rfTrain !== false) writer.tag(5, WireType.Varint).bool(message.rfTrain)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad2.RandomForestInfo
 */
export const RandomForestInfo = new RandomForestInfo$Type()
// @generated message type with reflection information, may provide speed optimized methods
class LiftoverInfo$Type extends MessageType<LiftoverInfo> {
  constructor() {
    super('annonars.gnomad.gnomad2.LiftoverInfo', [
      { no: 1, name: 'reverse_complemented_alleles', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 2, name: 'swapped_alleles', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      {
        no: 3,
        name: 'original_alleles',
        kind: 'scalar',
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/
      },
      { no: 4, name: 'original_contig', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 5, name: 'original_start', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ }
    ])
  }
  create(value?: PartialMessage<LiftoverInfo>): LiftoverInfo {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.reverseComplementedAlleles = false
    message.swappedAlleles = false
    message.originalAlleles = []
    if (value !== undefined) reflectionMergePartial<LiftoverInfo>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: LiftoverInfo
  ): LiftoverInfo {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* bool reverse_complemented_alleles */ 1:
          message.reverseComplementedAlleles = reader.bool()
          break
        case /* bool swapped_alleles */ 2:
          message.swappedAlleles = reader.bool()
          break
        case /* repeated string original_alleles */ 3:
          message.originalAlleles.push(reader.string())
          break
        case /* optional string original_contig */ 4:
          message.originalContig = reader.string()
          break
        case /* optional string original_start */ 5:
          message.originalStart = reader.string()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: LiftoverInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* bool reverse_complemented_alleles = 1; */
    if (message.reverseComplementedAlleles !== false)
      writer.tag(1, WireType.Varint).bool(message.reverseComplementedAlleles)
    /* bool swapped_alleles = 2; */
    if (message.swappedAlleles !== false)
      writer.tag(2, WireType.Varint).bool(message.swappedAlleles)
    /* repeated string original_alleles = 3; */
    for (let i = 0; i < message.originalAlleles.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.originalAlleles[i])
    /* optional string original_contig = 4; */
    if (message.originalContig !== undefined)
      writer.tag(4, WireType.LengthDelimited).string(message.originalContig)
    /* optional string original_start = 5; */
    if (message.originalStart !== undefined)
      writer.tag(5, WireType.LengthDelimited).string(message.originalStart)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad2.LiftoverInfo
 */
export const LiftoverInfo = new LiftoverInfo$Type()
// @generated message type with reflection information, may provide speed optimized methods
class VariantInfo$Type extends MessageType<VariantInfo> {
  constructor() {
    super('annonars.gnomad.gnomad2.VariantInfo', [
      { no: 1, name: 'variant_type', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'allele_type', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'n_alt_alleles', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 4, name: 'was_mixed', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 5, name: 'has_star', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ }
    ])
  }
  create(value?: PartialMessage<VariantInfo>): VariantInfo {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.variantType = ''
    message.alleleType = ''
    message.nAltAlleles = 0
    message.wasMixed = false
    message.hasStar = false
    if (value !== undefined) reflectionMergePartial<VariantInfo>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: VariantInfo
  ): VariantInfo {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string variant_type */ 1:
          message.variantType = reader.string()
          break
        case /* string allele_type */ 2:
          message.alleleType = reader.string()
          break
        case /* int32 n_alt_alleles */ 3:
          message.nAltAlleles = reader.int32()
          break
        case /* bool was_mixed */ 4:
          message.wasMixed = reader.bool()
          break
        case /* bool has_star */ 5:
          message.hasStar = reader.bool()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: VariantInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string variant_type = 1; */
    if (message.variantType !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.variantType)
    /* string allele_type = 2; */
    if (message.alleleType !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.alleleType)
    /* int32 n_alt_alleles = 3; */
    if (message.nAltAlleles !== 0) writer.tag(3, WireType.Varint).int32(message.nAltAlleles)
    /* bool was_mixed = 4; */
    if (message.wasMixed !== false) writer.tag(4, WireType.Varint).bool(message.wasMixed)
    /* bool has_star = 5; */
    if (message.hasStar !== false) writer.tag(5, WireType.Varint).bool(message.hasStar)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad2.VariantInfo
 */
export const VariantInfo = new VariantInfo$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Record$Type extends MessageType<Record> {
  constructor() {
    super('annonars.gnomad.gnomad2.Record', [
      { no: 1, name: 'chrom', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'pos', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 3, name: 'ref_allele', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: 'alt_allele', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 5,
        name: 'filters',
        kind: 'enum',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => ['annonars.gnomad.gnomad2.Filter', Filter]
      },
      { no: 6, name: 'vep', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Vep },
      {
        no: 7,
        name: 'allele_counts',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => CohortAlleleCounts
      },
      { no: 8, name: 'nonpar', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 9, name: 'liftover_info', kind: 'message', T: () => LiftoverInfo },
      { no: 10, name: 'rf_info', kind: 'message', T: () => RandomForestInfo },
      { no: 11, name: 'variant_info', kind: 'message', T: () => VariantInfo },
      { no: 12, name: 'quality_info', kind: 'message', T: () => QualityInfo },
      { no: 13, name: 'age_info', kind: 'message', T: () => AgeInfo },
      { no: 14, name: 'depth_info', kind: 'message', T: () => DepthInfo }
    ])
  }
  create(value?: PartialMessage<Record>): Record {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.chrom = ''
    message.pos = 0
    message.refAllele = ''
    message.altAllele = ''
    message.filters = []
    message.vep = []
    message.alleleCounts = []
    message.nonpar = false
    if (value !== undefined) reflectionMergePartial<Record>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Record
  ): Record {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string chrom */ 1:
          message.chrom = reader.string()
          break
        case /* int32 pos */ 2:
          message.pos = reader.int32()
          break
        case /* string ref_allele */ 3:
          message.refAllele = reader.string()
          break
        case /* string alt_allele */ 4:
          message.altAllele = reader.string()
          break
        case /* repeated annonars.gnomad.gnomad2.Filter filters */ 5:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.filters.push(reader.int32())
          else message.filters.push(reader.int32())
          break
        case /* repeated annonars.gnomad.vep_gnomad2.Vep vep */ 6:
          message.vep.push(Vep.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.gnomad.gnomad2.CohortAlleleCounts allele_counts */ 7:
          message.alleleCounts.push(
            CohortAlleleCounts.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* bool nonpar */ 8:
          message.nonpar = reader.bool()
          break
        case /* optional annonars.gnomad.gnomad2.LiftoverInfo liftover_info */ 9:
          message.liftoverInfo = LiftoverInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.liftoverInfo
          )
          break
        case /* optional annonars.gnomad.gnomad2.RandomForestInfo rf_info */ 10:
          message.rfInfo = RandomForestInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.rfInfo
          )
          break
        case /* optional annonars.gnomad.gnomad2.VariantInfo variant_info */ 11:
          message.variantInfo = VariantInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.variantInfo
          )
          break
        case /* optional annonars.gnomad.gnomad2.QualityInfo quality_info */ 12:
          message.qualityInfo = QualityInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.qualityInfo
          )
          break
        case /* optional annonars.gnomad.gnomad2.AgeInfo age_info */ 13:
          message.ageInfo = AgeInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.ageInfo
          )
          break
        case /* optional annonars.gnomad.gnomad2.DepthInfo depth_info */ 14:
          message.depthInfo = DepthInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.depthInfo
          )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Record,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string chrom = 1; */
    if (message.chrom !== '') writer.tag(1, WireType.LengthDelimited).string(message.chrom)
    /* int32 pos = 2; */
    if (message.pos !== 0) writer.tag(2, WireType.Varint).int32(message.pos)
    /* string ref_allele = 3; */
    if (message.refAllele !== '') writer.tag(3, WireType.LengthDelimited).string(message.refAllele)
    /* string alt_allele = 4; */
    if (message.altAllele !== '') writer.tag(4, WireType.LengthDelimited).string(message.altAllele)
    /* repeated annonars.gnomad.gnomad2.Filter filters = 5; */
    if (message.filters.length) {
      writer.tag(5, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.filters.length; i++) writer.int32(message.filters[i])
      writer.join()
    }
    /* repeated annonars.gnomad.vep_gnomad2.Vep vep = 6; */
    for (let i = 0; i < message.vep.length; i++)
      Vep.internalBinaryWrite(
        message.vep[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.gnomad.gnomad2.CohortAlleleCounts allele_counts = 7; */
    for (let i = 0; i < message.alleleCounts.length; i++)
      CohortAlleleCounts.internalBinaryWrite(
        message.alleleCounts[i],
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* bool nonpar = 8; */
    if (message.nonpar !== false) writer.tag(8, WireType.Varint).bool(message.nonpar)
    /* optional annonars.gnomad.gnomad2.LiftoverInfo liftover_info = 9; */
    if (message.liftoverInfo)
      LiftoverInfo.internalBinaryWrite(
        message.liftoverInfo,
        writer.tag(9, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.gnomad.gnomad2.RandomForestInfo rf_info = 10; */
    if (message.rfInfo)
      RandomForestInfo.internalBinaryWrite(
        message.rfInfo,
        writer.tag(10, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.gnomad.gnomad2.VariantInfo variant_info = 11; */
    if (message.variantInfo)
      VariantInfo.internalBinaryWrite(
        message.variantInfo,
        writer.tag(11, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.gnomad.gnomad2.QualityInfo quality_info = 12; */
    if (message.qualityInfo)
      QualityInfo.internalBinaryWrite(
        message.qualityInfo,
        writer.tag(12, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.gnomad.gnomad2.AgeInfo age_info = 13; */
    if (message.ageInfo)
      AgeInfo.internalBinaryWrite(
        message.ageInfo,
        writer.tag(13, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.gnomad.gnomad2.DepthInfo depth_info = 14; */
    if (message.depthInfo)
      DepthInfo.internalBinaryWrite(
        message.depthInfo,
        writer.tag(14, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad2.Record
 */
export const Record = new Record$Type()
