// @generated by protobuf-ts 2.9.3 with parameter keep_enum_prefix,long_type_string
// @generated from protobuf file "annonars/gnomad/gnomad3.proto" (package "annonars.gnomad.gnomad3", syntax proto3)
// tslint:disable
//
// Protobufs for gnomAD v3.
//
// In the case of smaller additions in **both exomes and genomes** in v4.0,
// we extended the protobufs here and re-used them.
//
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'

import { Vep } from './vep_gnomad3'

/**
 * Store details on variant effect predictions.
 *
 * @generated from protobuf message annonars.gnomad.gnomad3.EffectInfo
 */
export interface EffectInfo {
  /**
   * PrimateAI's deleteriousness score from 0 (less deleterious) to 1 (more deleterious).
   *
   * @generated from protobuf field: optional float primate_ai_score = 1;
   */
  primateAiScore?: number
  /**
   * dbNSFP's Revel score from 0 to 1. Variants with higher scores are predicted to be
   * more likely to be deleterious.
   *
   * @generated from protobuf field: optional float revel_score = 2;
   */
  revelScore?: number
  /**
   * Illumina's SpliceAI max delta score; interpreted as the probability of the variant
   * being splice-altering.
   *
   * @generated from protobuf field: optional float splice_ai_max_ds = 3;
   */
  spliceAiMaxDs?: number
  /**
   * The consequence term associated with the max delta score in 'splice_ai_max_ds'.
   *
   * @generated from protobuf field: optional string splice_ai_consequence = 4;
   */
  spliceAiConsequence?: string
  /**
   * Raw CADD scores are interpretable as the extent to which the annotation profile for a given variant suggests that the variant is likely to be 'observed' (negative values) vs 'simulated' (positive values). Larger values are more deleterious.
   *
   * @generated from protobuf field: optional float cadd_raw = 5;
   */
  caddRaw?: number
  /**
   * Cadd Phred-like scores ('scaled C-scores') ranging from 1 to 99, based on the rank of each variant relative to all possible 8.6 billion substitutions in the human reference genome. Larger values are more deleterious.
   *
   * @generated from protobuf field: optional float cadd_phred = 6;
   */
  caddPhred?: number
}
/**
 * Store the relevant allele counts and frequencies in a given sub cohort.
 *
 * @generated from protobuf message annonars.gnomad.gnomad3.AlleleCounts
 */
export interface AlleleCounts {
  /**
   * Number of alternate alleles in sub cohort.
   *
   * @generated from protobuf field: int32 ac = 1;
   */
  ac: number
  /**
   * Total number of alleles in the sub cohort.
   *
   * @generated from protobuf field: int32 an = 2;
   */
  an: number
  /**
   * Number of homozygous alternate alleles in the sub cohort.
   *
   * @generated from protobuf field: int32 nhomalt = 3;
   */
  nhomalt: number
  /**
   * Alternate allele frequency in the sub cohort.
   *
   * @generated from protobuf field: float af = 4;
   */
  af: number
}
/**
 * Store the allele counts for the given sub cohort and sub cohort factored by sex.
 *
 * @generated from protobuf message annonars.gnomad.gnomad3.AlleleCountsBySex
 */
export interface AlleleCountsBySex {
  /**
   * Overall allele counts in the sub cohort.
   *
   * @generated from protobuf field: annonars.gnomad.gnomad3.AlleleCounts overall = 1;
   */
  overall?: AlleleCounts
  /**
   * Allele counts in female/XX karyotype individuals of sub cohort.
   *
   * @generated from protobuf field: optional annonars.gnomad.gnomad3.AlleleCounts xx = 2;
   */
  xx?: AlleleCounts
  /**
   * Allele counts in male/XY karyotype individuals of sub cohort.
   *
   * @generated from protobuf field: optional annonars.gnomad.gnomad3.AlleleCounts xy = 3;
   */
  xy?: AlleleCounts
}
/**
 * Store the allele counts for the given sub cohort in the given population.
 *
 * @generated from protobuf message annonars.gnomad.gnomad3.PopulationAlleleCounts
 */
export interface PopulationAlleleCounts {
  /**
   * Name of the population.
   *
   * @generated from protobuf field: string population = 1;
   */
  population: string
  /**
   * The overall allele counts and the one by sex.
   *
   * @generated from protobuf field: annonars.gnomad.gnomad3.AlleleCountsBySex counts = 2;
   */
  counts?: AlleleCountsBySex
  /**
   * The filtering allele frequency (using Poisson 95% CI).
   *
   * @generated from protobuf field: optional float faf95 = 3;
   */
  faf95?: number
  /**
   * The filtering allele frequency (using Poisson 99% CI).
   *
   * @generated from protobuf field: optional float faf99 = 4;
   */
  faf99?: number
  /**
   * The filtering allele frequency for XX samples (using Poisson 95% CI).
   *
   * @generated from protobuf field: optional float faf95_xx = 5;
   */
  faf95Xx?: number
  /**
   * The filtering allele frequency for XX samples (using Poisson 99% CI).
   *
   * @generated from protobuf field: optional float faf99_xx = 6;
   */
  faf99Xx?: number
  /**
   * The filtering allele frequency for XY samples (using Poisson 95% CI).
   *
   * @generated from protobuf field: optional float faf95_xy = 7;
   */
  faf95Xy?: number
  /**
   * The filtering allele frequency for XY samples (using Poisson 99% CI).
   *
   * @generated from protobuf field: optional float faf99_xy = 8;
   */
  faf99Xy?: number
}
/**
 * Store the allele counts for the given cohort.
 *
 * @generated from protobuf message annonars.gnomad.gnomad3.CohortAlleleCounts
 */
export interface CohortAlleleCounts {
  /**
   * Name of the cohort.
   *
   * @generated from protobuf field: optional string cohort = 1;
   */
  cohort?: string
  /**
   * Allele counts for each population.
   *
   * @generated from protobuf field: repeated annonars.gnomad.gnomad3.PopulationAlleleCounts by_population = 2;
   */
  byPopulation: PopulationAlleleCounts[]
  /**
   * Allele counts by sex.
   *
   * @generated from protobuf field: annonars.gnomad.gnomad3.AlleleCountsBySex by_sex = 3;
   */
  bySex?: AlleleCountsBySex
  /**
   * Raw allele counts.
   *
   * @generated from protobuf field: annonars.gnomad.gnomad3.AlleleCounts raw = 4;
   */
  raw?: AlleleCounts
  /**
   * The population with maximum AF.
   *
   * @generated from protobuf field: optional string popmax = 5;
   */
  popmax?: string
  /**
   * Maximum allele frequency across populations (excluding samples of Ashkenazi, Finnish, and
   * indeterminate ancestry).
   *
   * @generated from protobuf field: optional float af_popmax = 6;
   */
  afPopmax?: number
  /**
   * Allele count in population with maximum AF.
   *
   * @generated from protobuf field: optional int32 ac_popmax = 7;
   */
  acPopmax?: number
  /**
   * Total number of alleles in population with maximum AF.
   *
   * @generated from protobuf field: optional int32 an_popmax = 8;
   */
  anPopmax?: number
  /**
   * Total number of homozygous individuals in population with maximum AF.
   *
   * @generated from protobuf field: optional int32 nhomalt_popmax = 9;
   */
  nhomaltPopmax?: number
}
/**
 * Encapsulate VCF INFO fields related to age.
 *
 * @generated from protobuf message annonars.gnomad.gnomad3.AgeInfo
 */
export interface AgeInfo {
  /**
   * Histogram of ages of individuals with a homoplasmic variant; bin edges are: [30.0, 35.0,
   * 40.0, 45.0, 50.0, 55.0, 60.0, 65.0, 70.0, 75.0, 80.0].
   *
   * @generated from protobuf field: repeated int32 age_hist_hom_bin_freq = 1;
   */
  ageHistHomBinFreq: number[]
  /**
   * Count of age values falling below lowest histogram bin edge for individuals with a
   * homoplasmic variant.
   *
   * @generated from protobuf field: optional int32 age_hist_hom_n_smaller = 2;
   */
  ageHistHomNSmaller?: number
  /**
   * Count of age values falling above highest histogram bin edge for individuals with a
   * homoplasmic variant.
   *
   * @generated from protobuf field: optional int32 age_hist_hom_n_larger = 3;
   */
  ageHistHomNLarger?: number
  /**
   * Histogram of ages of individuals with a heteroplasmic variant; bin edges are: [30.0, 35.0,
   * 40.0, 45.0, 50.0, 55.0, 60.0, 65.0, 70.0, 75.0, 80.0]
   *
   * @generated from protobuf field: repeated int32 age_hist_het_bin_freq = 4;
   */
  ageHistHetBinFreq: number[]
  /**
   * Count of age values falling below lowest histogram bin edge for individuals with a
   * heteroplasmic variant.
   *
   * @generated from protobuf field: optional int32 age_hist_het_n_smaller = 5;
   */
  ageHistHetNSmaller?: number
  /**
   * Count of age values falling above highest histogram bin edge for individuals with a
   * heteroplasmic variant.
   *
   * @generated from protobuf field: optional int32 age_hist_het_n_larger = 6;
   */
  ageHistHetNLarger?: number
}
/**
 * Encapsulate VCF INFO fields related to depth.
 *
 * @generated from protobuf message annonars.gnomad.gnomad3.DepthInfo
 */
export interface DepthInfo {
  /**
   * Count of dp values falling above highest histogram bin edge for all individuals.
   *
   * @generated from protobuf field: optional int32 dp_hist_all_n_larger = 1;
   */
  dpHistAllNLarger?: number
  /**
   * Count of dp values falling above highest histogram bin edge for individuals with the
   * alternative allele
   *
   * @generated from protobuf field: optional int32 dp_hist_alt_n_larger = 2;
   */
  dpHistAltNLarger?: number
  /**
   * Histogram of dp values for all individuals; bin edges are: [0.0, 200.0, 400.0, 600.0, 800.0,
   * 1000.0, 1200.0, 1400.0, 1600.0, 1800.0, 2000.0]
   *
   * @generated from protobuf field: repeated int32 dp_hist_all_bin_freq = 3;
   */
  dpHistAllBinFreq: number[]
  /**
   * Histogram of dp values for individuals with the alternative allele; bin edges are: [0.0,
   * 200.0, 400.0, 600.0, 800.0, 1000.0, 1200.0, 1400.0, 1600.0, 1800.0, 2000.0]
   *
   * @generated from protobuf field: repeated int32 dp_hist_alt_bin_freq = 4;
   */
  dpHistAltBinFreq: number[]
}
/**
 * Encapsulate quality-related information.
 *
 * @generated from protobuf message annonars.gnomad.gnomad3.QualityInfo
 */
export interface QualityInfo {
  /**
   * Allele-specific phred-scaled p-value of Fisher's exact test for strand bias.
   *
   * @generated from protobuf field: optional float as_fs = 1;
   */
  asFs?: number
  /**
   * Inbreeding coefficient as estimated from the genotype likelihoods per-sample when compared
   * against the Hardy-Weinberg expectation.
   *
   * @generated from protobuf field: optional float inbreeding_coeff = 2;
   */
  inbreedingCoeff?: number
  /**
   * Allele-specific root mean square of the mapping quality of reads across all samples
   *
   * @generated from protobuf field: optional float as_mq = 3;
   */
  asMq?: number
  /**
   * Z-score from Wilcoxon rank sum test of alternate vs. reference read mapping qualities.
   *
   * @generated from protobuf field: optional float mq_rank_sum = 4;
   */
  mqRankSum?: number
  /**
   * Allele-specific z-score from Wilcoxon rank sum test of alternate vs. reference read
   * mapping qualities.
   *
   * @generated from protobuf field: optional float as_mq_rank_sum = 5;
   */
  asMqRankSum?: number
  /**
   * Allele-specific variant call confidence normalized by depth of sample reads supporting a
   * variant.
   *
   * @generated from protobuf field: optional float as_qd = 6;
   */
  asQd?: number
  /**
   * Z-score from Wilcoxon rank sum test of alternate vs. reference read position bias.
   *
   * @generated from protobuf field: optional float read_pos_rank_sum = 7;
   */
  readPosRankSum?: number
  /**
   * Allele-specific z-score from Wilcoxon rank sum test of alternate vs. reference read position bias.
   *
   * @generated from protobuf field: optional float as_read_pos_rank_sum = 8;
   */
  asReadPosRankSum?: number
  /**
   * Allele-specific strand bias estimated by the symmetric odds ratio test.
   *
   * @generated from protobuf field: optional float as_sor = 9;
   */
  asSor?: number
  /**
   * Variant was used to build the positive training set of high-quality variants for VQSR.
   *
   * @generated from protobuf field: bool positive_train_site = 10;
   */
  positiveTrainSite: boolean
  /**
   * Variant was used to build the negative training set of low-quality variants for VQSR.
   *
   * @generated from protobuf field: bool negative_train_site = 11;
   */
  negativeTrainSite: boolean
  /**
   * Allele-specific log-odds ratio of being a true variant versus being a false positive under the trained VQSR Gaussian mixture model.
   *
   * @generated from protobuf field: optional float as_vqslod = 12;
   */
  asVqslod?: number
  /**
   * Allele-specific worst-performing annotation in the VQSR Gaussian mixture model.
   *
   * @generated from protobuf field: optional string as_culprit = 13;
   */
  asCulprit?: string
  /**
   * Variant falls within a segmental duplication region.
   *
   * @generated from protobuf field: bool segdup = 14;
   */
  segdup: boolean
  /**
   * Variant falls within a low complexity region.
   *
   * @generated from protobuf field: bool lcr = 15;
   */
  lcr: boolean
  /**
   * Variant was a callset-wide doubleton that was transmitted within a family (i.e., a singleton
   * amongst unrelated sampes in cohort).
   *
   * @generated from protobuf field: bool transmitted_singleton = 16;
   */
  transmittedSingleton: boolean
  /**
   * Maximum p-value over callset for binomial test of observed allele balance for a heterozygous genotype, given expectation of 0.5.
   *
   * @generated from protobuf field: optional float as_pab_max = 17;
   */
  asPabMax?: number
  /**
   * Allele-specific sum of PL[0] values; used to approximate the QUAL score.
   *
   * @generated from protobuf field: optional int32 as_qual_approx = 18;
   */
  asQualApprox?: number
  /**
   * Allele-specific forward/reverse read counts for strand bias tests.
   *
   * @generated from protobuf field: optional string as_sb_table = 19;
   */
  asSbTable?: string
  /**
   * Strand bias estimated by the symmetric odds ratio test (v4 only).
   *
   * @generated from protobuf field: optional float sor = 20;
   */
  sor?: number
}
/**
 * Variant type related information.
 *
 * @generated from protobuf message annonars.gnomad.gnomad3.VariantInfo
 */
export interface VariantInfo {
  /**
   * Variant type (snv, indel, multi-snv, multi-indel, or mixed).
   *
   * @generated from protobuf field: string variant_type = 1;
   */
  variantType: string
  /**
   * Allele type (snv, ins, del, or mixed).
   *
   * @generated from protobuf field: string allele_type = 2;
   */
  alleleType: string
  /**
   * Total number of alternate alleles observed at variant locus.
   *
   * @generated from protobuf field: int32 n_alt_alleles = 3;
   */
  nAltAlleles: number
  /**
   * Variant type was mixed.
   *
   * @generated from protobuf field: bool was_mixed = 4;
   */
  wasMixed: boolean
  /**
   * All samples are homozygous alternate for the variant.
   *
   * @generated from protobuf field: bool monoallelic = 5;
   */
  monoallelic: boolean
  /**
   * Depth over variant genotypes (does not include depth of reference samples).
   *
   * @generated from protobuf field: int32 var_dp = 6;
   */
  varDp: number
  /**
   * Allele-specific depth over variant genotypes (does not include depth of reference samples) (v4 only).
   *
   * @generated from protobuf field: optional int32 as_vardp = 7;
   */
  asVardp?: number
}
/**
 * Protocol buffer for the gnomAD-nuclear VCF record.
 *
 * The more specialized fields from the INFO column are stored in separate, optional fields such
 * that we don't end up with a humongous message.
 *
 * @generated from protobuf message annonars.gnomad.gnomad3.Record
 */
export interface Record {
  /**
   * Chromosome name.
   *
   * @generated from protobuf field: string chrom = 1;
   */
  chrom: string
  /**
   * 1-based start position.
   *
   * @generated from protobuf field: int32 pos = 2;
   */
  pos: number
  /**
   * Reference allele.
   *
   * @generated from protobuf field: string ref_allele = 3;
   */
  refAllele: string
  /**
   * Alternate allele.
   *
   * @generated from protobuf field: string alt_allele = 4;
   */
  altAllele: string
  /**
   * Site-level filters.
   *
   * @generated from protobuf field: repeated annonars.gnomad.gnomad3.Filter filters = 5;
   */
  filters: Filter[]
  /**
   * VEP annotation records.
   *
   * @generated from protobuf field: repeated annonars.gnomad.vep_gnomad3.Vep vep = 6;
   */
  vep: Vep[]
  /**
   * Variant allele counts in the different cohorts and population.
   *
   * The populations in gnomAD v2/3 are: empty for global, "controls", "non_cancer", "non_neuro",
   * and "non_topmed".
   *
   * @generated from protobuf field: repeated annonars.gnomad.gnomad3.CohortAlleleCounts allele_counts = 7;
   */
  alleleCounts: CohortAlleleCounts[]
  /**
   * Variant (on sex chromosome) falls outside a pseudoautosomal region
   *
   * @generated from protobuf field: bool nonpar = 8;
   */
  nonpar: boolean
  /**
   * Information on variant scores.
   *
   * @generated from protobuf field: optional annonars.gnomad.gnomad3.EffectInfo effect_info = 9;
   */
  effectInfo?: EffectInfo
  /**
   * Variant-related information details.
   *
   * @generated from protobuf field: optional annonars.gnomad.gnomad3.VariantInfo variant_info = 10;
   */
  variantInfo?: VariantInfo
  /**
   * Summary information for variant quality interpretation.
   *
   * @generated from protobuf field: optional annonars.gnomad.gnomad3.QualityInfo quality_info = 11;
   */
  qualityInfo?: QualityInfo
  /**
   * Age-related information.
   *
   * @generated from protobuf field: optional annonars.gnomad.gnomad3.AgeInfo age_info = 12;
   */
  ageInfo?: AgeInfo
  /**
   * Depth of coverage-related information.
   *
   * @generated from protobuf field: optional annonars.gnomad.gnomad3.DepthInfo depth_info = 13;
   */
  depthInfo?: DepthInfo
}
/**
 * Protocol buffer enum for site-level filters.
 *
 * @generated from protobuf enum annonars.gnomad.gnomad3.Filter
 */
export enum Filter {
  /**
   * unknown
   *
   * @generated from protobuf enum value: FILTER_UNKNOWN = 0;
   */
  FILTER_UNKNOWN = 0,
  /**
   * Allele count is zero after filtering out low-confidence genotypes (GQ < 20; DP < 10; and AB <
   * 0.2 for het calls).
   *
   * @generated from protobuf enum value: FILTER_ALLELE_COUNT_IS_ZERO = 1;
   */
  FILTER_ALLELE_COUNT_IS_ZERO = 1,
  /**
   * Failed VQSR filtering thresholds of:
   *
   * gnomAD-genomes v3: -2.7739 for SNPs and -1.0606 for indels
   * gnomAD-genomes v4: -2.502 for SNPs and -0.7156 for indels
   * gnomAD-exomes v4: -1.4526 for SNPs and 0.0717 for indels
   *
   * @generated from protobuf enum value: FILTER_AS_VSQR = 2;
   */
  FILTER_AS_VSQR = 2,
  /**
   * InbreedingCoeff < -0.3.
   *
   * @generated from protobuf enum value: FILTER_INBREEDING_COEFF = 3;
   */
  FILTER_INBREEDING_COEFF = 3,
  /**
   * Passed all variant filters
   *
   * @generated from protobuf enum value: FILTER_PASS = 4;
   */
  FILTER_PASS = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class EffectInfo$Type extends MessageType<EffectInfo> {
  constructor() {
    super('annonars.gnomad.gnomad3.EffectInfo', [
      { no: 1, name: 'primate_ai_score', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 2, name: 'revel_score', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 3, name: 'splice_ai_max_ds', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      {
        no: 4,
        name: 'splice_ai_consequence',
        kind: 'scalar',
        opt: true,
        T: 9 /*ScalarType.STRING*/
      },
      { no: 5, name: 'cadd_raw', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 6, name: 'cadd_phred', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ }
    ])
  }
  create(value?: PartialMessage<EffectInfo>): EffectInfo {
    const message = globalThis.Object.create(this.messagePrototype!)
    if (value !== undefined) reflectionMergePartial<EffectInfo>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: EffectInfo
  ): EffectInfo {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional float primate_ai_score */ 1:
          message.primateAiScore = reader.float()
          break
        case /* optional float revel_score */ 2:
          message.revelScore = reader.float()
          break
        case /* optional float splice_ai_max_ds */ 3:
          message.spliceAiMaxDs = reader.float()
          break
        case /* optional string splice_ai_consequence */ 4:
          message.spliceAiConsequence = reader.string()
          break
        case /* optional float cadd_raw */ 5:
          message.caddRaw = reader.float()
          break
        case /* optional float cadd_phred */ 6:
          message.caddPhred = reader.float()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: EffectInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional float primate_ai_score = 1; */
    if (message.primateAiScore !== undefined)
      writer.tag(1, WireType.Bit32).float(message.primateAiScore)
    /* optional float revel_score = 2; */
    if (message.revelScore !== undefined) writer.tag(2, WireType.Bit32).float(message.revelScore)
    /* optional float splice_ai_max_ds = 3; */
    if (message.spliceAiMaxDs !== undefined)
      writer.tag(3, WireType.Bit32).float(message.spliceAiMaxDs)
    /* optional string splice_ai_consequence = 4; */
    if (message.spliceAiConsequence !== undefined)
      writer.tag(4, WireType.LengthDelimited).string(message.spliceAiConsequence)
    /* optional float cadd_raw = 5; */
    if (message.caddRaw !== undefined) writer.tag(5, WireType.Bit32).float(message.caddRaw)
    /* optional float cadd_phred = 6; */
    if (message.caddPhred !== undefined) writer.tag(6, WireType.Bit32).float(message.caddPhred)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad3.EffectInfo
 */
export const EffectInfo = new EffectInfo$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AlleleCounts$Type extends MessageType<AlleleCounts> {
  constructor() {
    super('annonars.gnomad.gnomad3.AlleleCounts', [
      { no: 1, name: 'ac', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 2, name: 'an', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 3, name: 'nhomalt', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 4, name: 'af', kind: 'scalar', T: 2 /*ScalarType.FLOAT*/ }
    ])
  }
  create(value?: PartialMessage<AlleleCounts>): AlleleCounts {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.ac = 0
    message.an = 0
    message.nhomalt = 0
    message.af = 0
    if (value !== undefined) reflectionMergePartial<AlleleCounts>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AlleleCounts
  ): AlleleCounts {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* int32 ac */ 1:
          message.ac = reader.int32()
          break
        case /* int32 an */ 2:
          message.an = reader.int32()
          break
        case /* int32 nhomalt */ 3:
          message.nhomalt = reader.int32()
          break
        case /* float af */ 4:
          message.af = reader.float()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: AlleleCounts,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* int32 ac = 1; */
    if (message.ac !== 0) writer.tag(1, WireType.Varint).int32(message.ac)
    /* int32 an = 2; */
    if (message.an !== 0) writer.tag(2, WireType.Varint).int32(message.an)
    /* int32 nhomalt = 3; */
    if (message.nhomalt !== 0) writer.tag(3, WireType.Varint).int32(message.nhomalt)
    /* float af = 4; */
    if (message.af !== 0) writer.tag(4, WireType.Bit32).float(message.af)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad3.AlleleCounts
 */
export const AlleleCounts = new AlleleCounts$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AlleleCountsBySex$Type extends MessageType<AlleleCountsBySex> {
  constructor() {
    super('annonars.gnomad.gnomad3.AlleleCountsBySex', [
      { no: 1, name: 'overall', kind: 'message', T: () => AlleleCounts },
      { no: 2, name: 'xx', kind: 'message', T: () => AlleleCounts },
      { no: 3, name: 'xy', kind: 'message', T: () => AlleleCounts }
    ])
  }
  create(value?: PartialMessage<AlleleCountsBySex>): AlleleCountsBySex {
    const message = globalThis.Object.create(this.messagePrototype!)
    if (value !== undefined) reflectionMergePartial<AlleleCountsBySex>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AlleleCountsBySex
  ): AlleleCountsBySex {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* annonars.gnomad.gnomad3.AlleleCounts overall */ 1:
          message.overall = AlleleCounts.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.overall
          )
          break
        case /* optional annonars.gnomad.gnomad3.AlleleCounts xx */ 2:
          message.xx = AlleleCounts.internalBinaryRead(reader, reader.uint32(), options, message.xx)
          break
        case /* optional annonars.gnomad.gnomad3.AlleleCounts xy */ 3:
          message.xy = AlleleCounts.internalBinaryRead(reader, reader.uint32(), options, message.xy)
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: AlleleCountsBySex,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* annonars.gnomad.gnomad3.AlleleCounts overall = 1; */
    if (message.overall)
      AlleleCounts.internalBinaryWrite(
        message.overall,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.gnomad.gnomad3.AlleleCounts xx = 2; */
    if (message.xx)
      AlleleCounts.internalBinaryWrite(
        message.xx,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.gnomad.gnomad3.AlleleCounts xy = 3; */
    if (message.xy)
      AlleleCounts.internalBinaryWrite(
        message.xy,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad3.AlleleCountsBySex
 */
export const AlleleCountsBySex = new AlleleCountsBySex$Type()
// @generated message type with reflection information, may provide speed optimized methods
class PopulationAlleleCounts$Type extends MessageType<PopulationAlleleCounts> {
  constructor() {
    super('annonars.gnomad.gnomad3.PopulationAlleleCounts', [
      { no: 1, name: 'population', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'counts', kind: 'message', T: () => AlleleCountsBySex },
      { no: 3, name: 'faf95', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 4, name: 'faf99', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 5, name: 'faf95_xx', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 6, name: 'faf99_xx', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 7, name: 'faf95_xy', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 8, name: 'faf99_xy', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ }
    ])
  }
  create(value?: PartialMessage<PopulationAlleleCounts>): PopulationAlleleCounts {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.population = ''
    if (value !== undefined) reflectionMergePartial<PopulationAlleleCounts>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PopulationAlleleCounts
  ): PopulationAlleleCounts {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string population */ 1:
          message.population = reader.string()
          break
        case /* annonars.gnomad.gnomad3.AlleleCountsBySex counts */ 2:
          message.counts = AlleleCountsBySex.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.counts
          )
          break
        case /* optional float faf95 */ 3:
          message.faf95 = reader.float()
          break
        case /* optional float faf99 */ 4:
          message.faf99 = reader.float()
          break
        case /* optional float faf95_xx */ 5:
          message.faf95Xx = reader.float()
          break
        case /* optional float faf99_xx */ 6:
          message.faf99Xx = reader.float()
          break
        case /* optional float faf95_xy */ 7:
          message.faf95Xy = reader.float()
          break
        case /* optional float faf99_xy */ 8:
          message.faf99Xy = reader.float()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: PopulationAlleleCounts,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string population = 1; */
    if (message.population !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.population)
    /* annonars.gnomad.gnomad3.AlleleCountsBySex counts = 2; */
    if (message.counts)
      AlleleCountsBySex.internalBinaryWrite(
        message.counts,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional float faf95 = 3; */
    if (message.faf95 !== undefined) writer.tag(3, WireType.Bit32).float(message.faf95)
    /* optional float faf99 = 4; */
    if (message.faf99 !== undefined) writer.tag(4, WireType.Bit32).float(message.faf99)
    /* optional float faf95_xx = 5; */
    if (message.faf95Xx !== undefined) writer.tag(5, WireType.Bit32).float(message.faf95Xx)
    /* optional float faf99_xx = 6; */
    if (message.faf99Xx !== undefined) writer.tag(6, WireType.Bit32).float(message.faf99Xx)
    /* optional float faf95_xy = 7; */
    if (message.faf95Xy !== undefined) writer.tag(7, WireType.Bit32).float(message.faf95Xy)
    /* optional float faf99_xy = 8; */
    if (message.faf99Xy !== undefined) writer.tag(8, WireType.Bit32).float(message.faf99Xy)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad3.PopulationAlleleCounts
 */
export const PopulationAlleleCounts = new PopulationAlleleCounts$Type()
// @generated message type with reflection information, may provide speed optimized methods
class CohortAlleleCounts$Type extends MessageType<CohortAlleleCounts> {
  constructor() {
    super('annonars.gnomad.gnomad3.CohortAlleleCounts', [
      { no: 1, name: 'cohort', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      {
        no: 2,
        name: 'by_population',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => PopulationAlleleCounts
      },
      { no: 3, name: 'by_sex', kind: 'message', T: () => AlleleCountsBySex },
      { no: 4, name: 'raw', kind: 'message', T: () => AlleleCounts },
      { no: 5, name: 'popmax', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 6, name: 'af_popmax', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 7, name: 'ac_popmax', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      { no: 8, name: 'an_popmax', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      { no: 9, name: 'nhomalt_popmax', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ }
    ])
  }
  create(value?: PartialMessage<CohortAlleleCounts>): CohortAlleleCounts {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.byPopulation = []
    if (value !== undefined) reflectionMergePartial<CohortAlleleCounts>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CohortAlleleCounts
  ): CohortAlleleCounts {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional string cohort */ 1:
          message.cohort = reader.string()
          break
        case /* repeated annonars.gnomad.gnomad3.PopulationAlleleCounts by_population */ 2:
          message.byPopulation.push(
            PopulationAlleleCounts.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* annonars.gnomad.gnomad3.AlleleCountsBySex by_sex */ 3:
          message.bySex = AlleleCountsBySex.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.bySex
          )
          break
        case /* annonars.gnomad.gnomad3.AlleleCounts raw */ 4:
          message.raw = AlleleCounts.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.raw
          )
          break
        case /* optional string popmax */ 5:
          message.popmax = reader.string()
          break
        case /* optional float af_popmax */ 6:
          message.afPopmax = reader.float()
          break
        case /* optional int32 ac_popmax */ 7:
          message.acPopmax = reader.int32()
          break
        case /* optional int32 an_popmax */ 8:
          message.anPopmax = reader.int32()
          break
        case /* optional int32 nhomalt_popmax */ 9:
          message.nhomaltPopmax = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: CohortAlleleCounts,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional string cohort = 1; */
    if (message.cohort !== undefined) writer.tag(1, WireType.LengthDelimited).string(message.cohort)
    /* repeated annonars.gnomad.gnomad3.PopulationAlleleCounts by_population = 2; */
    for (let i = 0; i < message.byPopulation.length; i++)
      PopulationAlleleCounts.internalBinaryWrite(
        message.byPopulation[i],
        writer.tag(2, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.gnomad.gnomad3.AlleleCountsBySex by_sex = 3; */
    if (message.bySex)
      AlleleCountsBySex.internalBinaryWrite(
        message.bySex,
        writer.tag(3, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* annonars.gnomad.gnomad3.AlleleCounts raw = 4; */
    if (message.raw)
      AlleleCounts.internalBinaryWrite(
        message.raw,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional string popmax = 5; */
    if (message.popmax !== undefined) writer.tag(5, WireType.LengthDelimited).string(message.popmax)
    /* optional float af_popmax = 6; */
    if (message.afPopmax !== undefined) writer.tag(6, WireType.Bit32).float(message.afPopmax)
    /* optional int32 ac_popmax = 7; */
    if (message.acPopmax !== undefined) writer.tag(7, WireType.Varint).int32(message.acPopmax)
    /* optional int32 an_popmax = 8; */
    if (message.anPopmax !== undefined) writer.tag(8, WireType.Varint).int32(message.anPopmax)
    /* optional int32 nhomalt_popmax = 9; */
    if (message.nhomaltPopmax !== undefined)
      writer.tag(9, WireType.Varint).int32(message.nhomaltPopmax)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad3.CohortAlleleCounts
 */
export const CohortAlleleCounts = new CohortAlleleCounts$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AgeInfo$Type extends MessageType<AgeInfo> {
  constructor() {
    super('annonars.gnomad.gnomad3.AgeInfo', [
      {
        no: 1,
        name: 'age_hist_hom_bin_freq',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 2,
        name: 'age_hist_hom_n_smaller',
        kind: 'scalar',
        opt: true,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 3,
        name: 'age_hist_hom_n_larger',
        kind: 'scalar',
        opt: true,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: 'age_hist_het_bin_freq',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 5,
        name: 'age_hist_het_n_smaller',
        kind: 'scalar',
        opt: true,
        T: 5 /*ScalarType.INT32*/
      },
      { no: 6, name: 'age_hist_het_n_larger', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ }
    ])
  }
  create(value?: PartialMessage<AgeInfo>): AgeInfo {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.ageHistHomBinFreq = []
    message.ageHistHetBinFreq = []
    if (value !== undefined) reflectionMergePartial<AgeInfo>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AgeInfo
  ): AgeInfo {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated int32 age_hist_hom_bin_freq */ 1:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.ageHistHomBinFreq.push(reader.int32())
          else message.ageHistHomBinFreq.push(reader.int32())
          break
        case /* optional int32 age_hist_hom_n_smaller */ 2:
          message.ageHistHomNSmaller = reader.int32()
          break
        case /* optional int32 age_hist_hom_n_larger */ 3:
          message.ageHistHomNLarger = reader.int32()
          break
        case /* repeated int32 age_hist_het_bin_freq */ 4:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.ageHistHetBinFreq.push(reader.int32())
          else message.ageHistHetBinFreq.push(reader.int32())
          break
        case /* optional int32 age_hist_het_n_smaller */ 5:
          message.ageHistHetNSmaller = reader.int32()
          break
        case /* optional int32 age_hist_het_n_larger */ 6:
          message.ageHistHetNLarger = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: AgeInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated int32 age_hist_hom_bin_freq = 1; */
    if (message.ageHistHomBinFreq.length) {
      writer.tag(1, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.ageHistHomBinFreq.length; i++)
        writer.int32(message.ageHistHomBinFreq[i])
      writer.join()
    }
    /* optional int32 age_hist_hom_n_smaller = 2; */
    if (message.ageHistHomNSmaller !== undefined)
      writer.tag(2, WireType.Varint).int32(message.ageHistHomNSmaller)
    /* optional int32 age_hist_hom_n_larger = 3; */
    if (message.ageHistHomNLarger !== undefined)
      writer.tag(3, WireType.Varint).int32(message.ageHistHomNLarger)
    /* repeated int32 age_hist_het_bin_freq = 4; */
    if (message.ageHistHetBinFreq.length) {
      writer.tag(4, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.ageHistHetBinFreq.length; i++)
        writer.int32(message.ageHistHetBinFreq[i])
      writer.join()
    }
    /* optional int32 age_hist_het_n_smaller = 5; */
    if (message.ageHistHetNSmaller !== undefined)
      writer.tag(5, WireType.Varint).int32(message.ageHistHetNSmaller)
    /* optional int32 age_hist_het_n_larger = 6; */
    if (message.ageHistHetNLarger !== undefined)
      writer.tag(6, WireType.Varint).int32(message.ageHistHetNLarger)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad3.AgeInfo
 */
export const AgeInfo = new AgeInfo$Type()
// @generated message type with reflection information, may provide speed optimized methods
class DepthInfo$Type extends MessageType<DepthInfo> {
  constructor() {
    super('annonars.gnomad.gnomad3.DepthInfo', [
      { no: 1, name: 'dp_hist_all_n_larger', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      { no: 2, name: 'dp_hist_alt_n_larger', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      {
        no: 3,
        name: 'dp_hist_all_bin_freq',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: 'dp_hist_alt_bin_freq',
        kind: 'scalar',
        repeat: 1 /*RepeatType.PACKED*/,
        T: 5 /*ScalarType.INT32*/
      }
    ])
  }
  create(value?: PartialMessage<DepthInfo>): DepthInfo {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.dpHistAllBinFreq = []
    message.dpHistAltBinFreq = []
    if (value !== undefined) reflectionMergePartial<DepthInfo>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: DepthInfo
  ): DepthInfo {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional int32 dp_hist_all_n_larger */ 1:
          message.dpHistAllNLarger = reader.int32()
          break
        case /* optional int32 dp_hist_alt_n_larger */ 2:
          message.dpHistAltNLarger = reader.int32()
          break
        case /* repeated int32 dp_hist_all_bin_freq */ 3:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.dpHistAllBinFreq.push(reader.int32())
          else message.dpHistAllBinFreq.push(reader.int32())
          break
        case /* repeated int32 dp_hist_alt_bin_freq */ 4:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.dpHistAltBinFreq.push(reader.int32())
          else message.dpHistAltBinFreq.push(reader.int32())
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: DepthInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional int32 dp_hist_all_n_larger = 1; */
    if (message.dpHistAllNLarger !== undefined)
      writer.tag(1, WireType.Varint).int32(message.dpHistAllNLarger)
    /* optional int32 dp_hist_alt_n_larger = 2; */
    if (message.dpHistAltNLarger !== undefined)
      writer.tag(2, WireType.Varint).int32(message.dpHistAltNLarger)
    /* repeated int32 dp_hist_all_bin_freq = 3; */
    if (message.dpHistAllBinFreq.length) {
      writer.tag(3, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.dpHistAllBinFreq.length; i++)
        writer.int32(message.dpHistAllBinFreq[i])
      writer.join()
    }
    /* repeated int32 dp_hist_alt_bin_freq = 4; */
    if (message.dpHistAltBinFreq.length) {
      writer.tag(4, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.dpHistAltBinFreq.length; i++)
        writer.int32(message.dpHistAltBinFreq[i])
      writer.join()
    }
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad3.DepthInfo
 */
export const DepthInfo = new DepthInfo$Type()
// @generated message type with reflection information, may provide speed optimized methods
class QualityInfo$Type extends MessageType<QualityInfo> {
  constructor() {
    super('annonars.gnomad.gnomad3.QualityInfo', [
      { no: 1, name: 'as_fs', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 2, name: 'inbreeding_coeff', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 3, name: 'as_mq', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 4, name: 'mq_rank_sum', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 5, name: 'as_mq_rank_sum', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 6, name: 'as_qd', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 7, name: 'read_pos_rank_sum', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 8, name: 'as_read_pos_rank_sum', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 9, name: 'as_sor', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 10, name: 'positive_train_site', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 11, name: 'negative_train_site', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 12, name: 'as_vqslod', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 13, name: 'as_culprit', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 14, name: 'segdup', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 15, name: 'lcr', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 16, name: 'transmitted_singleton', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 17, name: 'as_pab_max', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ },
      { no: 18, name: 'as_qual_approx', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ },
      { no: 19, name: 'as_sb_table', kind: 'scalar', opt: true, T: 9 /*ScalarType.STRING*/ },
      { no: 20, name: 'sor', kind: 'scalar', opt: true, T: 2 /*ScalarType.FLOAT*/ }
    ])
  }
  create(value?: PartialMessage<QualityInfo>): QualityInfo {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.positiveTrainSite = false
    message.negativeTrainSite = false
    message.segdup = false
    message.lcr = false
    message.transmittedSingleton = false
    if (value !== undefined) reflectionMergePartial<QualityInfo>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QualityInfo
  ): QualityInfo {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* optional float as_fs */ 1:
          message.asFs = reader.float()
          break
        case /* optional float inbreeding_coeff */ 2:
          message.inbreedingCoeff = reader.float()
          break
        case /* optional float as_mq */ 3:
          message.asMq = reader.float()
          break
        case /* optional float mq_rank_sum */ 4:
          message.mqRankSum = reader.float()
          break
        case /* optional float as_mq_rank_sum */ 5:
          message.asMqRankSum = reader.float()
          break
        case /* optional float as_qd */ 6:
          message.asQd = reader.float()
          break
        case /* optional float read_pos_rank_sum */ 7:
          message.readPosRankSum = reader.float()
          break
        case /* optional float as_read_pos_rank_sum */ 8:
          message.asReadPosRankSum = reader.float()
          break
        case /* optional float as_sor */ 9:
          message.asSor = reader.float()
          break
        case /* bool positive_train_site */ 10:
          message.positiveTrainSite = reader.bool()
          break
        case /* bool negative_train_site */ 11:
          message.negativeTrainSite = reader.bool()
          break
        case /* optional float as_vqslod */ 12:
          message.asVqslod = reader.float()
          break
        case /* optional string as_culprit */ 13:
          message.asCulprit = reader.string()
          break
        case /* bool segdup */ 14:
          message.segdup = reader.bool()
          break
        case /* bool lcr */ 15:
          message.lcr = reader.bool()
          break
        case /* bool transmitted_singleton */ 16:
          message.transmittedSingleton = reader.bool()
          break
        case /* optional float as_pab_max */ 17:
          message.asPabMax = reader.float()
          break
        case /* optional int32 as_qual_approx */ 18:
          message.asQualApprox = reader.int32()
          break
        case /* optional string as_sb_table */ 19:
          message.asSbTable = reader.string()
          break
        case /* optional float sor */ 20:
          message.sor = reader.float()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QualityInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* optional float as_fs = 1; */
    if (message.asFs !== undefined) writer.tag(1, WireType.Bit32).float(message.asFs)
    /* optional float inbreeding_coeff = 2; */
    if (message.inbreedingCoeff !== undefined)
      writer.tag(2, WireType.Bit32).float(message.inbreedingCoeff)
    /* optional float as_mq = 3; */
    if (message.asMq !== undefined) writer.tag(3, WireType.Bit32).float(message.asMq)
    /* optional float mq_rank_sum = 4; */
    if (message.mqRankSum !== undefined) writer.tag(4, WireType.Bit32).float(message.mqRankSum)
    /* optional float as_mq_rank_sum = 5; */
    if (message.asMqRankSum !== undefined) writer.tag(5, WireType.Bit32).float(message.asMqRankSum)
    /* optional float as_qd = 6; */
    if (message.asQd !== undefined) writer.tag(6, WireType.Bit32).float(message.asQd)
    /* optional float read_pos_rank_sum = 7; */
    if (message.readPosRankSum !== undefined)
      writer.tag(7, WireType.Bit32).float(message.readPosRankSum)
    /* optional float as_read_pos_rank_sum = 8; */
    if (message.asReadPosRankSum !== undefined)
      writer.tag(8, WireType.Bit32).float(message.asReadPosRankSum)
    /* optional float as_sor = 9; */
    if (message.asSor !== undefined) writer.tag(9, WireType.Bit32).float(message.asSor)
    /* bool positive_train_site = 10; */
    if (message.positiveTrainSite !== false)
      writer.tag(10, WireType.Varint).bool(message.positiveTrainSite)
    /* bool negative_train_site = 11; */
    if (message.negativeTrainSite !== false)
      writer.tag(11, WireType.Varint).bool(message.negativeTrainSite)
    /* optional float as_vqslod = 12; */
    if (message.asVqslod !== undefined) writer.tag(12, WireType.Bit32).float(message.asVqslod)
    /* optional string as_culprit = 13; */
    if (message.asCulprit !== undefined)
      writer.tag(13, WireType.LengthDelimited).string(message.asCulprit)
    /* bool segdup = 14; */
    if (message.segdup !== false) writer.tag(14, WireType.Varint).bool(message.segdup)
    /* bool lcr = 15; */
    if (message.lcr !== false) writer.tag(15, WireType.Varint).bool(message.lcr)
    /* bool transmitted_singleton = 16; */
    if (message.transmittedSingleton !== false)
      writer.tag(16, WireType.Varint).bool(message.transmittedSingleton)
    /* optional float as_pab_max = 17; */
    if (message.asPabMax !== undefined) writer.tag(17, WireType.Bit32).float(message.asPabMax)
    /* optional int32 as_qual_approx = 18; */
    if (message.asQualApprox !== undefined)
      writer.tag(18, WireType.Varint).int32(message.asQualApprox)
    /* optional string as_sb_table = 19; */
    if (message.asSbTable !== undefined)
      writer.tag(19, WireType.LengthDelimited).string(message.asSbTable)
    /* optional float sor = 20; */
    if (message.sor !== undefined) writer.tag(20, WireType.Bit32).float(message.sor)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad3.QualityInfo
 */
export const QualityInfo = new QualityInfo$Type()
// @generated message type with reflection information, may provide speed optimized methods
class VariantInfo$Type extends MessageType<VariantInfo> {
  constructor() {
    super('annonars.gnomad.gnomad3.VariantInfo', [
      { no: 1, name: 'variant_type', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'allele_type', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'n_alt_alleles', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 4, name: 'was_mixed', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 5, name: 'monoallelic', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 6, name: 'var_dp', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 7, name: 'as_vardp', kind: 'scalar', opt: true, T: 5 /*ScalarType.INT32*/ }
    ])
  }
  create(value?: PartialMessage<VariantInfo>): VariantInfo {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.variantType = ''
    message.alleleType = ''
    message.nAltAlleles = 0
    message.wasMixed = false
    message.monoallelic = false
    message.varDp = 0
    if (value !== undefined) reflectionMergePartial<VariantInfo>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: VariantInfo
  ): VariantInfo {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string variant_type */ 1:
          message.variantType = reader.string()
          break
        case /* string allele_type */ 2:
          message.alleleType = reader.string()
          break
        case /* int32 n_alt_alleles */ 3:
          message.nAltAlleles = reader.int32()
          break
        case /* bool was_mixed */ 4:
          message.wasMixed = reader.bool()
          break
        case /* bool monoallelic */ 5:
          message.monoallelic = reader.bool()
          break
        case /* int32 var_dp */ 6:
          message.varDp = reader.int32()
          break
        case /* optional int32 as_vardp */ 7:
          message.asVardp = reader.int32()
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: VariantInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string variant_type = 1; */
    if (message.variantType !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.variantType)
    /* string allele_type = 2; */
    if (message.alleleType !== '')
      writer.tag(2, WireType.LengthDelimited).string(message.alleleType)
    /* int32 n_alt_alleles = 3; */
    if (message.nAltAlleles !== 0) writer.tag(3, WireType.Varint).int32(message.nAltAlleles)
    /* bool was_mixed = 4; */
    if (message.wasMixed !== false) writer.tag(4, WireType.Varint).bool(message.wasMixed)
    /* bool monoallelic = 5; */
    if (message.monoallelic !== false) writer.tag(5, WireType.Varint).bool(message.monoallelic)
    /* int32 var_dp = 6; */
    if (message.varDp !== 0) writer.tag(6, WireType.Varint).int32(message.varDp)
    /* optional int32 as_vardp = 7; */
    if (message.asVardp !== undefined) writer.tag(7, WireType.Varint).int32(message.asVardp)
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad3.VariantInfo
 */
export const VariantInfo = new VariantInfo$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Record$Type extends MessageType<Record> {
  constructor() {
    super('annonars.gnomad.gnomad3.Record', [
      { no: 1, name: 'chrom', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'pos', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
      { no: 3, name: 'ref_allele', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: 'alt_allele', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      {
        no: 5,
        name: 'filters',
        kind: 'enum',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => ['annonars.gnomad.gnomad3.Filter', Filter]
      },
      { no: 6, name: 'vep', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Vep },
      {
        no: 7,
        name: 'allele_counts',
        kind: 'message',
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => CohortAlleleCounts
      },
      { no: 8, name: 'nonpar', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
      { no: 9, name: 'effect_info', kind: 'message', T: () => EffectInfo },
      { no: 10, name: 'variant_info', kind: 'message', T: () => VariantInfo },
      { no: 11, name: 'quality_info', kind: 'message', T: () => QualityInfo },
      { no: 12, name: 'age_info', kind: 'message', T: () => AgeInfo },
      { no: 13, name: 'depth_info', kind: 'message', T: () => DepthInfo }
    ])
  }
  create(value?: PartialMessage<Record>): Record {
    const message = globalThis.Object.create(this.messagePrototype!)
    message.chrom = ''
    message.pos = 0
    message.refAllele = ''
    message.altAllele = ''
    message.filters = []
    message.vep = []
    message.alleleCounts = []
    message.nonpar = false
    if (value !== undefined) reflectionMergePartial<Record>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Record
  ): Record {
    const message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string chrom */ 1:
          message.chrom = reader.string()
          break
        case /* int32 pos */ 2:
          message.pos = reader.int32()
          break
        case /* string ref_allele */ 3:
          message.refAllele = reader.string()
          break
        case /* string alt_allele */ 4:
          message.altAllele = reader.string()
          break
        case /* repeated annonars.gnomad.gnomad3.Filter filters */ 5:
          if (wireType === WireType.LengthDelimited)
            for (let e = reader.int32() + reader.pos; reader.pos < e; )
              message.filters.push(reader.int32())
          else message.filters.push(reader.int32())
          break
        case /* repeated annonars.gnomad.vep_gnomad3.Vep vep */ 6:
          message.vep.push(Vep.internalBinaryRead(reader, reader.uint32(), options))
          break
        case /* repeated annonars.gnomad.gnomad3.CohortAlleleCounts allele_counts */ 7:
          message.alleleCounts.push(
            CohortAlleleCounts.internalBinaryRead(reader, reader.uint32(), options)
          )
          break
        case /* bool nonpar */ 8:
          message.nonpar = reader.bool()
          break
        case /* optional annonars.gnomad.gnomad3.EffectInfo effect_info */ 9:
          message.effectInfo = EffectInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.effectInfo
          )
          break
        case /* optional annonars.gnomad.gnomad3.VariantInfo variant_info */ 10:
          message.variantInfo = VariantInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.variantInfo
          )
          break
        case /* optional annonars.gnomad.gnomad3.QualityInfo quality_info */ 11:
          message.qualityInfo = QualityInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.qualityInfo
          )
          break
        case /* optional annonars.gnomad.gnomad3.AgeInfo age_info */ 12:
          message.ageInfo = AgeInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.ageInfo
          )
          break
        case /* optional annonars.gnomad.gnomad3.DepthInfo depth_info */ 13:
          message.depthInfo = DepthInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.depthInfo
          )
          break
        default:
          const u = options.readUnknownField
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            )
          const d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Record,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string chrom = 1; */
    if (message.chrom !== '') writer.tag(1, WireType.LengthDelimited).string(message.chrom)
    /* int32 pos = 2; */
    if (message.pos !== 0) writer.tag(2, WireType.Varint).int32(message.pos)
    /* string ref_allele = 3; */
    if (message.refAllele !== '') writer.tag(3, WireType.LengthDelimited).string(message.refAllele)
    /* string alt_allele = 4; */
    if (message.altAllele !== '') writer.tag(4, WireType.LengthDelimited).string(message.altAllele)
    /* repeated annonars.gnomad.gnomad3.Filter filters = 5; */
    if (message.filters.length) {
      writer.tag(5, WireType.LengthDelimited).fork()
      for (let i = 0; i < message.filters.length; i++) writer.int32(message.filters[i])
      writer.join()
    }
    /* repeated annonars.gnomad.vep_gnomad3.Vep vep = 6; */
    for (let i = 0; i < message.vep.length; i++)
      Vep.internalBinaryWrite(
        message.vep[i],
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* repeated annonars.gnomad.gnomad3.CohortAlleleCounts allele_counts = 7; */
    for (let i = 0; i < message.alleleCounts.length; i++)
      CohortAlleleCounts.internalBinaryWrite(
        message.alleleCounts[i],
        writer.tag(7, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* bool nonpar = 8; */
    if (message.nonpar !== false) writer.tag(8, WireType.Varint).bool(message.nonpar)
    /* optional annonars.gnomad.gnomad3.EffectInfo effect_info = 9; */
    if (message.effectInfo)
      EffectInfo.internalBinaryWrite(
        message.effectInfo,
        writer.tag(9, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.gnomad.gnomad3.VariantInfo variant_info = 10; */
    if (message.variantInfo)
      VariantInfo.internalBinaryWrite(
        message.variantInfo,
        writer.tag(10, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.gnomad.gnomad3.QualityInfo quality_info = 11; */
    if (message.qualityInfo)
      QualityInfo.internalBinaryWrite(
        message.qualityInfo,
        writer.tag(11, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.gnomad.gnomad3.AgeInfo age_info = 12; */
    if (message.ageInfo)
      AgeInfo.internalBinaryWrite(
        message.ageInfo,
        writer.tag(12, WireType.LengthDelimited).fork(),
        options
      ).join()
    /* optional annonars.gnomad.gnomad3.DepthInfo depth_info = 13; */
    if (message.depthInfo)
      DepthInfo.internalBinaryWrite(
        message.depthInfo,
        writer.tag(13, WireType.LengthDelimited).fork(),
        options
      ).join()
    const u = options.writeUnknownFields
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer)
    return writer
  }
}
/**
 * @generated MessageType for protobuf message annonars.gnomad.gnomad3.Record
 */
export const Record = new Record$Type()
